<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PlayRho: playrho Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlayRho
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">An Interactive Real-Time-Oriented C++ Physics Engine &amp; Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceplayrho.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">playrho Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Name space for all PlayRho related names.  
<a href="namespaceplayrho.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceplayrho_1_1d2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho_1_1d2.html">d2</a></td></tr>
<tr class="memdesc:namespaceplayrho_1_1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name space for 2-dimensionally related PlayRho names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplayrho_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceplayrho_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name space for internal/detail related PlayRho names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1AllocatedArray.html">AllocatedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocated Array.  <a href="classplayrho_1_1AllocatedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ArrayAllocator.html">ArrayAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array allocator.  <a href="classplayrho_1_1ArrayAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array list.  <a href="classplayrho_1_1ArrayList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1BlockAllocator_1_1Block.html" title="Block.">Block</a> allocator.  <a href="classplayrho_1_1BlockAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1BlockDeallocator.html">BlockDeallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block deallocator.  <a href="structplayrho_1_1BlockDeallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checked value.  <a href="classplayrho_1_1CheckedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint solver configuration data.  <a href="structplayrho_1_1ConstraintSolverConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contact Feature.  <a href="structplayrho_1_1ContactFeature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key value class for contacts.  <a href="classplayrho_1_1ContactKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A holder for contact filtering data.  <a href="structplayrho_1_1Filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1FiniteChecker.html">FiniteChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite constrained value checker.  <a href="structplayrho_1_1FiniteChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for fixed-point numbers.  <a href="classplayrho_1_1Fixed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1FlagGuard.html">FlagGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag guard type.  <a href="classplayrho_1_1FlagGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1GrowableStack.html">GrowableStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a growable LIFO stack with an initial capacity of N. If the stack size exceeds the initial capacity, the heap is used to increase the size of the stack.  <a href="classplayrho_1_1GrowableStack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasFunctor.html">HasFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-functor trait template fallback class.  <a href="structplayrho_1_1HasFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasFunctor_3_01Type_00_01Return_07Args_8_8_8_08_4.html">HasFunctor&lt; Type, Return(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-functor trait template class.  <a href="structplayrho_1_1HasFunctor_3_01Type_00_01Return_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType.html">HasType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait template class.  <a href="structplayrho_1_1HasType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_01_4.html">HasType&lt; T, std::tuple&lt; T, Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait true class.  <a href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01T_00_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01U_00_01Ts_8_8_8_01_4_01_4.html">HasType&lt; T, std::tuple&lt; U, Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait template super class.  <a href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_01U_00_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_4_01_4.html">HasType&lt; T, std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has-type trait template class specialized for <code>std::tuple</code> classes.  <a href="structplayrho_1_1HasType_3_01T_00_01std_1_1tuple_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classplayrho_1_1Interval.html" title="Interval template type.">Interval</a> template type.  <a href="classplayrho_1_1Interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1InvalidArgument.html">InvalidArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid argument logic error.  <a href="classplayrho_1_1InvalidArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsAddable.html">IsAddable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for determining if the given types are addable.  <a href="structplayrho_1_1IsAddable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsAddable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_09T2_02_03_08_4_01_4.html">IsAddable&lt; T1, T2, std::void_t&lt; decltype(T1{}+T2{})&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specializing for addable types.  <a href="structplayrho_1_1IsAddable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_09T2_02_03_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsArithmetic.html">IsArithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for determining if the given type is an "arithmetic" type.  <a href="structplayrho_1_1IsArithmetic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsArithmetic_3_01T_00_01std_1_1void__t_3_01decltype_07T_02_03_09T_02_03_08_00_0e30487095fcbd3150b7b99d467763a14.html">IsArithmetic&lt; T, std::void_t&lt; decltype(T{}+T{}), decltype(T{} - T{}), decltype(T{} *T{}), decltype(T{}/T{})&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for valid/acceptable "arithmetic" types.  <a href="structplayrho_1_1IsArithmetic_3_01T_00_01std_1_1void__t_3_01decltype_07T_02_03_09T_02_03_08_00_0e30487095fcbd3150b7b99d467763a14.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsDivisable.html">IsDivisable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for determining if the given types are divisable.  <a href="structplayrho_1_1IsDivisable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsDivisable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_2T2_02_03_08_4_01_4.html">IsDivisable&lt; T1, T2, std::void_t&lt; decltype(T1{}/T2{})&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specializing for divisable types.  <a href="structplayrho_1_1IsDivisable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_2T2_02_03_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsEqualityComparable.html">IsEqualityComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for determining if the given type is an equality comparable type.  <a href="structplayrho_1_1IsEqualityComparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsEqualityComparable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_0a_0aT2_02_03_08_4_01_4.html">IsEqualityComparable&lt; T1, T2, std::void_t&lt; decltype(T1{}==T2{})&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for equality comparable types.  <a href="structplayrho_1_1IsEqualityComparable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_0a_0aT2_02_03_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsInequalityComparable.html">IsInequalityComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for determining if the given type is an inequality comparable type.  <a href="structplayrho_1_1IsInequalityComparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsInequalityComparable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_01_9_0aT2_02_03_08_4_01_4.html">IsInequalityComparable&lt; T1, T2, std::void_t&lt; decltype(T1{} !=T2{})&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for inequality comparable types.  <a href="structplayrho_1_1IsInequalityComparable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_01_9_0aT2_02_03_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IslandStats.html">IslandStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Island solver statistics.  <a href="structplayrho_1_1IslandStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMatrix.html">IsMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class for checking if type is a matrix type.  <a href="structplayrho_1_1IsMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMatrix_3_01Vector_3_01Vector_3_01T_00_01N_01_4_00_01M_01_4_01_4.html">IsMatrix&lt; Vector&lt; Vector&lt; T, N &gt;, M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class specialization for checking if type is a matrix type.  <a href="structplayrho_1_1IsMatrix_3_01Vector_3_01Vector_3_01T_00_01N_01_4_00_01M_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for determining if the given types are multipliable.  <a href="structplayrho_1_1IsMultipliable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsMultipliable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_01_5T2_02_03_08_4_01_4.html">IsMultipliable&lt; T1, T2, std::void_t&lt; decltype(T1{} *T2{})&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specializing for multipliable types.  <a href="structplayrho_1_1IsMultipliable_3_01T1_00_01T2_00_01std_1_1void__t_3_01decltype_07T1_02_03_01_5T2_02_03_08_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsSquareMatrix.html">IsSquareMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class for checking if type is a square matrix type.  <a href="structplayrho_1_1IsSquareMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsSquareMatrix_3_01Vector_3_01Vector_3_01T_00_01M_01_4_00_01M_01_4_01_4.html">IsSquareMatrix&lt; Vector&lt; Vector&lt; T, M &gt;, M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class specialization for checking if type is a square matrix type.  <a href="structplayrho_1_1IsSquareMatrix_3_01Vector_3_01Vector_3_01T_00_01M_01_4_00_01M_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsVector.html">IsVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class for checking if type is a <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a></code> type.  <a href="structplayrho_1_1IsVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IsVector_3_01Vector_3_01T_00_01N_01_4_01_4.html">IsVector&lt; Vector&lt; T, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class specialization for checking if type is a <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a></code> type..  <a href="structplayrho_1_1IsVector_3_01Vector_3_01T_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1LengthError.html">LengthError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length based logic error.  <a href="classplayrho_1_1LengthError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LengthIndexPair.html">LengthIndexPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A length associated with two vertex counter indices.  <a href="structplayrho_1_1LengthIndexPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalGreater.html">LexicographicalGreater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical greater-than comparisons of containers.  <a href="structplayrho_1_1LexicographicalGreater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalGreaterEqual.html">LexicographicalGreaterEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical greater-than or equal-to comparisons of containers.  <a href="structplayrho_1_1LexicographicalGreaterEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalLess.html">LexicographicalLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical less-than comparisons of containers.  <a href="structplayrho_1_1LexicographicalLess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalLessEqual.html">LexicographicalLessEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical less-than or equal-to comparisons of containers.  <a href="structplayrho_1_1LexicographicalLessEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Movement configuration.  <a href="structplayrho_1_1MovementConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1NegativeChecker.html">NegativeChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative constrained value checker.  <a href="structplayrho_1_1NegativeChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1NonNegativeChecker.html">NonNegativeChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative constrained value checker.  <a href="structplayrho_1_1NonNegativeChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1NonPositiveChecker.html">NonPositiveChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-positive constrained value checker.  <a href="structplayrho_1_1NonPositiveChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1NonZeroChecker.html">NonZeroChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero constrained value checker.  <a href="structplayrho_1_1NonZeroChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1NoOpChecker.html">NoOpChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op value checker.  <a href="structplayrho_1_1NoOpChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1PointStates.html">PointStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point states.  <a href="structplayrho_1_1PointStates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1PositiveChecker.html">PositiveChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive constrained value checker.  <a href="structplayrho_1_1PositiveChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1PreStepStats.html">PreStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-phase per-step statistics.  <a href="structplayrho_1_1PreStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1propagate__const.html">propagate_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant propagating template wrapper type.  <a href="classplayrho_1_1propagate__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template range value class.  <a href="classplayrho_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular-phase per-step statistics.  <a href="structplayrho_1_1RegStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1SizedRange.html">SizedRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template sized range value class.  <a href="classplayrho_1_1SizedRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ encapsulation of an array and its size.  <a href="classplayrho_1_1Span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1StackAllocator.html">StackAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack allocator.  <a href="classplayrho_1_1StackAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1StepConf.html">StepConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step configuration.  <a href="structplayrho_1_1StepConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1StepStats.html">StepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-step statistics.  <a href="structplayrho_1_1StepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ToiConf.html">ToiConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time of impact configuration.  <a href="structplayrho_1_1ToiConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TOIOutput.html">TOIOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output data for time of impact.  <a href="structplayrho_1_1TOIOutput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ToiStepStats.html">ToiStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TOI-phase per-step statistics.  <a href="structplayrho_1_1ToiStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo.html">TypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information.  <a href="structplayrho_1_1TypeInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1DistanceJointConf_01_4.html">TypeInfo&lt; d2::DistanceJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html" title="Distance joint definition.">d2::DistanceJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1DistanceJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1FrictionJointConf_01_4.html">TypeInfo&lt; d2::FrictionJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1FrictionJointConf.html" title="Friction joint definition.">d2::FrictionJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1FrictionJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1GearJointConf_01_4.html">TypeInfo&lt; d2::GearJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html" title="Gear joint definition.">d2::GearJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1GearJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1MotorJointConf_01_4.html">TypeInfo&lt; d2::MotorJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1MotorJointConf.html" title="Motor joint definition.">d2::MotorJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1MotorJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1PrismaticJointConf_01_4.html">TypeInfo&lt; d2::PrismaticJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html" title="Prismatic joint definition.">d2::PrismaticJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1PrismaticJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1PulleyJointConf_01_4.html">TypeInfo&lt; d2::PulleyJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html" title="Pulley joint definition.">d2::PulleyJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1PulleyJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1RevoluteJointConf_01_4.html">TypeInfo&lt; d2::RevoluteJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html" title="Revolute joint definition.">d2::RevoluteJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1RevoluteJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1RopeJointConf_01_4.html">TypeInfo&lt; d2::RopeJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html" title="Rope joint definition.">d2::RopeJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1RopeJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1TargetJointConf_01_4.html">TypeInfo&lt; d2::TargetJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html" title="Target joint definition.">d2::TargetJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1TargetJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1WeldJointConf_01_4.html">TypeInfo&lt; d2::WeldJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html" title="Weld joint definition.">d2::WeldJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1WeldJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01d2_1_1WheelJointConf_01_4.html">TypeInfo&lt; d2::WheelJointConf &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code><a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html" title="Wheel joint definition.">d2::WheelJointConf</a></code>.  <a href="structplayrho_1_1TypeInfo_3_01d2_1_1WheelJointConf_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01double_01_4.html">TypeInfo&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code>double</code>.  <a href="structplayrho_1_1TypeInfo_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01Fixed32_01_4.html">TypeInfo&lt; Fixed32 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code>Fixed32</code>.  <a href="structplayrho_1_1TypeInfo_3_01Fixed32_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01float_01_4.html">TypeInfo&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code>float</code>.  <a href="structplayrho_1_1TypeInfo_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1TypeInfo_3_01long_01double_01_4.html">TypeInfo&lt; long double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type info specialization for <code>long double</code>.  <a href="structplayrho_1_1TypeInfo_3_01long_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1underlying__type.html">underlying_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying-type template class.  <a href="structplayrho_1_1underlying__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1underlying__type_3_01detail_1_1IndexingNamedType_3_01T_00_01Tag_01_4_01_4.html">underlying_type&lt; detail::IndexingNamedType&lt; T, Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying-type template class for <code><a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html" title="An indexable, hashable, named &quot;strong type&quot; template class.">detail::IndexingNamedType</a></code> types.  <a href="structplayrho_1_1underlying__type_3_01detail_1_1IndexingNamedType_3_01T_00_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1underlying__type_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__enum__v_3_01T_01_4_01_4_01_4.html">underlying_type&lt; T, std::enable_if_t&lt; std::is_enum_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying-type class specialization for enum types.  <a href="structplayrho_1_1underlying__type_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__enum__v_3_01T_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1UnitIntervalChecker.html">UnitIntervalChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit-interval constrained value checker.  <a href="structplayrho_1_1UnitIntervalChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>.  <a href="structplayrho_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Version.html" title="Version numbering scheme.">Version</a> numbering scheme.  <a href="structplayrho_1_1Version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider.html">Wider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> data type obtainer.  <a href="structplayrho_1_1Wider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01double_01_4.html">Wider&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for double.  <a href="structplayrho_1_1Wider_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01float_01_4.html">Wider&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for float.  <a href="structplayrho_1_1Wider_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1int16__t_01_4.html">Wider&lt; std::int16_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for signed 16-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1int16__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1int32__t_01_4.html">Wider&lt; std::int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for signed 32-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1int8__t_01_4.html">Wider&lt; std::int8_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for signed 8-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1int8__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1uint16__t_01_4.html">Wider&lt; std::uint16_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for unsigned 16-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1uint16__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1uint32__t_01_4.html">Wider&lt; std::uint32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for unsigned 32-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1uint32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Wider_3_01std_1_1uint8__t_01_4.html">Wider&lt; std::uint8_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="structplayrho_1_1Wider.html" title="Wider data type obtainer.">Wider</a> trait for unsigned 8-bit integers.  <a href="structplayrho_1_1Wider_3_01std_1_1uint8__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1WrongState.html">WrongState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrong state logic error.  <a href="classplayrho_1_1WrongState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae444a62491fcb2b10f0f06a41b1ac406"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">PairLength2</a> = std::pair&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>, <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;</td></tr>
<tr class="memdesc:ae444a62491fcb2b10f0f06a41b1ac406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of <code>Length2</code> values.  <a href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">More...</a><br /></td></tr>
<tr class="separator:ae444a62491fcb2b10f0f06a41b1ac406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d449e0a1528c10ae0f241713fb69b40"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a> = std::pair&lt; <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>, <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a> &gt;</td></tr>
<tr class="memdesc:a7d449e0a1528c10ae0f241713fb69b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index pair.  <a href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">More...</a><br /></td></tr>
<tr class="separator:a7d449e0a1528c10ae0f241713fb69b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704da3b24d9b1f9135e140dcd5420518"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> = std::array&lt; <a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>, <a class="el" href="namespaceplayrho.html#a95591102a273a4d301f3f795d463b9ba">MaxSimplexEdges</a> &gt;</td></tr>
<tr class="memdesc:a704da3b24d9b1f9135e140dcd5420518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of three index-pair elements.  <a href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">More...</a><br /></td></tr>
<tr class="separator:a704da3b24d9b1f9135e140dcd5420518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8c8047429035c030e233c9503cbec9"><td class="memTemplParams" colspan="2"><a id="a0a8c8047429035c030e233c9503cbec9"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a0a8c8047429035c030e233c9503cbec9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0a8c8047429035c030e233c9503cbec9">VertexCounterArray</a> = std::array&lt; <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>, N &gt;</td></tr>
<tr class="memdesc:a0a8c8047429035c030e233c9503cbec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex counter array template alias. <br /></td></tr>
<tr class="separator:a0a8c8047429035c030e233c9503cbec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="memItemLeft" align="right" valign="top"><a id="ae2ea03f9c65d074dfd1aa21b6352f293"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae2ea03f9c65d074dfd1aa21b6352f293">VertexCounter2</a> = <a class="el" href="namespaceplayrho.html#a0a8c8047429035c030e233c9503cbec9">VertexCounterArray</a>&lt; 2 &gt;</td></tr>
<tr class="memdesc:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vertex counter array. <br /></td></tr>
<tr class="separator:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37a2881e65f48db22b37ebdf8a2075e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae37a2881e65f48db22b37ebdf8a2075e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#gae37a2881e65f48db22b37ebdf8a2075e">DefaultCheckedValue</a> = <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gae37a2881e65f48db22b37ebdf8a2075e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default checked value type.  <a href="group__CheckedValues.html#gae37a2881e65f48db22b37ebdf8a2075e">More...</a><br /></td></tr>
<tr class="separator:gae37a2881e65f48db22b37ebdf8a2075e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46783d843137ba60b696139078119dec"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga46783d843137ba60b696139078119dec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#ga46783d843137ba60b696139078119dec">Finite</a> = <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1FiniteChecker.html">FiniteChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga46783d843137ba60b696139078119dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite constrained value type. <br /></td></tr>
<tr class="separator:ga46783d843137ba60b696139078119dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e61fee8a0be399ed24773ebc3135f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> = <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; std::int32_t, 9 &gt;</td></tr>
<tr class="memdesc:a51e61fee8a0be399ed24773ebc3135f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit fixed precision type.  <a href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">More...</a><br /></td></tr>
<tr class="separator:a51e61fee8a0be399ed24773ebc3135f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f10d34cd7e0d7f7cbbafb638373818"><td class="memTemplParams" colspan="2"><a id="a79f10d34cd7e0d7f7cbbafb638373818"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a79f10d34cd7e0d7f7cbbafb638373818"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a79f10d34cd7e0d7f7cbbafb638373818">underlying_type_t</a> = typename <a class="el" href="structplayrho_1_1underlying__type.html">underlying_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a79f10d34cd7e0d7f7cbbafb638373818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying-type convenience alias. <br /></td></tr>
<tr class="separator:a79f10d34cd7e0d7f7cbbafb638373818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;, M &gt;</td></tr>
<tr class="memdesc:acbf97bd8e3f0f2ce4588735388f4089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic M by N matrix.  <a href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">More...</a><br /></td></tr>
<tr class="separator:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aabbb6723402cb9e12cf32e17beebc"><td class="memTemplParams" colspan="2"><a id="a26aabbb6723402cb9e12cf32e17beebc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26aabbb6723402cb9e12cf32e17beebc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a> = <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, 2, 2 &gt;</td></tr>
<tr class="memdesc:a26aabbb6723402cb9e12cf32e17beebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix. <br /></td></tr>
<tr class="separator:a26aabbb6723402cb9e12cf32e17beebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memTemplParams" colspan="2"><a id="a92e228aada1d7ca23d9f6c2c9ce3b415"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a92e228aada1d7ca23d9f6c2c9ce3b415">Matrix33</a> = <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, 3, 3 &gt;</td></tr>
<tr class="memdesc:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 matrix. <br /></td></tr>
<tr class="separator:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c09bb6556e3168c0085871358d2f71"><td class="memItemLeft" align="right" valign="top"><a id="a02c09bb6556e3168c0085871358d2f71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:a02c09bb6556e3168c0085871358d2f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of Real elements. <br /></td></tr>
<tr class="separator:a02c09bb6556e3168c0085871358d2f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358c8036b278316ab41b3f35b56342a1"><td class="memItemLeft" align="right" valign="top"><a id="a358c8036b278316ab41b3f35b56342a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a358c8036b278316ab41b3f35b56342a1">Mass22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> &gt;</td></tr>
<tr class="memdesc:a358c8036b278316ab41b3f35b56342a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of Mass elements. <br /></td></tr>
<tr class="separator:a358c8036b278316ab41b3f35b56342a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="memItemLeft" align="right" valign="top"><a id="a507cf0b47bd41371f90aa8f78f1d7c8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a507cf0b47bd41371f90aa8f78f1d7c8a">InvMass22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga9b387148008099ec9d37dbcf1f1a1571">InvMass</a> &gt;</td></tr>
<tr class="memdesc:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of <code>InvMass</code> elements. <br /></td></tr>
<tr class="separator:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="memItemLeft" align="right" valign="top"><a id="aabd44d74c5bc530c9b6676c6a61e6b31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> = <a class="el" href="namespaceplayrho.html#a92e228aada1d7ca23d9f6c2c9ce3b415">Matrix33</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 matrix of Real elements. <br /></td></tr>
<tr class="separator:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69142355b498ed0ff7ec9ee8aec5d7d"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab69142355b498ed0ff7ec9ee8aec5d7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#gab69142355b498ed0ff7ec9ee8aec5d7d">Negative</a> = <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1NegativeChecker.html">NegativeChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gab69142355b498ed0ff7ec9ee8aec5d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative constrained value type. <br /></td></tr>
<tr class="separator:gab69142355b498ed0ff7ec9ee8aec5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac74ec9c65c8f22cefed941aa486af9e3"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac74ec9c65c8f22cefed941aa486af9e3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a> = <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1NonNegativeChecker.html">NonNegativeChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gac74ec9c65c8f22cefed941aa486af9e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative constrained value type. <br /></td></tr>
<tr class="separator:gac74ec9c65c8f22cefed941aa486af9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7595073697fcf149a7828d5ea96c23d"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae7595073697fcf149a7828d5ea96c23d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#gae7595073697fcf149a7828d5ea96c23d">NonPositive</a> = <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1NonPositiveChecker.html">NonPositiveChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gae7595073697fcf149a7828d5ea96c23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-positive constrained value type. <br /></td></tr>
<tr class="separator:gae7595073697fcf149a7828d5ea96c23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78bf6648df130b547bb5e79e3dcb9a74"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga78bf6648df130b547bb5e79e3dcb9a74"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#ga78bf6648df130b547bb5e79e3dcb9a74">NonZero</a> = std::enable_if_t&lt;!std::is_pointer&lt; T &gt;::value, <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1NonZeroChecker.html">NonZeroChecker</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga78bf6648df130b547bb5e79e3dcb9a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero constrained value type. <br /></td></tr>
<tr class="separator:ga78bf6648df130b547bb5e79e3dcb9a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6765653a298365f410348651dff5b088"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6765653a298365f410348651dff5b088"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#ga6765653a298365f410348651dff5b088">NonNull</a> = std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value, <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1NonZeroChecker.html">NonZeroChecker</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga6765653a298365f410348651dff5b088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-null constrained value type. <br /></td></tr>
<tr class="separator:ga6765653a298365f410348651dff5b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68f6ae626f30553fcc05b6d944bae742"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga68f6ae626f30553fcc05b6d944bae742"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#ga68f6ae626f30553fcc05b6d944bae742">Positive</a> = <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1PositiveChecker.html">PositiveChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga68f6ae626f30553fcc05b6d944bae742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive constrained value type. <br /></td></tr>
<tr class="separator:ga68f6ae626f30553fcc05b6d944bae742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc125070a08100d083a1360f7167f87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> = float</td></tr>
<tr class="memdesc:a1fc125070a08100d083a1360f7167f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-number type.  <a href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">More...</a><br /></td></tr>
<tr class="separator:a1fc125070a08100d083a1360f7167f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed352724e203ca09595faf0dc6a76e5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#af33623a59b7c701aead6d06e88dc2cc6">MaxChildCount</a>)&gt;::type</td></tr>
<tr class="memdesc:aed352724e203ca09595faf0dc6a76e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child counter type.  <a href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">More...</a><br /></td></tr>
<tr class="separator:aed352724e203ca09595faf0dc6a76e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3898807006fd29cd5c4fc2e1a9cf5536">TimestepIters</a> = std::uint8_t</td></tr>
<tr class="memdesc:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time step iterations type.  <a href="namespaceplayrho.html#a3898807006fd29cd5c4fc2e1a9cf5536">More...</a><br /></td></tr>
<tr class="separator:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16da705f1b3c51c7fd1b9b1162c258b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">MaxShapeVertices</a>)&gt;::type</td></tr>
<tr class="memdesc:a16da705f1b3c51c7fd1b9b1162c258b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex count type.  <a href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">More...</a><br /></td></tr>
<tr class="separator:a16da705f1b3c51c7fd1b9b1162c258b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fb4e1b050424d59666b3b2b7b6c935"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a15fb4e1b050424d59666b3b2b7b6c935">FixtureCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#af36288c4602f14acd96242145a546980">MaxFixtures</a>)&gt;::type</td></tr>
<tr class="memdesc:a15fb4e1b050424d59666b3b2b7b6c935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter type for fixtures.  <a href="namespaceplayrho.html#a15fb4e1b050424d59666b3b2b7b6c935">More...</a><br /></td></tr>
<tr class="separator:a15fb4e1b050424d59666b3b2b7b6c935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4106d8a0e998a2485196534514527a5a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">BodyCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>)&gt;::type</td></tr>
<tr class="memdesc:a4106d8a0e998a2485196534514527a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count type for bodies.  <a href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">More...</a><br /></td></tr>
<tr class="separator:a4106d8a0e998a2485196534514527a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf0674233f83e8b83b30db98332e129"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a> = <a class="el" href="structplayrho_1_1Wider.html">Wider</a>&lt; <a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">BodyCounter</a> &gt;::type</td></tr>
<tr class="memdesc:a2bf0674233f83e8b83b30db98332e129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count type for contacts.  <a href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">More...</a><br /></td></tr>
<tr class="separator:a2bf0674233f83e8b83b30db98332e129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8ea60dc388d1e92e2e6fa277a32495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aeb8ea60dc388d1e92e2e6fa277a32495">JointCounter</a> = std::remove_const&lt; decltype(<a class="el" href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">MaxJoints</a>)&gt;::type</td></tr>
<tr class="memdesc:aeb8ea60dc388d1e92e2e6fa277a32495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter type for joints.  <a href="namespaceplayrho.html#aeb8ea60dc388d1e92e2e6fa277a32495">More...</a><br /></td></tr>
<tr class="separator:aeb8ea60dc388d1e92e2e6fa277a32495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4708d38a866c6ebc70da3939d5edc8dc"><td class="memTemplParams" colspan="2"><a id="a4708d38a866c6ebc70da3939d5edc8dc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4708d38a866c6ebc70da3939d5edc8dc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4708d38a866c6ebc70da3939d5edc8dc">IsIterable</a> = typename <a class="el" href="structplayrho_1_1detail_1_1IsIterableImpl.html">detail::IsIterableImpl</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a4708d38a866c6ebc70da3939d5edc8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is an iterable type. <br /></td></tr>
<tr class="separator:a4708d38a866c6ebc70da3939d5edc8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a9fb888eae63605b73b61c61ccd17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a592a9fb888eae63605b73b61c61ccd17"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a592a9fb888eae63605b73b61c61ccd17">TupleContainsType</a> = typename <a class="el" href="structplayrho_1_1HasType.html">HasType</a>&lt; T, Tuple &gt;::type</td></tr>
<tr class="memdesc:a592a9fb888eae63605b73b61c61ccd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple contains type alias.  <a href="namespaceplayrho.html#a592a9fb888eae63605b73b61c61ccd17">More...</a><br /></td></tr>
<tr class="separator:a592a9fb888eae63605b73b61c61ccd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c300db3a063bd5b4c1d947cc302577"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Return &gt; </td></tr>
<tr class="memitem:ad9c300db3a063bd5b4c1d947cc302577"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad9c300db3a063bd5b4c1d947cc302577">HasNullaryFunctor</a> = <a class="el" href="structplayrho_1_1HasFunctor.html">HasFunctor</a>&lt; Type, Return()&gt;</td></tr>
<tr class="memdesc:ad9c300db3a063bd5b4c1d947cc302577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has nullary functor type alias.  <a href="namespaceplayrho.html#ad9c300db3a063bd5b4c1d947cc302577">More...</a><br /></td></tr>
<tr class="separator:ad9c300db3a063bd5b4c1d947cc302577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd75892346a971d244693bb9d97a33e"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Return , typename Arg &gt; </td></tr>
<tr class="memitem:acbd75892346a971d244693bb9d97a33e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acbd75892346a971d244693bb9d97a33e">HasUnaryFunctor</a> = <a class="el" href="structplayrho_1_1HasFunctor.html">HasFunctor</a>&lt; Type, Return(Arg)&gt;</td></tr>
<tr class="memdesc:acbd75892346a971d244693bb9d97a33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has unary functor type alias.  <a href="namespaceplayrho.html#acbd75892346a971d244693bb9d97a33e">More...</a><br /></td></tr>
<tr class="separator:acbd75892346a971d244693bb9d97a33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922c3472852863ed46d7551b1dd8ba9d"><td class="memItemLeft" align="right" valign="top"><a id="a922c3472852863ed46d7551b1dd8ba9d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; const char *const *, struct TypeIdentifier &gt;</td></tr>
<tr class="memdesc:a922c3472852863ed46d7551b1dd8ba9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type identifier. <br /></td></tr>
<tr class="separator:a922c3472852863ed46d7551b1dd8ba9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdc100fb69df2f2d3726be076c6b9501"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabdc100fb69df2f2d3726be076c6b9501"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedValues.html#gabdc100fb69df2f2d3726be076c6b9501">UnitInterval</a> = <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; T, <a class="el" href="structplayrho_1_1UnitIntervalChecker.html">UnitIntervalChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gabdc100fb69df2f2d3726be076c6b9501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit interval constrained value type. <br /></td></tr>
<tr class="separator:gabdc100fb69df2f2d3726be076c6b9501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250898c9929b0e6eaf56a1967c568888"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a> = PLAYRHO_QUANTITY(boost::units::si::time)</td></tr>
<tr class="memdesc:ga250898c9929b0e6eaf56a1967c568888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time quantity.  <a href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">More...</a><br /></td></tr>
<tr class="separator:ga250898c9929b0e6eaf56a1967c568888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39135cf298be76964c70829ec84a51e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a> = PLAYRHO_QUANTITY(boost::units::si::frequency)</td></tr>
<tr class="memdesc:gad39135cf298be76964c70829ec84a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency quantity.  <a href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">More...</a><br /></td></tr>
<tr class="separator:gad39135cf298be76964c70829ec84a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7361ef2e10e7853a05b64aa433651014"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> = PLAYRHO_QUANTITY(boost::units::si::length)</td></tr>
<tr class="memdesc:ga7361ef2e10e7853a05b64aa433651014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length quantity.  <a href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">More...</a><br /></td></tr>
<tr class="separator:ga7361ef2e10e7853a05b64aa433651014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e944c18ed210626b5829b8ad2813fde"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a> = PLAYRHO_QUANTITY(boost::units::si::velocity)</td></tr>
<tr class="memdesc:ga6e944c18ed210626b5829b8ad2813fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear velocity quantity.  <a href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">More...</a><br /></td></tr>
<tr class="separator:ga6e944c18ed210626b5829b8ad2813fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf7de472e7f4a6fa26bff6a655f100e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a> = PLAYRHO_QUANTITY(boost::units::si::acceleration)</td></tr>
<tr class="memdesc:gadf7de472e7f4a6fa26bff6a655f100e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear acceleration quantity.  <a href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">More...</a><br /></td></tr>
<tr class="separator:gadf7de472e7f4a6fa26bff6a655f100e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5edfc295416b7690b4f949223b551bc1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> = PLAYRHO_QUANTITY(boost::units::si::mass)</td></tr>
<tr class="memdesc:ga5edfc295416b7690b4f949223b551bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mass quantity.  <a href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">More...</a><br /></td></tr>
<tr class="separator:ga5edfc295416b7690b4f949223b551bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b387148008099ec9d37dbcf1f1a1571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga9b387148008099ec9d37dbcf1f1a1571">InvMass</a> = PLAYRHO_QUANTITY(playrho::units::si::inverse_mass)</td></tr>
<tr class="memdesc:ga9b387148008099ec9d37dbcf1f1a1571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse mass quantity.  <a href="group__PhysicalQuantities.html#ga9b387148008099ec9d37dbcf1f1a1571">More...</a><br /></td></tr>
<tr class="separator:ga9b387148008099ec9d37dbcf1f1a1571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea2a7de91fdafccb2e49c3a84117ab5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> = PLAYRHO_QUANTITY(boost::units::si::area)</td></tr>
<tr class="memdesc:ga3ea2a7de91fdafccb2e49c3a84117ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area quantity.  <a href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">More...</a><br /></td></tr>
<tr class="separator:ga3ea2a7de91fdafccb2e49c3a84117ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga534c92a63631b49d1e80119a68af8a4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a> = PLAYRHO_QUANTITY(boost::units::si::surface_density)</td></tr>
<tr class="memdesc:ga534c92a63631b49d1e80119a68af8a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area (surface) density quantity.  <a href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">More...</a><br /></td></tr>
<tr class="separator:ga534c92a63631b49d1e80119a68af8a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab999341c050df340ff56a65816a63da9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> = PLAYRHO_QUANTITY(boost::units::si::plane_angle)</td></tr>
<tr class="memdesc:gab999341c050df340ff56a65816a63da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angle quantity.  <a href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">More...</a><br /></td></tr>
<tr class="separator:gab999341c050df340ff56a65816a63da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33f92018f7e8821550296aece465028"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a> = PLAYRHO_QUANTITY(boost::units::si::angular_velocity)</td></tr>
<tr class="memdesc:gac33f92018f7e8821550296aece465028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular velocity quantity.  <a href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">More...</a><br /></td></tr>
<tr class="separator:gac33f92018f7e8821550296aece465028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcce543a0d59f313adb801e2e18ede86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gafcce543a0d59f313adb801e2e18ede86">AngularAcceleration</a> = PLAYRHO_QUANTITY(boost::units::si::angular_acceleration)</td></tr>
<tr class="memdesc:gafcce543a0d59f313adb801e2e18ede86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular acceleration quantity.  <a href="group__PhysicalQuantities.html#gafcce543a0d59f313adb801e2e18ede86">More...</a><br /></td></tr>
<tr class="separator:gafcce543a0d59f313adb801e2e18ede86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbf955ed1cafec5062f074511ee4829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a> = PLAYRHO_QUANTITY(boost::units::si::force)</td></tr>
<tr class="memdesc:gabdbf955ed1cafec5062f074511ee4829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force quantity.  <a href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">More...</a><br /></td></tr>
<tr class="separator:gabdbf955ed1cafec5062f074511ee4829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13e620479b6e4a34fae5a90bcaf9355"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a> = PLAYRHO_QUANTITY(boost::units::si::torque)</td></tr>
<tr class="memdesc:gaa13e620479b6e4a34fae5a90bcaf9355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Torque quantity.  <a href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">More...</a><br /></td></tr>
<tr class="separator:gaa13e620479b6e4a34fae5a90bcaf9355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ded7e1044d55beb1ca2957d671ece44"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga9ded7e1044d55beb1ca2957d671ece44">SecondMomentOfArea</a> = PLAYRHO_QUANTITY(playrho::units::si::second_moment_of_area)</td></tr>
<tr class="memdesc:ga9ded7e1044d55beb1ca2957d671ece44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second moment of area quantity.  <a href="group__PhysicalQuantities.html#ga9ded7e1044d55beb1ca2957d671ece44">More...</a><br /></td></tr>
<tr class="separator:ga9ded7e1044d55beb1ca2957d671ece44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67bbb3e4938321efec8d939636bf988e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga67bbb3e4938321efec8d939636bf988e">RotInertia</a> = PLAYRHO_QUANTITY(boost::units::si::moment_of_inertia)</td></tr>
<tr class="memdesc:ga67bbb3e4938321efec8d939636bf988e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotational inertia quantity.  <a href="group__PhysicalQuantities.html#ga67bbb3e4938321efec8d939636bf988e">More...</a><br /></td></tr>
<tr class="separator:ga67bbb3e4938321efec8d939636bf988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5941a3d5c4b22ba991887772a3744de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gad5941a3d5c4b22ba991887772a3744de">InvRotInertia</a> = PLAYRHO_QUANTITY(playrho::units::si::inverse_moment_of_inertia)</td></tr>
<tr class="memdesc:gad5941a3d5c4b22ba991887772a3744de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse rotational inertia quantity.  <a href="group__PhysicalQuantities.html#gad5941a3d5c4b22ba991887772a3744de">More...</a><br /></td></tr>
<tr class="separator:gad5941a3d5c4b22ba991887772a3744de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d281ffd7cf8e2c8897d03a1cae9f1f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a> = PLAYRHO_QUANTITY(boost::units::si::momentum)</td></tr>
<tr class="memdesc:ga1d281ffd7cf8e2c8897d03a1cae9f1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum quantity.  <a href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">More...</a><br /></td></tr>
<tr class="separator:ga1d281ffd7cf8e2c8897d03a1cae9f1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3537d441743bb2f96c612296424f1e43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga3537d441743bb2f96c612296424f1e43">AngularMomentum</a> = PLAYRHO_QUANTITY(boost::units::si::angular_momentum)</td></tr>
<tr class="memdesc:ga3537d441743bb2f96c612296424f1e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular momentum quantity.  <a href="group__PhysicalQuantities.html#ga3537d441743bb2f96c612296424f1e43">More...</a><br /></td></tr>
<tr class="separator:ga3537d441743bb2f96c612296424f1e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97243f194a9406d0fdcf5f6f833851ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97243f194a9406d0fdcf5f6f833851ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 2 &gt;</td></tr>
<tr class="memdesc:a97243f194a9406d0fdcf5f6f833851ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2-elements.  <a href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">More...</a><br /></td></tr>
<tr class="separator:a97243f194a9406d0fdcf5f6f833851ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93c0cd83df090aba6593ffac4b628ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:ad93c0cd83df090aba6593ffac4b628ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2 Real elements.  <a href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">More...</a><br /></td></tr>
<tr class="separator:ad93c0cd83df090aba6593ffac4b628ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> &gt;</td></tr>
<tr class="memdesc:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Length quantities.  <a href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">More...</a><br /></td></tr>
<tr class="separator:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faa31bff8794a0c4191d8b042f7deeb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">LinearVelocity2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a> &gt;</td></tr>
<tr class="memdesc:a2faa31bff8794a0c4191d8b042f7deeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of linear velocity (<code>LinearVelocity</code>) quantities.  <a href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">More...</a><br /></td></tr>
<tr class="separator:a2faa31bff8794a0c4191d8b042f7deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822921028100052d4c6dfb43c7f6c4b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">LinearAcceleration2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a> &gt;</td></tr>
<tr class="memdesc:a5822921028100052d4c6dfb43c7f6c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of linear acceleration (<code>LinearAcceleration</code>) quantities.  <a href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">More...</a><br /></td></tr>
<tr class="separator:a5822921028100052d4c6dfb43c7f6c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d09dc7b51321c052b071485357ca1f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">Force2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a> &gt;</td></tr>
<tr class="memdesc:a2d09dc7b51321c052b071485357ca1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Force quantities.  <a href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">More...</a><br /></td></tr>
<tr class="separator:a2d09dc7b51321c052b071485357ca1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfba2b26f22dcc026361ed5a0ccf3966"><td class="memItemLeft" align="right" valign="top"><a id="acfba2b26f22dcc026361ed5a0ccf3966"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acfba2b26f22dcc026361ed5a0ccf3966">Mass2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> &gt;</td></tr>
<tr class="memdesc:acfba2b26f22dcc026361ed5a0ccf3966"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Mass quantities. <br /></td></tr>
<tr class="separator:acfba2b26f22dcc026361ed5a0ccf3966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f2424eab18780894e83bbc4127fe67"><td class="memItemLeft" align="right" valign="top"><a id="ab4f2424eab18780894e83bbc4127fe67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab4f2424eab18780894e83bbc4127fe67">InvMass2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga9b387148008099ec9d37dbcf1f1a1571">InvMass</a> &gt;</td></tr>
<tr class="memdesc:ab4f2424eab18780894e83bbc4127fe67"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of inverse mass (<code>InvMass</code>) quantities. <br /></td></tr>
<tr class="separator:ab4f2424eab18780894e83bbc4127fe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa6ffb2e67c2e2f620eed088412b146"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">Momentum2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a> &gt;</td></tr>
<tr class="memdesc:a1fa6ffb2e67c2e2f620eed088412b146"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Momentum quantities.  <a href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">More...</a><br /></td></tr>
<tr class="separator:a1fa6ffb2e67c2e2f620eed088412b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 3 &gt;</td></tr>
<tr class="memdesc:ad07b44f811ac4c7551067fb1d3554ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 3-elements.  <a href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">More...</a><br /></td></tr>
<tr class="separator:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f6dcdf3763052ea25099973c7c00ad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:a63f6dcdf3763052ea25099973c7c00ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional column vector with 3 elements.  <a href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">More...</a><br /></td></tr>
<tr class="separator:a63f6dcdf3763052ea25099973c7c00ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996c0271f83c70e94b485ff59bb468a1"><td class="memItemLeft" align="right" valign="top"><a id="a996c0271f83c70e94b485ff59bb468a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a996c0271f83c70e94b485ff59bb468a1">Mass3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a> &gt;</td></tr>
<tr class="memdesc:a996c0271f83c70e94b485ff59bb468a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-element vector of Mass quantities. <br /></td></tr>
<tr class="separator:a996c0271f83c70e94b485ff59bb468a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b57b56d804cd09ae743e670e866d3"><td class="memItemLeft" align="right" valign="top"><a id="a9d3b57b56d804cd09ae743e670e866d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9d3b57b56d804cd09ae743e670e866d3">InvMass3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga9b387148008099ec9d37dbcf1f1a1571">InvMass</a> &gt;</td></tr>
<tr class="memdesc:a9d3b57b56d804cd09ae743e670e866d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-element vector of inverse mass (<code>InvMass</code>) quantities. <br /></td></tr>
<tr class="separator:a9d3b57b56d804cd09ae743e670e866d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d094e8b19ea714a079a48c336abad92"><td class="memItemLeft" align="right" valign="top"><a id="a9d094e8b19ea714a079a48c336abad92"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">BodyCounter</a>, struct BodyIdentifier &gt;</td></tr>
<tr class="memdesc:a9d094e8b19ea714a079a48c336abad92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for bodies. <br /></td></tr>
<tr class="separator:a9d094e8b19ea714a079a48c336abad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7a48a3a0e57fa1a9dd9e396b6b24f7"><td class="memItemLeft" align="right" valign="top"><a id="abe7a48a3a0e57fa1a9dd9e396b6b24f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>, struct ContactIdentifier &gt;</td></tr>
<tr class="memdesc:abe7a48a3a0e57fa1a9dd9e396b6b24f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contact identifier. <br /></td></tr>
<tr class="separator:abe7a48a3a0e57fa1a9dd9e396b6b24f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0ae1f76104ef8214134a5be96027f6"><td class="memItemLeft" align="right" valign="top"><a id="aeb0ae1f76104ef8214134a5be96027f6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aeb0ae1f76104ef8214134a5be96027f6">FixtureID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#a15fb4e1b050424d59666b3b2b7b6c935">FixtureCounter</a>, struct FixtureIdentifier &gt;</td></tr>
<tr class="memdesc:aeb0ae1f76104ef8214134a5be96027f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixture identifier. <br /></td></tr>
<tr class="separator:aeb0ae1f76104ef8214134a5be96027f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3114be8fb50493389d7991db4f2b3d"><td class="memItemLeft" align="right" valign="top"><a id="a8e3114be8fb50493389d7991db4f2b3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#aeb8ea60dc388d1e92e2e6fa277a32495">JointCounter</a>, struct JointIdentifier &gt;</td></tr>
<tr class="memdesc:a8e3114be8fb50493389d7991db4f2b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint identifier. <br /></td></tr>
<tr class="separator:a8e3114be8fb50493389d7991db4f2b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06f67e158a928ef59e4263facac8fb0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">PointState</a> { <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba5ac8cf2fb7a90ff2d0829f5fca4db5b8">PointState::NullState</a>, 
<a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba494a3e62657370358107e2edf3fca5a0">PointState::AddState</a>, 
<a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba60a7f32dd91e5f33a4ca2bc7b7255343">PointState::PersistState</a>, 
<a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba3500ff358c0521359118fe519bd8f605">PointState::RemoveState</a>
 }</td></tr>
<tr class="memdesc:a06f67e158a928ef59e4263facac8fb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point state enumeration.  <a href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">More...</a><br /></td></tr>
<tr class="separator:a06f67e158a928ef59e4263facac8fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66189f1fe36ac717e284ab1099171106"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">RayCastOpcode</a> { <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a056fa3d840f48b7bfbbd68c19a4797b3">RayCastOpcode::Terminate</a>, 
<a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106aaf8767ee039cdc51717435bb815da593">RayCastOpcode::IgnoreFixture</a>, 
<a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a8dcfe18b6245b17c9cd69d5af7ef1847">RayCastOpcode::ClipRay</a>, 
<a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a4592f28dc9d11de3ce507bebafd9de16">RayCastOpcode::ResetRay</a>
 }</td></tr>
<tr class="memdesc:a66189f1fe36ac717e284ab1099171106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray cast opcode enumeration.  <a href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">More...</a><br /></td></tr>
<tr class="separator:a66189f1fe36ac717e284ab1099171106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098b0ef528e3b728af8e3e17873963f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a> { <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a84a8921b25f505d0d2077aeb5db4bc16">BodyType::Static</a> = 0, 
<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a40c78b58b86002ee38fad2d3c9dd787e">BodyType::Kinematic</a>, 
<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a971fd8cc345d8bd9f92e9f7d88fdf20c">BodyType::Dynamic</a>
 }</td></tr>
<tr class="memdesc:a098b0ef528e3b728af8e3e17873963f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of body.  <a href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">More...</a><br /></td></tr>
<tr class="separator:a098b0ef528e3b728af8e3e17873963f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa4c22718accfc68e3baba71b3747a4ba"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa4c22718accfc68e3baba71b3747a4ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho_1_1d2.html#abfb3031d97cbdac7eb72cccf26e3c694">d2::AABB</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa4c22718accfc68e3baba71b3747a4ba">GetInvalid</a> () noexcept</td></tr>
<tr class="memdesc:aa4c22718accfc68e3baba71b3747a4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an invalid AABB value.  <a href="namespaceplayrho.html#aa4c22718accfc68e3baba71b3747a4ba">More...</a><br /></td></tr>
<tr class="separator:aa4c22718accfc68e3baba71b3747a4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c8c86c92d71e89dd707af00b1de6a8"><td class="memItemLeft" align="right" valign="top"><a id="ad0c8c86c92d71e89dd707af00b1de6a8"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad0c8c86c92d71e89dd707af00b1de6a8">GetVertexVertexContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:ad0c8c86c92d71e89dd707af00b1de6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex vertex contact feature for the given indices. <br /></td></tr>
<tr class="separator:ad0c8c86c92d71e89dd707af00b1de6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525adfccea1a81ce8311751fc90d0614"><td class="memItemLeft" align="right" valign="top"><a id="a525adfccea1a81ce8311751fc90d0614"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a525adfccea1a81ce8311751fc90d0614">GetVertexFaceContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:a525adfccea1a81ce8311751fc90d0614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex face contact feature for the given indices. <br /></td></tr>
<tr class="separator:a525adfccea1a81ce8311751fc90d0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874b42008ce4794858edc982ba13534a"><td class="memItemLeft" align="right" valign="top"><a id="a874b42008ce4794858edc982ba13534a"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a874b42008ce4794858edc982ba13534a">GetFaceVertexContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:a874b42008ce4794858edc982ba13534a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the face vertex contact feature for the given indices. <br /></td></tr>
<tr class="separator:a874b42008ce4794858edc982ba13534a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64fefdeb5b40b3ee00c30dc263397b9"><td class="memItemLeft" align="right" valign="top"><a id="aa64fefdeb5b40b3ee00c30dc263397b9"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa64fefdeb5b40b3ee00c30dc263397b9">GetFaceFaceContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:aa64fefdeb5b40b3ee00c30dc263397b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the face face contact feature for the given indices. <br /></td></tr>
<tr class="separator:aa64fefdeb5b40b3ee00c30dc263397b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43951f69f7ead57450bac66cbb76b0e1"><td class="memItemLeft" align="right" valign="top"><a id="a43951f69f7ead57450bac66cbb76b0e1"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a43951f69f7ead57450bac66cbb76b0e1">Flip</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> val) noexcept</td></tr>
<tr class="memdesc:a43951f69f7ead57450bac66cbb76b0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips contact features information. <br /></td></tr>
<tr class="separator:a43951f69f7ead57450bac66cbb76b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19a825ed22691eab1981a616b6bf539"><td class="memItemLeft" align="right" valign="top"><a id="ac19a825ed22691eab1981a616b6bf539"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac19a825ed22691eab1981a616b6bf539">operator==</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> lhs, <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> rhs) noexcept</td></tr>
<tr class="memdesc:ac19a825ed22691eab1981a616b6bf539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given two contact features are equal. <br /></td></tr>
<tr class="separator:ac19a825ed22691eab1981a616b6bf539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcf95269c48c96b8af0854d24894e3d"><td class="memItemLeft" align="right" valign="top"><a id="a9bcf95269c48c96b8af0854d24894e3d"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9bcf95269c48c96b8af0854d24894e3d">operator!=</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> lhs, <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9bcf95269c48c96b8af0854d24894e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given two contact features are not equal. <br /></td></tr>
<tr class="separator:a9bcf95269c48c96b8af0854d24894e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"><td class="memItemLeft" align="right" valign="top"><a id="a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea">GetName</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#afd2b1a5d28a16fc49261c39d8cebabc0">ContactFeature::Type</a> type) noexcept</td></tr>
<tr class="memdesc:a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the human readable name for the given contact feature type. <br /></td></tr>
<tr class="separator:a6cc5c3f8bdf0fe8001ba1d2e3f7b2eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="memItemLeft" align="right" valign="top"><a id="ad3ec58bed15fb00ea00af6a52e5a7e3e"></a>
inline ::std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad3ec58bed15fb00ea00af6a52e5a7e3e">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> &amp;value)</td></tr>
<tr class="memdesc:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator. <br /></td></tr>
<tr class="separator:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad136f8db9fd6c0c583c1890b8a3cc504"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) noexcept</td></tr>
<tr class="memdesc:ad136f8db9fd6c0c583c1890b8a3cc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of valid indices in the given collection of index pairs.  <a href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">More...</a><br /></td></tr>
<tr class="separator:ad136f8db9fd6c0c583c1890b8a3cc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ab78cb47da6f6d872d617cc66040a6"><td class="memItemLeft" align="right" valign="top"><a id="a98ab78cb47da6f6d872d617cc66040a6"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a98ab78cb47da6f6d872d617cc66040a6">empty</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) noexcept</td></tr>
<tr class="memdesc:a98ab78cb47da6f6d872d617cc66040a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given collection of index pairs is empty. <br /></td></tr>
<tr class="separator:a98ab78cb47da6f6d872d617cc66040a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33cf35b33c93168aedcbf5a986a3472"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) -&gt; decltype(<a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices</a>(pairs))</td></tr>
<tr class="memdesc:af33cf35b33c93168aedcbf5a986a3472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dynamic size of the given collection of index pairs.  <a href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">More...</a><br /></td></tr>
<tr class="separator:af33cf35b33c93168aedcbf5a986a3472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32367e964a575ebee3ed45c8ddb0afe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac32367e964a575ebee3ed45c8ddb0afe">max_size</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) -&gt; decltype(pairs.max_size())</td></tr>
<tr class="memdesc:ac32367e964a575ebee3ed45c8ddb0afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum size of the given container of index pairs.  <a href="namespaceplayrho.html#ac32367e964a575ebee3ed45c8ddb0afe">More...</a><br /></td></tr>
<tr class="separator:ac32367e964a575ebee3ed45c8ddb0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memTemplParams" colspan="2"><a id="a24de24fa4d8c10dea7826ce11c81ff36"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a24de24fa4d8c10dea7826ce11c81ff36">GetFirstShapeVertexIdx</a> (const <a class="el" href="structplayrho_1_1detail_1_1SeparationInfo.html">detail::SeparationInfo</a>&lt; N &gt; &amp;info) noexcept</td></tr>
<tr class="memdesc:a24de24fa4d8c10dea7826ce11c81ff36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets first shape vertex index. <br /></td></tr>
<tr class="separator:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memTemplParams" colspan="2"><a id="a435b2e5c84e285bf7f0ac9486c2512d3"></a>
template&lt;VertexCounter M, std::size_t N&gt; </td></tr>
<tr class="memitem:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a435b2e5c84e285bf7f0ac9486c2512d3">GetSecondShapeVertexIdx</a> (const <a class="el" href="structplayrho_1_1detail_1_1SeparationInfo.html">detail::SeparationInfo</a>&lt; N &gt; &amp;info) noexcept</td></tr>
<tr class="memdesc:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets second shape vertex indices. <br /></td></tr>
<tr class="separator:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab903c93dd80fcff6148a66dbc7c89687"><td class="memItemLeft" align="right" valign="top"><a id="ab903c93dd80fcff6148a66dbc7c89687"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab903c93dd80fcff6148a66dbc7c89687"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab903c93dd80fcff6148a66dbc7c89687">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1Manifold.html">d2::Manifold</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ab903c93dd80fcff6148a66dbc7c89687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given manifold is valid. <br /></td></tr>
<tr class="separator:ab903c93dd80fcff6148a66dbc7c89687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb29c9575dd4eeac1ff13136d9a56494"><td class="memItemLeft" align="right" valign="top"><a id="acb29c9575dd4eeac1ff13136d9a56494"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acb29c9575dd4eeac1ff13136d9a56494">GetName</a> (<a class="el" href="structplayrho_1_1TOIOutput.html#a7387423560f6283896f1c6af1f938991">TOIOutput::State</a> state) noexcept</td></tr>
<tr class="memdesc:acb29c9575dd4eeac1ff13136d9a56494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a human readable name for the given output state. <br /></td></tr>
<tr class="separator:acb29c9575dd4eeac1ff13136d9a56494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864179cb9a35cb6665d429656ad0e9b"><td class="memItemLeft" align="right" valign="top"><a id="a9864179cb9a35cb6665d429656ad0e9b"></a>
<a class="el" href="structplayrho_1_1ToiConf.html">ToiConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9864179cb9a35cb6665d429656ad0e9b">GetToiConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a9864179cb9a35cb6665d429656ad0e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time of impact configuration for the given step configuration. <br /></td></tr>
<tr class="separator:a9864179cb9a35cb6665d429656ad0e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd2e3047d7ac0836f8921a496e8d432"><td class="memItemLeft" align="right" valign="top"><a id="a4dd2e3047d7ac0836f8921a496e8d432"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4dd2e3047d7ac0836f8921a496e8d432">GetDefaultToiConf</a> ()</td></tr>
<tr class="memdesc:a4dd2e3047d7ac0836f8921a496e8d432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default time of impact configuration. <br /></td></tr>
<tr class="separator:a4dd2e3047d7ac0836f8921a496e8d432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299c547b3a13504426688a0c968e2891"><td class="memItemLeft" align="right" valign="top"><a id="a299c547b3a13504426688a0c968e2891"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a299c547b3a13504426688a0c968e2891"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a299c547b3a13504426688a0c968e2891">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Acceleration.html">d2::Acceleration</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a299c547b3a13504426688a0c968e2891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a299c547b3a13504426688a0c968e2891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1619f9e02f66414371891d25a1275f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d1619f9e02f66414371891d25a1275f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ArrayAllocator.html">ArrayAllocator</a>&lt; T &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8d1619f9e02f66414371891d25a1275f">used</a> (const <a class="el" href="classplayrho_1_1ArrayAllocator.html">ArrayAllocator</a>&lt; T &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:a8d1619f9e02f66414371891d25a1275f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements that are used in the specified structure.  <a href="namespaceplayrho.html#a8d1619f9e02f66414371891d25a1275f">More...</a><br /></td></tr>
<tr class="separator:a8d1619f9e02f66414371891d25a1275f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="memTemplParams" colspan="2"><a id="afe9da6ff11f4a2c1b7d0df8f513bc217"></a>
template&lt;typename T , std::size_t S&gt; </td></tr>
<tr class="memitem:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afe9da6ff11f4a2c1b7d0df8f513bc217">operator+=</a> (<a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; &amp;lhs, const typename <a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;::data_type &amp;rhs)</td></tr>
<tr class="memdesc:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1ArrayList.html" title="Array list.">ArrayList</a></code> append operator. <br /></td></tr>
<tr class="separator:afe9da6ff11f4a2c1b7d0df8f513bc217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2410eb16decdbb7ed8ce34c06327161b"><td class="memTemplParams" colspan="2"><a id="a2410eb16decdbb7ed8ce34c06327161b"></a>
template&lt;typename T , std::size_t S&gt; </td></tr>
<tr class="memitem:a2410eb16decdbb7ed8ce34c06327161b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2410eb16decdbb7ed8ce34c06327161b">operator+</a> (<a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; lhs, const typename <a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;::data_type &amp;rhs)</td></tr>
<tr class="memdesc:a2410eb16decdbb7ed8ce34c06327161b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1ArrayList.html" title="Array list.">ArrayList</a></code> add operator. <br /></td></tr>
<tr class="separator:a2410eb16decdbb7ed8ce34c06327161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f6b57cf0f7bc53f9339381007d9b84"><td class="memTemplParams" colspan="2"><a id="a02f6b57cf0f7bc53f9339381007d9b84"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02f6b57cf0f7bc53f9339381007d9b84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a02f6b57cf0f7bc53f9339381007d9b84">Delete</a> (const T *p, <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;allocator)</td></tr>
<tr class="memdesc:a02f6b57cf0f7bc53f9339381007d9b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the given pointer by calling the pointed-to object's destructor and returning it to the given allocator. <br /></td></tr>
<tr class="separator:a02f6b57cf0f7bc53f9339381007d9b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5692e54289c87c156bd7455763082a9"><td class="memItemLeft" align="right" valign="top"><a id="ab5692e54289c87c156bd7455763082a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab5692e54289c87c156bd7455763082a9">operator==</a> (const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;a, const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;b)</td></tr>
<tr class="memdesc:ab5692e54289c87c156bd7455763082a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1BlockAllocator.html" title="Block allocator.">BlockAllocator</a></code> equality operator. <br /></td></tr>
<tr class="separator:ab5692e54289c87c156bd7455763082a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d26025dffe3901caa095b9fa19682"><td class="memItemLeft" align="right" valign="top"><a id="a425d26025dffe3901caa095b9fa19682"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a425d26025dffe3901caa095b9fa19682">operator!=</a> (const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;a, const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;b)</td></tr>
<tr class="memdesc:a425d26025dffe3901caa095b9fa19682"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1BlockAllocator.html" title="Block allocator.">BlockAllocator</a></code> inequality operator. <br /></td></tr>
<tr class="separator:a425d26025dffe3901caa095b9fa19682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc045bd4bbb560077978ce21cd20c49f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType &gt; </td></tr>
<tr class="memitem:acc045bd4bbb560077978ce21cd20c49f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acc045bd4bbb560077978ce21cd20c49f">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;value) -&gt; decltype(os&lt;&lt; ValueType(value))</td></tr>
<tr class="memdesc:acc045bd4bbb560077978ce21cd20c49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value stream output operator for value types which support it.  <a href="namespaceplayrho.html#acc045bd4bbb560077978ce21cd20c49f">More...</a><br /></td></tr>
<tr class="separator:acc045bd4bbb560077978ce21cd20c49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21e9430d6c13f5645a8a5af6a64a23a"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:ab21e9430d6c13f5645a8a5af6a64a23a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab21e9430d6c13f5645a8a5af6a64a23a">operator==</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) noexcept(noexcept(std::declval&lt; LhsValueType &gt;()==std::declval&lt; RhsValueType &gt;())) -&gt; decltype(LhsValueType(lhs)==RhsValueType(rhs))</td></tr>
<tr class="memdesc:ab21e9430d6c13f5645a8a5af6a64a23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value equality operator for value types which support it.  <a href="namespaceplayrho.html#ab21e9430d6c13f5645a8a5af6a64a23a">More...</a><br /></td></tr>
<tr class="separator:ab21e9430d6c13f5645a8a5af6a64a23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0878dcd8f25150f77ebea43e908e3023"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:a0878dcd8f25150f77ebea43e908e3023"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0878dcd8f25150f77ebea43e908e3023">operator!=</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) noexcept(noexcept(std::declval&lt; LhsValueType &gt;() !=std::declval&lt; RhsValueType &gt;())) -&gt; decltype(LhsValueType(lhs) !=RhsValueType(rhs))</td></tr>
<tr class="memdesc:a0878dcd8f25150f77ebea43e908e3023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value inequality operator for value types which support it.  <a href="namespaceplayrho.html#a0878dcd8f25150f77ebea43e908e3023">More...</a><br /></td></tr>
<tr class="separator:a0878dcd8f25150f77ebea43e908e3023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f5c3cf62f38463edf89ddc5bf05b80"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:a17f5c3cf62f38463edf89ddc5bf05b80"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a17f5c3cf62f38463edf89ddc5bf05b80">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs)&lt;=RhsValueType(rhs))</td></tr>
<tr class="memdesc:a17f5c3cf62f38463edf89ddc5bf05b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value less-than or equal-to operator.  <a href="namespaceplayrho.html#a17f5c3cf62f38463edf89ddc5bf05b80">More...</a><br /></td></tr>
<tr class="separator:a17f5c3cf62f38463edf89ddc5bf05b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c18729fd53f4bb5275874c8cd1eb644"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:a5c18729fd53f4bb5275874c8cd1eb644"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5c18729fd53f4bb5275874c8cd1eb644">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs) &gt;=RhsValueType(rhs))</td></tr>
<tr class="memdesc:a5c18729fd53f4bb5275874c8cd1eb644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value greater-than or equal-to operator.  <a href="namespaceplayrho.html#a5c18729fd53f4bb5275874c8cd1eb644">More...</a><br /></td></tr>
<tr class="separator:a5c18729fd53f4bb5275874c8cd1eb644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e50b7f361b27adaf57e0b275b849cb2"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:a4e50b7f361b27adaf57e0b275b849cb2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4e50b7f361b27adaf57e0b275b849cb2">operator&lt;</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs)&lt; RhsValueType(rhs))</td></tr>
<tr class="memdesc:a4e50b7f361b27adaf57e0b275b849cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value less-than operator.  <a href="namespaceplayrho.html#a4e50b7f361b27adaf57e0b275b849cb2">More...</a><br /></td></tr>
<tr class="separator:a4e50b7f361b27adaf57e0b275b849cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6a70eaafe3d414d9ebb561150a5ae0"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:aab6a70eaafe3d414d9ebb561150a5ae0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aab6a70eaafe3d414d9ebb561150a5ae0">operator&gt;</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs) &gt; RhsValueType(rhs))</td></tr>
<tr class="memdesc:aab6a70eaafe3d414d9ebb561150a5ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value greater-than operator.  <a href="namespaceplayrho.html#aab6a70eaafe3d414d9ebb561150a5ae0">More...</a><br /></td></tr>
<tr class="separator:aab6a70eaafe3d414d9ebb561150a5ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695c5da4298cd1267ccb84710dc5dc4"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:ab695c5da4298cd1267ccb84710dc5dc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab695c5da4298cd1267ccb84710dc5dc4">operator*</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs) *RhsValueType(rhs))</td></tr>
<tr class="memdesc:ab695c5da4298cd1267ccb84710dc5dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value multiplication operator.  <a href="namespaceplayrho.html#ab695c5da4298cd1267ccb84710dc5dc4">More...</a><br /></td></tr>
<tr class="separator:ab695c5da4298cd1267ccb84710dc5dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5b28003deb87e06a3c9e51f44fb096"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:a5a5b28003deb87e06a3c9e51f44fb096"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5a5b28003deb87e06a3c9e51f44fb096">operator/</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs)/RhsValueType(rhs))</td></tr>
<tr class="memdesc:a5a5b28003deb87e06a3c9e51f44fb096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value division operator.  <a href="namespaceplayrho.html#a5a5b28003deb87e06a3c9e51f44fb096">More...</a><br /></td></tr>
<tr class="separator:a5a5b28003deb87e06a3c9e51f44fb096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace19087d3c9f0e9cf7b83eb131626bee"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:ace19087d3c9f0e9cf7b83eb131626bee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ace19087d3c9f0e9cf7b83eb131626bee">operator+</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs)+RhsValueType(rhs))</td></tr>
<tr class="memdesc:ace19087d3c9f0e9cf7b83eb131626bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value addition operator.  <a href="namespaceplayrho.html#ace19087d3c9f0e9cf7b83eb131626bee">More...</a><br /></td></tr>
<tr class="separator:ace19087d3c9f0e9cf7b83eb131626bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa918349e3179ab2f97d04b41085d0a48"><td class="memTemplParams" colspan="2">template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </td></tr>
<tr class="memitem:aa918349e3179ab2f97d04b41085d0a48"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa918349e3179ab2f97d04b41085d0a48">operator-</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;rhs) -&gt; decltype(LhsValueType(lhs) - RhsValueType(rhs))</td></tr>
<tr class="memdesc:aa918349e3179ab2f97d04b41085d0a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value subtraction operator.  <a href="namespaceplayrho.html#aa918349e3179ab2f97d04b41085d0a48">More...</a><br /></td></tr>
<tr class="separator:aa918349e3179ab2f97d04b41085d0a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafba64613de79315803f30e1c800aad"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:adafba64613de79315803f30e1c800aad"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adafba64613de79315803f30e1c800aad">operator==</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs)==rhs)</td></tr>
<tr class="memdesc:adafba64613de79315803f30e1c800aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value equality operator.  <a href="namespaceplayrho.html#adafba64613de79315803f30e1c800aad">More...</a><br /></td></tr>
<tr class="separator:adafba64613de79315803f30e1c800aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fc70d9f3c91ab4c9afb7730f920243"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:aa8fc70d9f3c91ab4c9afb7730f920243"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa8fc70d9f3c91ab4c9afb7730f920243">operator==</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs==ValueType(rhs))</td></tr>
<tr class="memdesc:aa8fc70d9f3c91ab4c9afb7730f920243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value equality operator.  <a href="namespaceplayrho.html#aa8fc70d9f3c91ab4c9afb7730f920243">More...</a><br /></td></tr>
<tr class="separator:aa8fc70d9f3c91ab4c9afb7730f920243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25888243d04857183fbff9a515bcbfd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:af25888243d04857183fbff9a515bcbfd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af25888243d04857183fbff9a515bcbfd">operator!=</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs) !=rhs)</td></tr>
<tr class="memdesc:af25888243d04857183fbff9a515bcbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value inequality operator.  <a href="namespaceplayrho.html#af25888243d04857183fbff9a515bcbfd">More...</a><br /></td></tr>
<tr class="separator:af25888243d04857183fbff9a515bcbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6bef32507b31e3d1ae0935a6719e71"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a2a6bef32507b31e3d1ae0935a6719e71"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2a6bef32507b31e3d1ae0935a6719e71">operator!=</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs !=ValueType(rhs))</td></tr>
<tr class="memdesc:a2a6bef32507b31e3d1ae0935a6719e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value inequality operator.  <a href="namespaceplayrho.html#a2a6bef32507b31e3d1ae0935a6719e71">More...</a><br /></td></tr>
<tr class="separator:a2a6bef32507b31e3d1ae0935a6719e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e696d4bb8a0294762be3428301ebbec"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a3e696d4bb8a0294762be3428301ebbec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3e696d4bb8a0294762be3428301ebbec">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs)&lt;=rhs)</td></tr>
<tr class="memdesc:a3e696d4bb8a0294762be3428301ebbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value less-than or equal-to operator.  <a href="namespaceplayrho.html#a3e696d4bb8a0294762be3428301ebbec">More...</a><br /></td></tr>
<tr class="separator:a3e696d4bb8a0294762be3428301ebbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fa5e47ada221e269711dbbf90eedd7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a55fa5e47ada221e269711dbbf90eedd7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a55fa5e47ada221e269711dbbf90eedd7">operator&lt;=</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs&lt;=ValueType(rhs))</td></tr>
<tr class="memdesc:a55fa5e47ada221e269711dbbf90eedd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value less-than or equal-to operator.  <a href="namespaceplayrho.html#a55fa5e47ada221e269711dbbf90eedd7">More...</a><br /></td></tr>
<tr class="separator:a55fa5e47ada221e269711dbbf90eedd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb14439b5fd9f3daf2b518c786865b7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:abcb14439b5fd9f3daf2b518c786865b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abcb14439b5fd9f3daf2b518c786865b7">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs) &gt;=rhs)</td></tr>
<tr class="memdesc:abcb14439b5fd9f3daf2b518c786865b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value greater-than or equal-to operator.  <a href="namespaceplayrho.html#abcb14439b5fd9f3daf2b518c786865b7">More...</a><br /></td></tr>
<tr class="separator:abcb14439b5fd9f3daf2b518c786865b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092ab700ddc3c1dba9a60a49ce75cf6e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a092ab700ddc3c1dba9a60a49ce75cf6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a092ab700ddc3c1dba9a60a49ce75cf6e">operator&gt;=</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs &gt;=ValueType(rhs))</td></tr>
<tr class="memdesc:a092ab700ddc3c1dba9a60a49ce75cf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value greater-than or equal-to operator.  <a href="namespaceplayrho.html#a092ab700ddc3c1dba9a60a49ce75cf6e">More...</a><br /></td></tr>
<tr class="separator:a092ab700ddc3c1dba9a60a49ce75cf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2a8be4da1677e412b8eabc2146873"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:ab9f2a8be4da1677e412b8eabc2146873"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab9f2a8be4da1677e412b8eabc2146873">operator&lt;</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs)&lt; rhs)</td></tr>
<tr class="memdesc:ab9f2a8be4da1677e412b8eabc2146873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value less-than operator.  <a href="namespaceplayrho.html#ab9f2a8be4da1677e412b8eabc2146873">More...</a><br /></td></tr>
<tr class="separator:ab9f2a8be4da1677e412b8eabc2146873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f64d5e0d888eb6813af5fa103a16b16"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a6f64d5e0d888eb6813af5fa103a16b16"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6f64d5e0d888eb6813af5fa103a16b16">operator&lt;</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs&lt; ValueType(rhs))</td></tr>
<tr class="memdesc:a6f64d5e0d888eb6813af5fa103a16b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value less-than operator.  <a href="namespaceplayrho.html#a6f64d5e0d888eb6813af5fa103a16b16">More...</a><br /></td></tr>
<tr class="separator:a6f64d5e0d888eb6813af5fa103a16b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2ff344394e8157985fe636a85f18d9"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a3b2ff344394e8157985fe636a85f18d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3b2ff344394e8157985fe636a85f18d9">operator&gt;</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs) &gt; rhs)</td></tr>
<tr class="memdesc:a3b2ff344394e8157985fe636a85f18d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value greater-than operator.  <a href="namespaceplayrho.html#a3b2ff344394e8157985fe636a85f18d9">More...</a><br /></td></tr>
<tr class="separator:a3b2ff344394e8157985fe636a85f18d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea68ce25d18cda2a9a333fa224f0558"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a6ea68ce25d18cda2a9a333fa224f0558"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6ea68ce25d18cda2a9a333fa224f0558">operator&gt;</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs &gt; ValueType(rhs))</td></tr>
<tr class="memdesc:a6ea68ce25d18cda2a9a333fa224f0558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value greater-than ooperator.  <a href="namespaceplayrho.html#a6ea68ce25d18cda2a9a333fa224f0558">More...</a><br /></td></tr>
<tr class="separator:a6ea68ce25d18cda2a9a333fa224f0558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344c62fec7ff32c28d2a98fb3eff0cee"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a344c62fec7ff32c28d2a98fb3eff0cee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a344c62fec7ff32c28d2a98fb3eff0cee">operator*</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt;, Other &gt;::value, decltype(ValueType() *Other())&gt;</td></tr>
<tr class="memdesc:a344c62fec7ff32c28d2a98fb3eff0cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value multiplication operator.  <a href="namespaceplayrho.html#a344c62fec7ff32c28d2a98fb3eff0cee">More...</a><br /></td></tr>
<tr class="separator:a344c62fec7ff32c28d2a98fb3eff0cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14860a28f9b31d3c16987c19762c227a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a14860a28f9b31d3c16987c19762c227a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a14860a28f9b31d3c16987c19762c227a">operator*</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; Other, <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt;&gt;::value, decltype(Other() *ValueType())&gt;</td></tr>
<tr class="memdesc:a14860a28f9b31d3c16987c19762c227a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value multiplication operator.  <a href="namespaceplayrho.html#a14860a28f9b31d3c16987c19762c227a">More...</a><br /></td></tr>
<tr class="separator:a14860a28f9b31d3c16987c19762c227a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a68e7bc007582c16847ed8615d8c26"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a21a68e7bc007582c16847ed8615d8c26"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a21a68e7bc007582c16847ed8615d8c26">operator/</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs)/rhs)</td></tr>
<tr class="memdesc:a21a68e7bc007582c16847ed8615d8c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value division operator.  <a href="namespaceplayrho.html#a21a68e7bc007582c16847ed8615d8c26">More...</a><br /></td></tr>
<tr class="separator:a21a68e7bc007582c16847ed8615d8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740ddde1b6038fc20e0e763e0eabac6a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a740ddde1b6038fc20e0e763e0eabac6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a740ddde1b6038fc20e0e763e0eabac6a">operator/</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs/ValueType(rhs))</td></tr>
<tr class="memdesc:a740ddde1b6038fc20e0e763e0eabac6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value division operator.  <a href="namespaceplayrho.html#a740ddde1b6038fc20e0e763e0eabac6a">More...</a><br /></td></tr>
<tr class="separator:a740ddde1b6038fc20e0e763e0eabac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687d59516f156855de42eea778eccc49"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a687d59516f156855de42eea778eccc49"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a687d59516f156855de42eea778eccc49">operator+</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs)+rhs)</td></tr>
<tr class="memdesc:a687d59516f156855de42eea778eccc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value addition operator.  <a href="namespaceplayrho.html#a687d59516f156855de42eea778eccc49">More...</a><br /></td></tr>
<tr class="separator:a687d59516f156855de42eea778eccc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75202d7d29b1ce5418c1ae4e32c95a08"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a75202d7d29b1ce5418c1ae4e32c95a08"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a75202d7d29b1ce5418c1ae4e32c95a08">operator+</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs+ValueType(rhs))</td></tr>
<tr class="memdesc:a75202d7d29b1ce5418c1ae4e32c95a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value addition operator.  <a href="namespaceplayrho.html#a75202d7d29b1ce5418c1ae4e32c95a08">More...</a><br /></td></tr>
<tr class="separator:a75202d7d29b1ce5418c1ae4e32c95a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1adc96b8c69fa7bb0ce08582f93de7"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:acf1adc96b8c69fa7bb0ce08582f93de7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acf1adc96b8c69fa7bb0ce08582f93de7">operator-</a> (const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;lhs, const Other &amp;rhs) -&gt; decltype(ValueType(lhs) - rhs)</td></tr>
<tr class="memdesc:acf1adc96b8c69fa7bb0ce08582f93de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value subtraction operator.  <a href="namespaceplayrho.html#acf1adc96b8c69fa7bb0ce08582f93de7">More...</a><br /></td></tr>
<tr class="separator:acf1adc96b8c69fa7bb0ce08582f93de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5783466a0028f61a1e70076f410ac4ee"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CheckerType , typename Other &gt; </td></tr>
<tr class="memitem:a5783466a0028f61a1e70076f410ac4ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5783466a0028f61a1e70076f410ac4ee">operator-</a> (const Other &amp;lhs, const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;rhs) -&gt; decltype(lhs - ValueType(rhs))</td></tr>
<tr class="memdesc:a5783466a0028f61a1e70076f410ac4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrained value subtraction operator.  <a href="namespaceplayrho.html#a5783466a0028f61a1e70076f410ac4ee">More...</a><br /></td></tr>
<tr class="separator:a5783466a0028f61a1e70076f410ac4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516a3bbb73371cdc53f348b67f43bb1f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f">Alloc</a> (std::size_t <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a>)</td></tr>
<tr class="memdesc:a516a3bbb73371cdc53f348b67f43bb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory.  <a href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f">More...</a><br /></td></tr>
<tr class="separator:a516a3bbb73371cdc53f348b67f43bb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb651f620aefb4ee65ec0cc8c10b27b0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">Realloc</a> (void *ptr, std::size_t <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a>)</td></tr>
<tr class="memdesc:adb651f620aefb4ee65ec0cc8c10b27b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory.  <a href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">More...</a><br /></td></tr>
<tr class="separator:adb651f620aefb4ee65ec0cc8c10b27b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c138018c11ab3c255b410f2dedd7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2">Free</a> (void *mem)</td></tr>
<tr class="memdesc:a62c138018c11ab3c255b410f2dedd7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory.  <a href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2">More...</a><br /></td></tr>
<tr class="separator:a62c138018c11ab3c255b410f2dedd7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2943dd9a79b7fc1fa196af1208b00388"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2943dd9a79b7fc1fa196af1208b00388"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">AllocArray</a> (std::size_t <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a>)</td></tr>
<tr class="memdesc:a2943dd9a79b7fc1fa196af1208b00388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for an array.  <a href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">More...</a><br /></td></tr>
<tr class="separator:a2943dd9a79b7fc1fa196af1208b00388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197482cbffdd702c8926a00f42a76e62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a197482cbffdd702c8926a00f42a76e62"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62">ReallocArray</a> (T *ptr, std::size_t count)</td></tr>
<tr class="memdesc:a197482cbffdd702c8926a00f42a76e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory for an array.  <a href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62">More...</a><br /></td></tr>
<tr class="separator:a197482cbffdd702c8926a00f42a76e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5fcbbad444f151c1665cecb75f381f"><td class="memTemplParams" colspan="2"><a id="aaf5fcbbad444f151c1665cecb75f381f"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:aaf5fcbbad444f151c1665cecb75f381f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aaf5fcbbad444f151c1665cecb75f381f">operator==</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:aaf5fcbbad444f151c1665cecb75f381f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:aaf5fcbbad444f151c1665cecb75f381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1feb96b1bc5f0678758df12f93fe3b"><td class="memTemplParams" colspan="2"><a id="a9a1feb96b1bc5f0678758df12f93fe3b"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a9a1feb96b1bc5f0678758df12f93fe3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9a1feb96b1bc5f0678758df12f93fe3b">operator!=</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a9a1feb96b1bc5f0678758df12f93fe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a9a1feb96b1bc5f0678758df12f93fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310dd6a59f071ee86430f5162368f61c"><td class="memTemplParams" colspan="2"><a id="a310dd6a59f071ee86430f5162368f61c"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a310dd6a59f071ee86430f5162368f61c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a310dd6a59f071ee86430f5162368f61c">operator&lt;</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a310dd6a59f071ee86430f5162368f61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:a310dd6a59f071ee86430f5162368f61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f2c871930a05238a02a3581b2dbcc9"><td class="memTemplParams" colspan="2"><a id="ab7f2c871930a05238a02a3581b2dbcc9"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ab7f2c871930a05238a02a3581b2dbcc9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab7f2c871930a05238a02a3581b2dbcc9">operator&gt;</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ab7f2c871930a05238a02a3581b2dbcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:ab7f2c871930a05238a02a3581b2dbcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f7c32a47415d5005673852344009eb"><td class="memTemplParams" colspan="2"><a id="a70f7c32a47415d5005673852344009eb"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a70f7c32a47415d5005673852344009eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a70f7c32a47415d5005673852344009eb">operator&lt;=</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a70f7c32a47415d5005673852344009eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a70f7c32a47415d5005673852344009eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52ee51315f92b6463bab76317603a8d"><td class="memTemplParams" colspan="2"><a id="ac52ee51315f92b6463bab76317603a8d"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ac52ee51315f92b6463bab76317603a8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac52ee51315f92b6463bab76317603a8d">operator&gt;=</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ac52ee51315f92b6463bab76317603a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:ac52ee51315f92b6463bab76317603a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf379d2d8f3a5aacdaf5fb871c935237"><td class="memTemplParams" colspan="2"><a id="adf379d2d8f3a5aacdaf5fb871c935237"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:adf379d2d8f3a5aacdaf5fb871c935237"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adf379d2d8f3a5aacdaf5fb871c935237">operator+</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:adf379d2d8f3a5aacdaf5fb871c935237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator. <br /></td></tr>
<tr class="separator:adf379d2d8f3a5aacdaf5fb871c935237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9468719501f7a5cf7747569ef71acc33"><td class="memTemplParams" colspan="2"><a id="a9468719501f7a5cf7747569ef71acc33"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a9468719501f7a5cf7747569ef71acc33"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9468719501f7a5cf7747569ef71acc33">operator-</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a9468719501f7a5cf7747569ef71acc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator. <br /></td></tr>
<tr class="separator:a9468719501f7a5cf7747569ef71acc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb53a11e4a467306c79d44056b59bc3"><td class="memTemplParams" colspan="2"><a id="a2eb53a11e4a467306c79d44056b59bc3"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a2eb53a11e4a467306c79d44056b59bc3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2eb53a11e4a467306c79d44056b59bc3">operator*</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a2eb53a11e4a467306c79d44056b59bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:a2eb53a11e4a467306c79d44056b59bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce07a22f20a1fe265a0ca72a3a0a3cd"><td class="memTemplParams" colspan="2"><a id="adce07a22f20a1fe265a0ca72a3a0a3cd"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:adce07a22f20a1fe265a0ca72a3a0a3cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adce07a22f20a1fe265a0ca72a3a0a3cd">operator/</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:adce07a22f20a1fe265a0ca72a3a0a3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:adce07a22f20a1fe265a0ca72a3a0a3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f9fcc19f63ecf57e549bedb3792e4"><td class="memTemplParams" colspan="2"><a id="ac69f9fcc19f63ecf57e549bedb3792e4"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ac69f9fcc19f63ecf57e549bedb3792e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac69f9fcc19f63ecf57e549bedb3792e4">operator%</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; lhs, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ac69f9fcc19f63ecf57e549bedb3792e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operator. <br /></td></tr>
<tr class="separator:ac69f9fcc19f63ecf57e549bedb3792e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b5e301c1a03179e49ed7ee3a9408d9"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a87b5e301c1a03179e49ed7ee3a9408d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a87b5e301c1a03179e49ed7ee3a9408d9">AlmostZero</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value)</td></tr>
<tr class="memdesc:a87b5e301c1a03179e49ed7ee3a9408d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="namespaceplayrho.html#a87b5e301c1a03179e49ed7ee3a9408d9">More...</a><br /></td></tr>
<tr class="separator:a87b5e301c1a03179e49ed7ee3a9408d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaf4879371df30246226867c121a9ad"><td class="memTemplParams" colspan="2"><a id="a6aaf4879371df30246226867c121a9ad"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a6aaf4879371df30246226867c121a9ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6aaf4879371df30246226867c121a9ad">AlmostEqual</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; x, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; y, int ulp=2)</td></tr>
<tr class="memdesc:a6aaf4879371df30246226867c121a9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:a6aaf4879371df30246226867c121a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598d4f1182411b5db1d2c445b16fc5fd"><td class="memTemplParams" colspan="2"><a id="a598d4f1182411b5db1d2c445b16fc5fd"></a>
template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:a598d4f1182411b5db1d2c445b16fc5fd"><td class="memTemplItemLeft" align="right" valign="top">inline ::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a598d4f1182411b5db1d2c445b16fc5fd">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; &amp;value)</td></tr>
<tr class="memdesc:a598d4f1182411b5db1d2c445b16fc5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator. <br /></td></tr>
<tr class="separator:a598d4f1182411b5db1d2c445b16fc5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dbd342566c29d766d910388cfac25e"><td class="memItemLeft" align="right" valign="top"><a id="ad4dbd342566c29d766d910388cfac25e"></a>
constexpr <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad4dbd342566c29d766d910388cfac25e">operator+</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:ad4dbd342566c29d766d910388cfac25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator. <br /></td></tr>
<tr class="separator:ad4dbd342566c29d766d910388cfac25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c382ba441e52b8730b18d38dfd5771"><td class="memItemLeft" align="right" valign="top"><a id="a95c382ba441e52b8730b18d38dfd5771"></a>
constexpr <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a95c382ba441e52b8730b18d38dfd5771">operator-</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a95c382ba441e52b8730b18d38dfd5771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator. <br /></td></tr>
<tr class="separator:a95c382ba441e52b8730b18d38dfd5771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbd048b74cca661af851475f3a32f03"><td class="memItemLeft" align="right" valign="top"><a id="a2bbd048b74cca661af851475f3a32f03"></a>
constexpr <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2bbd048b74cca661af851475f3a32f03">operator*</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a2bbd048b74cca661af851475f3a32f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator. <br /></td></tr>
<tr class="separator:a2bbd048b74cca661af851475f3a32f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb66724eaf58f719874fe12e5fa78eae"><td class="memItemLeft" align="right" valign="top"><a id="acb66724eaf58f719874fe12e5fa78eae"></a>
constexpr <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acb66724eaf58f719874fe12e5fa78eae">operator/</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:acb66724eaf58f719874fe12e5fa78eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:acb66724eaf58f719874fe12e5fa78eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f36791292a3de7d109592d5271e025"><td class="memItemLeft" align="right" valign="top"><a id="a34f36791292a3de7d109592d5271e025"></a>
constexpr <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a34f36791292a3de7d109592d5271e025">operator%</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a34f36791292a3de7d109592d5271e025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operator. <br /></td></tr>
<tr class="separator:a34f36791292a3de7d109592d5271e025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436c8f6a752a984295b46dc3c24256a1"><td class="memItemLeft" align="right" valign="top"><a id="a436c8f6a752a984295b46dc3c24256a1"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a436c8f6a752a984295b46dc3c24256a1">operator==</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a436c8f6a752a984295b46dc3c24256a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a436c8f6a752a984295b46dc3c24256a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468fcfdd8d9f35d55aff3d2b2d05cd69"><td class="memItemLeft" align="right" valign="top"><a id="a468fcfdd8d9f35d55aff3d2b2d05cd69"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a468fcfdd8d9f35d55aff3d2b2d05cd69">operator!=</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a468fcfdd8d9f35d55aff3d2b2d05cd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a468fcfdd8d9f35d55aff3d2b2d05cd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff78b36b8b4533aeb308283f8557c657"><td class="memItemLeft" align="right" valign="top"><a id="aff78b36b8b4533aeb308283f8557c657"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aff78b36b8b4533aeb308283f8557c657">operator&lt;=</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:aff78b36b8b4533aeb308283f8557c657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:aff78b36b8b4533aeb308283f8557c657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5c7c5e333c08e00e17f1809c4b5eb6"><td class="memItemLeft" align="right" valign="top"><a id="a2b5c7c5e333c08e00e17f1809c4b5eb6"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2b5c7c5e333c08e00e17f1809c4b5eb6">operator&gt;=</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a2b5c7c5e333c08e00e17f1809c4b5eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:a2b5c7c5e333c08e00e17f1809c4b5eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef6e842dc811739f58a6e2b4b1d95ae"><td class="memItemLeft" align="right" valign="top"><a id="aeef6e842dc811739f58a6e2b4b1d95ae"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aeef6e842dc811739f58a6e2b4b1d95ae">operator&lt;</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:aeef6e842dc811739f58a6e2b4b1d95ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:aeef6e842dc811739f58a6e2b4b1d95ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041ad90997561d20e0c3b4265c4f2f90"><td class="memItemLeft" align="right" valign="top"><a id="a041ad90997561d20e0c3b4265c4f2f90"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a041ad90997561d20e0c3b4265c4f2f90">operator&gt;</a> (<a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> lhs, <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">Fixed32</a> rhs) noexcept</td></tr>
<tr class="memdesc:a041ad90997561d20e0c3b4265c4f2f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:a041ad90997561d20e0c3b4265c4f2f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5766364e4f6e29b62f20216a25a678f"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB, int N = 5&gt; </td></tr>
<tr class="memitem:gad5766364e4f6e29b62f20216a25a678f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gad5766364e4f6e29b62f20216a25a678f">abs</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:gad5766364e4f6e29b62f20216a25a678f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the absolute value.  <a href="group__FixedMath.html#gad5766364e4f6e29b62f20216a25a678f">More...</a><br /></td></tr>
<tr class="separator:gad5766364e4f6e29b62f20216a25a678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gae62c436656c3c2a2e0d46d83fe1ea3ae">pow</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value, int n)</td></tr>
<tr class="memdesc:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the given number raised to the given power.  <a href="group__FixedMath.html#gae62c436656c3c2a2e0d46d83fe1ea3ae">More...</a><br /></td></tr>
<tr class="separator:gae62c436656c3c2a2e0d46d83fe1ea3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55adeaba7e08eb415e6437f709b62c0f"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga55adeaba7e08eb415e6437f709b62c0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga55adeaba7e08eb415e6437f709b62c0f">trunc</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga55adeaba7e08eb415e6437f709b62c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the given value.  <a href="group__FixedMath.html#ga55adeaba7e08eb415e6437f709b62c0f">More...</a><br /></td></tr>
<tr class="separator:ga55adeaba7e08eb415e6437f709b62c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935fa93a69f58baf20b00e14461d51e7"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga935fa93a69f58baf20b00e14461d51e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga935fa93a69f58baf20b00e14461d51e7">nextafter</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; from, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; to) noexcept</td></tr>
<tr class="memdesc:ga935fa93a69f58baf20b00e14461d51e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Next after function for <a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers.">Fixed</a> types.  <a href="group__FixedMath.html#ga935fa93a69f58baf20b00e14461d51e7">More...</a><br /></td></tr>
<tr class="separator:ga935fa93a69f58baf20b00e14461d51e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaae59d507ab3b0f722d4d22b3e4969f4a">fmod</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; dividend, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; divisor) noexcept</td></tr>
<tr class="memdesc:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of the division of the given dividend by the given divisor.  <a href="group__FixedMath.html#gaae59d507ab3b0f722d4d22b3e4969f4a">More...</a><br /></td></tr>
<tr class="separator:gaae59d507ab3b0f722d4d22b3e4969f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga7a9d7e9855b45a3b4103632a47ccd6f4">sqrt</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root's the given value.  <a href="group__FixedMath.html#ga7a9d7e9855b45a3b4103632a47ccd6f4">More...</a><br /></td></tr>
<tr class="separator:ga7a9d7e9855b45a3b4103632a47ccd6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab479ab854291e9d03a25cc0986deca"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga4ab479ab854291e9d03a25cc0986deca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga4ab479ab854291e9d03a25cc0986deca">isnormal</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga4ab479ab854291e9d03a25cc0986deca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is normal - i.e. not 0 nor infinite.  <a href="group__FixedMath.html#ga4ab479ab854291e9d03a25cc0986deca">More...</a><br /></td></tr>
<tr class="separator:ga4ab479ab854291e9d03a25cc0986deca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0daabd6eacf8702561639d394e3efe6e"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga0daabd6eacf8702561639d394e3efe6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga0daabd6eacf8702561639d394e3efe6e">sin</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga0daabd6eacf8702561639d394e3efe6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sine of the argument for <a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers.">Fixed</a> types.  <a href="group__FixedMath.html#ga0daabd6eacf8702561639d394e3efe6e">More...</a><br /></td></tr>
<tr class="separator:ga0daabd6eacf8702561639d394e3efe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6191f040980675d9a5c71bd53c79060"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaf6191f040980675d9a5c71bd53c79060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaf6191f040980675d9a5c71bd53c79060">cos</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:gaf6191f040980675d9a5c71bd53c79060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cosine of the argument for <a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers.">Fixed</a> types.  <a href="group__FixedMath.html#gaf6191f040980675d9a5c71bd53c79060">More...</a><br /></td></tr>
<tr class="separator:gaf6191f040980675d9a5c71bd53c79060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5670d26d229424278268189beb541f5"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaa5670d26d229424278268189beb541f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaa5670d26d229424278268189beb541f5">atan</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:gaa5670d26d229424278268189beb541f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent.  <a href="group__FixedMath.html#gaa5670d26d229424278268189beb541f5">More...</a><br /></td></tr>
<tr class="separator:gaa5670d26d229424278268189beb541f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3e4450a30d08eceda4225bd26c312b"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gaad3e4450a30d08eceda4225bd26c312b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gaad3e4450a30d08eceda4225bd26c312b">atan2</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; y, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; x)</td></tr>
<tr class="memdesc:gaad3e4450a30d08eceda4225bd26c312b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the multi-valued inverse tangent.  <a href="group__FixedMath.html#gaad3e4450a30d08eceda4225bd26c312b">More...</a><br /></td></tr>
<tr class="separator:gaad3e4450a30d08eceda4225bd26c312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661c3590b9b618ac14194bf25a70f1d6"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga661c3590b9b618ac14194bf25a70f1d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga661c3590b9b618ac14194bf25a70f1d6">log</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga661c3590b9b618ac14194bf25a70f1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the natural logarithm of the given argument.  <a href="group__FixedMath.html#ga661c3590b9b618ac14194bf25a70f1d6">More...</a><br /></td></tr>
<tr class="separator:ga661c3590b9b618ac14194bf25a70f1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddb9c067c645bded41aafe75cfecd02"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga7ddb9c067c645bded41aafe75cfecd02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga7ddb9c067c645bded41aafe75cfecd02">exp</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; arg)</td></tr>
<tr class="memdesc:ga7ddb9c067c645bded41aafe75cfecd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Euler number raised to the power of the given argument.  <a href="group__FixedMath.html#ga7ddb9c067c645bded41aafe75cfecd02">More...</a><br /></td></tr>
<tr class="separator:ga7ddb9c067c645bded41aafe75cfecd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dfc7d7d071b22f80179a86e5544237"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga85dfc7d7d071b22f80179a86e5544237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga85dfc7d7d071b22f80179a86e5544237">pow</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; base, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; exponent)</td></tr>
<tr class="memdesc:ga85dfc7d7d071b22f80179a86e5544237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the base number raised to the power of the exponent.  <a href="group__FixedMath.html#ga85dfc7d7d071b22f80179a86e5544237">More...</a><br /></td></tr>
<tr class="separator:ga85dfc7d7d071b22f80179a86e5544237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff5f9018a9088992be3c922926aee56"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gafff5f9018a9088992be3c922926aee56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gafff5f9018a9088992be3c922926aee56">hypot</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; x, <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; y)</td></tr>
<tr class="memdesc:gafff5f9018a9088992be3c922926aee56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the square root of the sum of the squares.  <a href="group__FixedMath.html#gafff5f9018a9088992be3c922926aee56">More...</a><br /></td></tr>
<tr class="separator:gafff5f9018a9088992be3c922926aee56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga1e3ca7fb2626886c5920bbc5f570a525">round</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds the given value.  <a href="group__FixedMath.html#ga1e3ca7fb2626886c5920bbc5f570a525">More...</a><br /></td></tr>
<tr class="separator:ga1e3ca7fb2626886c5920bbc5f570a525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8445167791eb53f1e8eb0dbf318293a1"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:ga8445167791eb53f1e8eb0dbf318293a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#ga8445167791eb53f1e8eb0dbf318293a1">signbit</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:ga8445167791eb53f1e8eb0dbf318293a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given value is negative.  <a href="group__FixedMath.html#ga8445167791eb53f1e8eb0dbf318293a1">More...</a><br /></td></tr>
<tr class="separator:ga8445167791eb53f1e8eb0dbf318293a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab57c92b7d96634ba24fa1f6c25647799"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gab57c92b7d96634ba24fa1f6c25647799"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gab57c92b7d96634ba24fa1f6c25647799">isnan</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:gab57c92b7d96634ba24fa1f6c25647799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is not-a-number.  <a href="group__FixedMath.html#gab57c92b7d96634ba24fa1f6c25647799">More...</a><br /></td></tr>
<tr class="separator:gab57c92b7d96634ba24fa1f6c25647799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8fa73692143466ca4d584aacf5749f1"><td class="memTemplParams" colspan="2">template&lt;typename BT , unsigned int FB&gt; </td></tr>
<tr class="memitem:gab8fa73692143466ca4d584aacf5749f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FixedMath.html#gab8fa73692143466ca4d584aacf5749f1">isfinite</a> (<a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt; value) noexcept</td></tr>
<tr class="memdesc:gab8fa73692143466ca4d584aacf5749f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given value is finite.  <a href="group__FixedMath.html#gab8fa73692143466ca4d584aacf5749f1">More...</a><br /></td></tr>
<tr class="separator:gab8fa73692143466ca4d584aacf5749f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf5bea73a392ad1b2be520e79fb9b4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcf5bea73a392ad1b2be520e79fb9b4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abcf5bea73a392ad1b2be520e79fb9b4a">to_underlying</a> (T value) noexcept -&gt; <a class="el" href="namespaceplayrho.html#a79f10d34cd7e0d7f7cbbafb638373818">underlying_type_t</a>&lt; T &gt;</td></tr>
<tr class="memdesc:abcf5bea73a392ad1b2be520e79fb9b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given value to the value as the underlying type.  <a href="namespaceplayrho.html#abcf5bea73a392ad1b2be520e79fb9b4a">More...</a><br /></td></tr>
<tr class="separator:abcf5bea73a392ad1b2be520e79fb9b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5ae61330e0553509baa283129e8e53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f5ae61330e0553509baa283129e8e53"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0f5ae61330e0553509baa283129e8e53">GetSize</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a0f5ae61330e0553509baa283129e8e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the given interval.  <a href="namespaceplayrho.html#a0f5ae61330e0553509baa283129e8e53">More...</a><br /></td></tr>
<tr class="separator:a0f5ae61330e0553509baa283129e8e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddf94310b3145c842e6365e3ec69226"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ddf94310b3145c842e6365e3ec69226"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6ddf94310b3145c842e6365e3ec69226">GetCenter</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a6ddf94310b3145c842e6365e3ec69226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the center of the given interval.  <a href="namespaceplayrho.html#a6ddf94310b3145c842e6365e3ec69226">More...</a><br /></td></tr>
<tr class="separator:a6ddf94310b3145c842e6365e3ec69226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eff0342e8a7b5e15dcf232d7f28f961"><td class="memTemplParams" colspan="2"><a id="a3eff0342e8a7b5e15dcf232d7f28f961"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3eff0342e8a7b5e15dcf232d7f28f961"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3eff0342e8a7b5e15dcf232d7f28f961">IsIntersecting</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a3eff0342e8a7b5e15dcf232d7f28f961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two value ranges have any intersection/overlap at all. <br /></td></tr>
<tr class="separator:a3eff0342e8a7b5e15dcf232d7f28f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="memTemplParams" colspan="2"><a id="a4baf1dd76711ae5151d0ee07a8b345d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4baf1dd76711ae5151d0ee07a8b345d0">GetIntersection</a> (<a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the intersecting interval of two given ranges. <br /></td></tr>
<tr class="separator:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537b76dc4bd198e60d148282e032533c"><td class="memTemplParams" colspan="2"><a id="a537b76dc4bd198e60d148282e032533c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a537b76dc4bd198e60d148282e032533c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a537b76dc4bd198e60d148282e032533c">IsEntirelyBefore</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a537b76dc4bd198e60d148282e032533c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range is entirely before the second range. <br /></td></tr>
<tr class="separator:a537b76dc4bd198e60d148282e032533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6f0d8de107567baafd2ff6770ded72"><td class="memTemplParams" colspan="2"><a id="abc6f0d8de107567baafd2ff6770ded72"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc6f0d8de107567baafd2ff6770ded72"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abc6f0d8de107567baafd2ff6770ded72">IsEntirelyAfter</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:abc6f0d8de107567baafd2ff6770ded72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range is entirely after the second range. <br /></td></tr>
<tr class="separator:abc6f0d8de107567baafd2ff6770ded72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133337daeb0dd2b8b5a78f42a8a526"><td class="memTemplParams" colspan="2"><a id="a32133337daeb0dd2b8b5a78f42a8a526"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32133337daeb0dd2b8b5a78f42a8a526"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a32133337daeb0dd2b8b5a78f42a8a526">IsEntirelyEnclosing</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a32133337daeb0dd2b8b5a78f42a8a526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range entirely encloses the second. <br /></td></tr>
<tr class="separator:a32133337daeb0dd2b8b5a78f42a8a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b97d7e2f5894048236948061068fb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1b97d7e2f5894048236948061068fb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac1b97d7e2f5894048236948061068fb5">operator==</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ac1b97d7e2f5894048236948061068fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="namespaceplayrho.html#ac1b97d7e2f5894048236948061068fb5">More...</a><br /></td></tr>
<tr class="separator:ac1b97d7e2f5894048236948061068fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861fb100d29d58d6f26f3767017886b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a861fb100d29d58d6f26f3767017886b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a861fb100d29d58d6f26f3767017886b3">operator!=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a861fb100d29d58d6f26f3767017886b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="namespaceplayrho.html#a861fb100d29d58d6f26f3767017886b3">More...</a><br /></td></tr>
<tr class="separator:a861fb100d29d58d6f26f3767017886b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815e65e38974a8bb60ef0a096bea0241"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a815e65e38974a8bb60ef0a096bea0241"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a815e65e38974a8bb60ef0a096bea0241">operator&lt;</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a815e65e38974a8bb60ef0a096bea0241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator.  <a href="namespaceplayrho.html#a815e65e38974a8bb60ef0a096bea0241">More...</a><br /></td></tr>
<tr class="separator:a815e65e38974a8bb60ef0a096bea0241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf50e7e086182f69dc09e011aef6345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbf50e7e086182f69dc09e011aef6345"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adbf50e7e086182f69dc09e011aef6345">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:adbf50e7e086182f69dc09e011aef6345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator.  <a href="namespaceplayrho.html#adbf50e7e086182f69dc09e011aef6345">More...</a><br /></td></tr>
<tr class="separator:adbf50e7e086182f69dc09e011aef6345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acc58a55aab3f8bdd7ea411a6b2a4ddfb">operator&gt;</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator.  <a href="namespaceplayrho.html#acc58a55aab3f8bdd7ea411a6b2a4ddfb">More...</a><br /></td></tr>
<tr class="separator:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca7f35c089808652f6c5d6c06a85ae7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acca7f35c089808652f6c5d6c06a85ae7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acca7f35c089808652f6c5d6c06a85ae7">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acca7f35c089808652f6c5d6c06a85ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator.  <a href="namespaceplayrho.html#acca7f35c089808652f6c5d6c06a85ae7">More...</a><br /></td></tr>
<tr class="separator:acca7f35c089808652f6c5d6c06a85ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5053c1cb8807f6296852e4a8c657d2"><td class="memTemplParams" colspan="2"><a id="acd5053c1cb8807f6296852e4a8c657d2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd5053c1cb8807f6296852e4a8c657d2"><td class="memTemplItemLeft" align="right" valign="top">::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acd5053c1cb8807f6296852e4a8c657d2">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:acd5053c1cb8807f6296852e4a8c657d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator. <br /></td></tr>
<tr class="separator:acd5053c1cb8807f6296852e4a8c657d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c036532db1260373b97c1d85360894c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8c036532db1260373b97c1d85360894c">GetDelta</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:ga8c036532db1260373b97c1d85360894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest angular distance to go from angle 1 to angle 2.  <a href="group__Math.html#ga8c036532db1260373b97c1d85360894c">More...</a><br /></td></tr>
<tr class="separator:ga8c036532db1260373b97c1d85360894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae769785f0540a4b8960b282f6b105c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">ComputeCentroid</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gae769785f0540a4b8960b282f6b105c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a counter-clockwise array of 3 or more vertices.  <a href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">More...</a><br /></td></tr>
<tr class="separator:gae769785f0540a4b8960b282f6b105c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3b8e8abc999b0c63cf1921b0edcf0b36">GetCircleVertices</a> (<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius, unsigned slices, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> start=0_deg, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> turns=<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{1})</td></tr>
<tr class="memdesc:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertices for a circle described by the given parameters. <br /></td></tr>
<tr class="separator:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0eb57dabfe8d3db9e509a6b493173358">GetAreaOfCircle</a> (<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> radius)</td></tr>
<tr class="memdesc:ga0eb57dabfe8d3db9e509a6b493173358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a circle. <br /></td></tr>
<tr class="separator:ga0eb57dabfe8d3db9e509a6b493173358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118f8284073d2638e48ef8f13177e1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">GetAreaOfPolygon</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga118f8284073d2638e48ef8f13177e1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a polygon.  <a href="group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">More...</a><br /></td></tr>
<tr class="separator:ga118f8284073d2638e48ef8f13177e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#ga9ded7e1044d55beb1ca2957d671ece44">SecondMomentOfArea</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">GetPolarMoment</a> (<a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; vertices)</td></tr>
<tr class="memdesc:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the polar moment of the area enclosed by the given vertices.  <a href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">More...</a><br /></td></tr>
<tr class="separator:ga760adfdd1cb30bdae8cd37c1ae5da485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd37c6d7e9a46ee2138492ccd17165e"><td class="memTemplParams" colspan="2"><a id="a8fd37c6d7e9a46ee2138492ccd17165e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fd37c6d7e9a46ee2138492ccd17165e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8fd37c6d7e9a46ee2138492ccd17165e">GetX</a> (T &amp;value)</td></tr>
<tr class="memdesc:a8fd37c6d7e9a46ee2138492ccd17165e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "X" element of the given value - i.e. the first element. <br /></td></tr>
<tr class="separator:a8fd37c6d7e9a46ee2138492ccd17165e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29239cb64970d1f73cd92e104940e7e"><td class="memTemplParams" colspan="2"><a id="af29239cb64970d1f73cd92e104940e7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af29239cb64970d1f73cd92e104940e7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af29239cb64970d1f73cd92e104940e7e">GetY</a> (T &amp;value)</td></tr>
<tr class="memdesc:af29239cb64970d1f73cd92e104940e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Y" element of the given value - i.e. the second element. <br /></td></tr>
<tr class="separator:af29239cb64970d1f73cd92e104940e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f3bfa45db75276f0b40ec3b44c9b6c"><td class="memTemplParams" colspan="2"><a id="ac5f3bfa45db75276f0b40ec3b44c9b6c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5f3bfa45db75276f0b40ec3b44c9b6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac5f3bfa45db75276f0b40ec3b44c9b6c">GetZ</a> (T &amp;value)</td></tr>
<tr class="memdesc:ac5f3bfa45db75276f0b40ec3b44c9b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Z" element of the given value - i.e. the third element. <br /></td></tr>
<tr class="separator:ac5f3bfa45db75276f0b40ec3b44c9b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f3dd3774eb0c4f476a0a50aea52e4a"><td class="memTemplParams" colspan="2"><a id="a25f3dd3774eb0c4f476a0a50aea52e4a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25f3dd3774eb0c4f476a0a50aea52e4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a25f3dd3774eb0c4f476a0a50aea52e4a">GetX</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a25f3dd3774eb0c4f476a0a50aea52e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "X" element of the given value - i.e. the first element. <br /></td></tr>
<tr class="separator:a25f3dd3774eb0c4f476a0a50aea52e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1883fdee56ab469902384a088a9f25"><td class="memTemplParams" colspan="2"><a id="a1b1883fdee56ab469902384a088a9f25"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b1883fdee56ab469902384a088a9f25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1b1883fdee56ab469902384a088a9f25">GetY</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a1b1883fdee56ab469902384a088a9f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Y" element of the given value - i.e. the second element. <br /></td></tr>
<tr class="separator:a1b1883fdee56ab469902384a088a9f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8874a6f34a63c318d36f8e90e2280543"><td class="memTemplParams" colspan="2"><a id="a8874a6f34a63c318d36f8e90e2280543"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8874a6f34a63c318d36f8e90e2280543"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8874a6f34a63c318d36f8e90e2280543">GetZ</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a8874a6f34a63c318d36f8e90e2280543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Z" element of the given value - i.e. the third element. <br /></td></tr>
<tr class="separator:a8874a6f34a63c318d36f8e90e2280543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e0e4246787f364251d07688fea46e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49e0e4246787f364251d07688fea46e5"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_signed&lt; T &gt;::value, std::make_unsigned_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a49e0e4246787f364251d07688fea46e5">MakeUnsigned</a> (const T &amp;arg) noexcept</td></tr>
<tr class="memdesc:a49e0e4246787f364251d07688fea46e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the given <b>value</b> into an <b>unsigned value</b>.  <a href="namespaceplayrho.html#a49e0e4246787f364251d07688fea46e5">More...</a><br /></td></tr>
<tr class="separator:a49e0e4246787f364251d07688fea46e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aad07dca595ebb37551e793171c2cfa"><td class="memTemplParams" colspan="2"><a id="a7aad07dca595ebb37551e793171c2cfa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7aad07dca595ebb37551e793171c2cfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7aad07dca595ebb37551e793171c2cfa">StripUnit</a> (const T &amp;v) -&gt; decltype(StripUnit(v.get()))</td></tr>
<tr class="memdesc:a7aad07dca595ebb37551e793171c2cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the unit from the given value. <br /></td></tr>
<tr class="separator:a7aad07dca595ebb37551e793171c2cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf6fb58c36515834217c6b150b43772"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga9cf6fb58c36515834217c6b150b43772"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga9cf6fb58c36515834217c6b150b43772">Secant</a> (T target, U a1, T s1, U a2, T s2) noexcept</td></tr>
<tr class="memdesc:ga9cf6fb58c36515834217c6b150b43772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secant method.  <a href="group__Math.html#ga9cf6fb58c36515834217c6b150b43772">More...</a><br /></td></tr>
<tr class="separator:ga9cf6fb58c36515834217c6b150b43772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8ccc71ac7ccd063fd81a31d78c3d2c90">Bisect</a> (T a1, T a2) noexcept</td></tr>
<tr class="memdesc:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection method.  <a href="group__Math.html#ga8ccc71ac7ccd063fd81a31d78c3d2c90">More...</a><br /></td></tr>
<tr class="separator:ga8ccc71ac7ccd063fd81a31d78c3d2c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76721557b2b677d24efa2d0415954be5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga76721557b2b677d24efa2d0415954be5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga76721557b2b677d24efa2d0415954be5">IsOdd</a> (T val) noexcept</td></tr>
<tr class="memdesc:ga76721557b2b677d24efa2d0415954be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-odd.  <a href="group__Math.html#ga76721557b2b677d24efa2d0415954be5">More...</a><br /></td></tr>
<tr class="separator:ga76721557b2b677d24efa2d0415954be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplParams" colspan="2">
template&lt;class TYPE &gt; </td></tr>
<tr class="memitem:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga948ebcbc9ef959d24546e6c8ff848fa6">Square</a> (TYPE t) noexcept</td></tr>
<tr class="memdesc:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the given value. <br /></td></tr>
<tr class="separator:ga948ebcbc9ef959d24546e6c8ff848fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">Atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:gab870a9188fcc77c905807fa718a8268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values.  <a href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">More...</a><br /></td></tr>
<tr class="separator:gab870a9188fcc77c905807fa718a8268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2133f1c2e5299035bb059d2d2706cd"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename  = std::enable_if_t&lt;    IsIterable&lt;T&gt;::value &amp;&amp; IsAddable&lt;decltype(*begin(std::declval&lt;T&gt;()))&gt;::value&gt; </td></tr>
<tr class="memitem:ga8b2133f1c2e5299035bb059d2d2706cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8b2133f1c2e5299035bb059d2d2706cd">Average</a> (const T &amp;span)</td></tr>
<tr class="memdesc:ga8b2133f1c2e5299035bb059d2d2706cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of the given values. <br /></td></tr>
<tr class="separator:ga8b2133f1c2e5299035bb059d2d2706cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsArithmetic.html">IsArithmetic</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab8f24574b8a0ca458ec2fe9d691364ff">RoundOff</a> (T value, unsigned precision=100000)</td></tr>
<tr class="memdesc:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:gab8f24574b8a0ca458ec2fe9d691364ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga812ea5eaf66fb9d1bffa799886b2eee3">RoundOff</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> value, std::uint32_t precision=100000)</td></tr>
<tr class="memdesc:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga812ea5eaf66fb9d1bffa799886b2eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901850dd04519b8e6d642ab96a10d9ea"><td class="memTemplParams" colspan="2">
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga901850dd04519b8e6d642ab96a10d9ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga901850dd04519b8e6d642ab96a10d9ea">abs</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga901850dd04519b8e6d642ab96a10d9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value function for vectors. <br /></td></tr>
<tr class="separator:ga901850dd04519b8e6d642ab96a10d9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac862a8609b82126d0683ecb38a498087"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gac862a8609b82126d0683ecb38a498087">abs</a> (const <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a> &amp;v) noexcept</td></tr>
<tr class="memdesc:gac862a8609b82126d0683ecb38a498087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:gac862a8609b82126d0683ecb38a498087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0270fbd098406a8cf4496d1de8a155"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafd0270fbd098406a8cf4496d1de8a155"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gafd0270fbd098406a8cf4496d1de8a155">AlmostZero</a> (T value)</td></tr>
<tr class="memdesc:gafd0270fbd098406a8cf4496d1de8a155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group__Math.html#gafd0270fbd098406a8cf4496d1de8a155">More...</a><br /></td></tr>
<tr class="separator:gafd0270fbd098406a8cf4496d1de8a155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c5f66dc1a40a727a7983aab1d92929"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga00c5f66dc1a40a727a7983aab1d92929"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_floating_point&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga00c5f66dc1a40a727a7983aab1d92929">AlmostEqual</a> (T x, T y, int ulp=2)</td></tr>
<tr class="memdesc:ga00c5f66dc1a40a727a7983aab1d92929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga00c5f66dc1a40a727a7983aab1d92929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga25b52facf9e28f05e5e41f4e7b7ff54e">ModuloViaFmod</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::fmod</code>.  <a href="group__Math.html#ga25b52facf9e28f05e5e41f4e7b7ff54e">More...</a><br /></td></tr>
<tr class="separator:ga25b52facf9e28f05e5e41f4e7b7ff54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">ModuloViaTrunc</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::trunc</code>.  <a href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">More...</a><br /></td></tr>
<tr class="separator:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156a2abff11f978a8df25efbf0c10147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">GetNormalized</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> value) noexcept</td></tr>
<tr class="memdesc:ga156a2abff11f978a8df25efbf0c10147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" value of the given angle.  <a href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">More...</a><br /></td></tr>
<tr class="separator:ga156a2abff11f978a8df25efbf0c10147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga56785e4c60180ef416fe29f68ccf525a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga56785e4c60180ef416fe29f68ccf525a">GetAngle</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; value)</td></tr>
<tr class="memdesc:ga56785e4c60180ef416fe29f68ccf525a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle.  <a href="group__Math.html#ga56785e4c60180ef416fe29f68ccf525a">More...</a><br /></td></tr>
<tr class="separator:ga56785e4c60180ef416fe29f68ccf525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1ac00e661c653f21ddbd0693bbb039ac">GetMagnitudeSquared</a> (T value) noexcept</td></tr>
<tr class="memdesc:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the magnitude of the given iterable value.  <a href="group__Math.html#ga1ac00e661c653f21ddbd0693bbb039ac">More...</a><br /></td></tr>
<tr class="separator:ga1ac00e661c653f21ddbd0693bbb039ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">GetMagnitude</a> (T value)</td></tr>
<tr class="memdesc:ga85c114f129eeee63e60ec7d4703bbd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the magnitude of the given value.  <a href="group__Math.html#ga85c114f129eeee63e60ec7d4703bbd65">More...</a><br /></td></tr>
<tr class="separator:ga85c114f129eeee63e60ec7d4703bbd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga451c8554a408d41df85a41650e0ada93"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga451c8554a408d41df85a41650e0ada93">Dot</a> (const T1 a, const T2 b) noexcept</td></tr>
<tr class="memdesc:ga451c8554a408d41df85a41650e0ada93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors (A and B).  <a href="group__Math.html#ga451c8554a408d41df85a41650e0ada93">More...</a><br /></td></tr>
<tr class="separator:ga451c8554a408d41df85a41650e0ada93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804d55e7545685ee9841c239bdac7c8f"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size&lt; T1 &gt;::value==2 &amp;&amp;std::tuple_size&lt; T2 &gt;::value==2, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga804d55e7545685ee9841c239bdac7c8f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga804d55e7545685ee9841c239bdac7c8f">Cross</a> (T1 a, T2 b) noexcept</td></tr>
<tr class="memdesc:ga804d55e7545685ee9841c239bdac7c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-element analog of the cross product of two vectors.  <a href="group__Math.html#ga804d55e7545685ee9841c239bdac7c8f">More...</a><br /></td></tr>
<tr class="separator:ga804d55e7545685ee9841c239bdac7c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3846333746b73978c91e250c6f239ce3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3846333746b73978c91e250c6f239ce3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3846333746b73978c91e250c6f239ce3">Solve</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt; mat, const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; b) noexcept</td></tr>
<tr class="memdesc:ga3846333746b73978c91e250c6f239ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga3846333746b73978c91e250c6f239ce3">More...</a><br /></td></tr>
<tr class="separator:ga3846333746b73978c91e250c6f239ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplParams" colspan="2">
template&lt;class IN_TYPE &gt; </td></tr>
<tr class="memitem:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga00cc9646bab6ce84d6b4704f8c1e0ade">Invert</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; IN_TYPE &gt; value) noexcept</td></tr>
<tr class="memdesc:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the given value. <br /></td></tr>
<tr class="separator:ga00cc9646bab6ce84d6b4704f8c1e0ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4795a90a377c5335ce5b1900caf6d24"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gab4795a90a377c5335ce5b1900caf6d24">Solve33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> b) noexcept</td></tr>
<tr class="memdesc:gab4795a90a377c5335ce5b1900caf6d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#gab4795a90a377c5335ce5b1900caf6d24">More...</a><br /></td></tr>
<tr class="separator:gab4795a90a377c5335ce5b1900caf6d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a0606abee6bd0cc122578a2a640f044"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0a0606abee6bd0cc122578a2a640f044">Solve22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const T b) noexcept</td></tr>
<tr class="memdesc:ga0a0606abee6bd0cc122578a2a640f044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga0a0606abee6bd0cc122578a2a640f044">More...</a><br /></td></tr>
<tr class="separator:ga0a0606abee6bd0cc122578a2a640f044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaceaa1218e1f86e27e6678db247bc79"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaeaceaa1218e1f86e27e6678db247bc79">GetInverse22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gaeaceaa1218e1f86e27e6678db247bc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the inverse of the given matrix as a 2-by-2.  <a href="group__Math.html#gaeaceaa1218e1f86e27e6678db247bc79">More...</a><br /></td></tr>
<tr class="separator:gaeaceaa1218e1f86e27e6678db247bc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a513e105038f6425bfc83180a69cd3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae7a513e105038f6425bfc83180a69cd3">GetSymInverse33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:gae7a513e105038f6425bfc83180a69cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the symmetric inverse of this matrix as a 3-by-3.  <a href="group__Math.html#gae7a513e105038f6425bfc83180a69cd3">More...</a><br /></td></tr>
<tr class="separator:gae7a513e105038f6425bfc83180a69cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6aa0aece94173885da01b5e3a6737af7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga6aa0aece94173885da01b5e3a6737af7">GetRevPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga6aa0aece94173885da01b5e3a6737af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.  <a href="group__Math.html#ga6aa0aece94173885da01b5e3a6737af7">More...</a><br /></td></tr>
<tr class="separator:ga6aa0aece94173885da01b5e3a6737af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga87b57d633b625c58f9200a201e4664a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga87b57d633b625c58f9200a201e4664a7">GetFwdPerpendicular</a> (const T vector) noexcept</td></tr>
<tr class="memdesc:ga87b57d633b625c58f9200a201e4664a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.  <a href="group__Math.html#ga87b57d633b625c58f9200a201e4664a7">More...</a><br /></td></tr>
<tr class="separator:ga87b57d633b625c58f9200a201e4664a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac898f9ba1986f3886cb93c0668613c41"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, typename T1 , std::size_t N, typename T2 &gt; </td></tr>
<tr class="memitem:gac898f9ba1986f3886cb93c0668613c41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gac898f9ba1986f3886cb93c0668613c41">Transform</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, M &gt; v, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T2, M, N &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gac898f9ba1986f3886cb93c0668613c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an M-element vector by an M-by-N matrix.  <a href="group__Math.html#gac898f9ba1986f3886cb93c0668613c41">More...</a><br /></td></tr>
<tr class="separator:gac898f9ba1986f3886cb93c0668613c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a7716aaab729705e73d4d533e81672"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga52a7716aaab729705e73d4d533e81672">Transform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga52a7716aaab729705e73d4d533e81672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by a matrix. <br /></td></tr>
<tr class="separator:ga52a7716aaab729705e73d4d533e81672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819a9ef6f9c3d492b5177ca25077618e"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga819a9ef6f9c3d492b5177ca25077618e">InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:ga819a9ef6f9c3d492b5177ca25077618e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform). <br /></td></tr>
<tr class="separator:ga819a9ef6f9c3d492b5177ca25077618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471bae6413067374ab8d8262533e402"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gab471bae6413067374ab8d8262533e402">MulT</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gab471bae6413067374ab8d8262533e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A^T * B. <br /></td></tr>
<tr class="separator:gab471bae6413067374ab8d8262533e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fee43efb2fa412b816e9e0a7df87f8"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga94fee43efb2fa412b816e9e0a7df87f8">abs</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A)</td></tr>
<tr class="memdesc:ga94fee43efb2fa412b816e9e0a7df87f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:ga94fee43efb2fa412b816e9e0a7df87f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e157fe9f9288debcd4be111a2485991"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2e157fe9f9288debcd4be111a2485991"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga2e157fe9f9288debcd4be111a2485991">NextPowerOfTwo</a> (T x)</td></tr>
<tr class="memdesc:ga2e157fe9f9288debcd4be111a2485991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next largest power of 2.  <a href="group__Math.html#ga2e157fe9f9288debcd4be111a2485991">More...</a><br /></td></tr>
<tr class="separator:ga2e157fe9f9288debcd4be111a2485991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">Normalize</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given vector into a unit vector and returns its original length. <br /></td></tr>
<tr class="separator:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaf9689e93a5538424dfb54bbbb78ad217">GetModuloNext</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:gaf9689e93a5538424dfb54bbbb78ad217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo next value. <br /></td></tr>
<tr class="separator:gaf9689e93a5538424dfb54bbbb78ad217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37e627f196ec102af9dd855d05611a6e"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37e627f196ec102af9dd855d05611a6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga37e627f196ec102af9dd855d05611a6e">GetModuloPrev</a> (T value, T count) noexcept</td></tr>
<tr class="memdesc:ga37e627f196ec102af9dd855d05611a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo previous value. <br /></td></tr>
<tr class="separator:ga37e627f196ec102af9dd855d05611a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dcf271b85b501cd2d7188902066e55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga07dcf271b85b501cd2d7188902066e55">GetRevRotationalAngle</a> (<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a1, <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a> a2) noexcept</td></tr>
<tr class="memdesc:ga07dcf271b85b501cd2d7188902066e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2.  <a href="group__Math.html#ga07dcf271b85b501cd2d7188902066e55">More...</a><br /></td></tr>
<tr class="separator:ga07dcf271b85b501cd2d7188902066e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e64649a393ae84ea092662d18089732"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9e64649a393ae84ea092662d18089732"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T &gt;::value, <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, N, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9e64649a393ae84ea092662d18089732">GetIdentityMatrix</a> ()</td></tr>
<tr class="memdesc:a9e64649a393ae84ea092662d18089732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the identity matrix of the template type and size.  <a href="namespaceplayrho.html#a9e64649a393ae84ea092662d18089732">More...</a><br /></td></tr>
<tr class="separator:a9e64649a393ae84ea092662d18089732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982dd137f465f53dd7c84e6d6286a3ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a982dd137f465f53dd7c84e6d6286a3ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsSquareMatrix.html">IsSquareMatrix</a>&lt; T &gt;::value, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a982dd137f465f53dd7c84e6d6286a3ad">GetIdentity</a> ()</td></tr>
<tr class="memdesc:a982dd137f465f53dd7c84e6d6286a3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the identity matrix of the template type and size as given by the argument.  <a href="namespaceplayrho.html#a982dd137f465f53dd7c84e6d6286a3ad">More...</a><br /></td></tr>
<tr class="separator:a982dd137f465f53dd7c84e6d6286a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02258b390c2e52afd55c14ae9fb21556"><td class="memTemplParams" colspan="2"><a id="a02258b390c2e52afd55c14ae9fb21556"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a02258b390c2e52afd55c14ae9fb21556"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a02258b390c2e52afd55c14ae9fb21556">GetRowMatrix</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; arg)</td></tr>
<tr class="memdesc:a02258b390c2e52afd55c14ae9fb21556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified row of the given matrix as a row matrix. <br /></td></tr>
<tr class="separator:a02258b390c2e52afd55c14ae9fb21556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a775c6e97cd4708fe5e9f58860a53d"><td class="memTemplParams" colspan="2"><a id="a93a775c6e97cd4708fe5e9f58860a53d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a93a775c6e97cd4708fe5e9f58860a53d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 1 &gt;, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a93a775c6e97cd4708fe5e9f58860a53d">GetColumnMatrix</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; arg)</td></tr>
<tr class="memdesc:a93a775c6e97cd4708fe5e9f58860a53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified column of the given matrix as a column matrix. <br /></td></tr>
<tr class="separator:a93a775c6e97cd4708fe5e9f58860a53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0c49a750ed51bb02cef10158e8d7f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a41f0c49a750ed51bb02cef10158e8d7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a41f0c49a750ed51bb02cef10158e8d7f">operator+</a> (const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;lhs, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a41f0c49a750ed51bb02cef10158e8d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix addition operator for two same-type, same-sized matrices.  <a href="namespaceplayrho.html#a41f0c49a750ed51bb02cef10158e8d7f">More...</a><br /></td></tr>
<tr class="separator:a41f0c49a750ed51bb02cef10158e8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89118d71eeeffa541c76f6d566a8546d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a89118d71eeeffa541c76f6d566a8546d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a89118d71eeeffa541c76f6d566a8546d">operator-</a> (const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;lhs, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a89118d71eeeffa541c76f6d566a8546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix subtraction operator for two same-type, same-sized matrices.  <a href="namespaceplayrho.html#a89118d71eeeffa541c76f6d566a8546d">More...</a><br /></td></tr>
<tr class="separator:a89118d71eeeffa541c76f6d566a8546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0fa02e6b0d55e9363ad4afb89a755fc1">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="namespaceplayrho.html#a0fa02e6b0d55e9363ad4afb89a755fc1">More...</a><br /></td></tr>
<tr class="separator:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4eafabdd97553a750feb39943d629da"><td class="memItemLeft" align="right" valign="top"><a id="aa4eafabdd97553a750feb39943d629da"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa4eafabdd97553a750feb39943d629da"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa4eafabdd97553a750feb39943d629da">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Position.html">d2::Position</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:aa4eafabdd97553a750feb39943d629da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:aa4eafabdd97553a750feb39943d629da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaf30d44caa739e24d21d763b90030c"><td class="memTemplParams" colspan="2"><a id="abbaf30d44caa739e24d21d763b90030c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abbaf30d44caa739e24d21d763b90030c"><td class="memTemplItemLeft" align="right" valign="top">PROPAGATE_CONST_CONSTEXPR void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abbaf30d44caa739e24d21d763b90030c">swap</a> (<a class="el" href="classplayrho_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;pt, <a class="el" href="classplayrho_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;pu) noexcept(noexcept(swap(std::declval&lt; T &amp; &gt;(), std::declval&lt; T &amp; &gt;())))</td></tr>
<tr class="memdesc:abbaf30d44caa739e24d21d763b90030c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for swap operation. <br /></td></tr>
<tr class="separator:abbaf30d44caa739e24d21d763b90030c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eebf111910b8b036f4caca5e01fcab3"><td class="memItemLeft" align="right" valign="top"><a id="a4eebf111910b8b036f4caca5e01fcab3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4eebf111910b8b036f4caca5e01fcab3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4eebf111910b8b036f4caca5e01fcab3">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1Sweep.html">d2::Sweep</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a4eebf111910b8b036f4caca5e01fcab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a4eebf111910b8b036f4caca5e01fcab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465a2b892f4effbc98c1b2468d6eb56a"><td class="memTemplParams" colspan="2"><a id="a465a2b892f4effbc98c1b2468d6eb56a"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a465a2b892f4effbc98c1b2468d6eb56a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a465a2b892f4effbc98c1b2468d6eb56a">NOT_USED</a> (T &amp;&amp;...)</td></tr>
<tr class="memdesc:a465a2b892f4effbc98c1b2468d6eb56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Not used" annotator. <br /></td></tr>
<tr class="separator:a465a2b892f4effbc98c1b2468d6eb56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7dde95b5e9b50eb6552368d0c57cfc88">IsValid</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="namespaceplayrho.html#a7dde95b5e9b50eb6552368d0c57cfc88">More...</a><br /></td></tr>
<tr class="separator:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048e0ad2c0fac1472430520c115466eb"><td class="memItemLeft" align="right" valign="top"><a id="a048e0ad2c0fac1472430520c115466eb"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a048e0ad2c0fac1472430520c115466eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a048e0ad2c0fac1472430520c115466eb">IsValid</a> (const std::size_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a048e0ad2c0fac1472430520c115466eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a048e0ad2c0fac1472430520c115466eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad559996a9d085eb07a18b5b88525761f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad559996a9d085eb07a18b5b88525761f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad559996a9d085eb07a18b5b88525761f">EraseFirst</a> (T &amp;container, const U &amp;value) -&gt; decltype(container.erase(find(begin(container), end(container), value)) !=end(container))</td></tr>
<tr class="memdesc:ad559996a9d085eb07a18b5b88525761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template function for erasing first found value from container.  <a href="namespaceplayrho.html#ad559996a9d085eb07a18b5b88525761f">More...</a><br /></td></tr>
<tr class="separator:ad559996a9d085eb07a18b5b88525761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa5b77298f0fc2a2ae88ececbc3fb23d1">EraseAll</a> (T &amp;container, const U &amp;value) -&gt; decltype(distance(container.erase(remove(begin(container), end(container), value), end(container)), end(container)))</td></tr>
<tr class="memdesc:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template function for erasing specified value from container.  <a href="namespaceplayrho.html#aa5b77298f0fc2a2ae88ececbc3fb23d1">More...</a><br /></td></tr>
<tr class="separator:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdecea4e39775053f705ca921b5080fe"><td class="memItemLeft" align="right" valign="top"><a id="abdecea4e39775053f705ca921b5080fe"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abdecea4e39775053f705ca921b5080fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abdecea4e39775053f705ca921b5080fe">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Transformation.html">d2::Transformation</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:abdecea4e39775053f705ca921b5080fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:abdecea4e39775053f705ca921b5080fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f58fd1d245f78d15f4415f5cef57c6"><td class="memItemLeft" align="right" valign="top"><a id="a31f58fd1d245f78d15f4415f5cef57c6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a31f58fd1d245f78d15f4415f5cef57c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a31f58fd1d245f78d15f4415f5cef57c6">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a31f58fd1d245f78d15f4415f5cef57c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a31f58fd1d245f78d15f4415f5cef57c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45e948cf36b820a949cc0a915e12c6c"><td class="memTemplParams" colspan="2"><a id="ad45e948cf36b820a949cc0a915e12c6c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad45e948cf36b820a949cc0a915e12c6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad45e948cf36b820a949cc0a915e12c6c">GetTypeID</a> ()</td></tr>
<tr class="memdesc:ad45e948cf36b820a949cc0a915e12c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type ID for the template parameter type. <br /></td></tr>
<tr class="separator:ad45e948cf36b820a949cc0a915e12c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9958a9d60c4d64c45260d4b0971f314e"><td class="memTemplParams" colspan="2"><a id="a9958a9d60c4d64c45260d4b0971f314e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9958a9d60c4d64c45260d4b0971f314e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9958a9d60c4d64c45260d4b0971f314e">GetTypeID</a> (T)</td></tr>
<tr class="memdesc:a9958a9d60c4d64c45260d4b0971f314e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type ID for the function parameter type. <br /></td></tr>
<tr class="separator:a9958a9d60c4d64c45260d4b0971f314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470dc644f20793cbc54ed79ad49fb491"><td class="memItemLeft" align="right" valign="top"><a id="a470dc644f20793cbc54ed79ad49fb491"></a>
constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a470dc644f20793cbc54ed79ad49fb491">GetName</a> (<a class="el" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a> id) noexcept</td></tr>
<tr class="memdesc:a470dc644f20793cbc54ed79ad49fb491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name associated with the given type ID. <br /></td></tr>
<tr class="separator:a470dc644f20793cbc54ed79ad49fb491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267edfe760bf1c787ca0487b93e0c719"><td class="memTemplParams" colspan="2"><a id="a267edfe760bf1c787ca0487b93e0c719"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a267edfe760bf1c787ca0487b93e0c719"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a267edfe760bf1c787ca0487b93e0c719">GetTypeName</a> () noexcept</td></tr>
<tr class="memdesc:a267edfe760bf1c787ca0487b93e0c719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name associated with the given template parameter type. <br /></td></tr>
<tr class="separator:a267edfe760bf1c787ca0487b93e0c719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce86132eda24d9d313987cba6a40c16"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga6ce86132eda24d9d313987cba6a40c16">operator&quot;&quot;_g</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga6ce86132eda24d9d313987cba6a40c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gram unit of Mass.  <a href="group__Unitsymbols.html#ga6ce86132eda24d9d313987cba6a40c16">More...</a><br /></td></tr>
<tr class="separator:ga6ce86132eda24d9d313987cba6a40c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99c0b153cdb012f8093f047b1e3b13a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab99c0b153cdb012f8093f047b1e3b13a">operator&quot;&quot;_g</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab99c0b153cdb012f8093f047b1e3b13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gram unit of Mass.  <a href="group__Unitsymbols.html#gab99c0b153cdb012f8093f047b1e3b13a">More...</a><br /></td></tr>
<tr class="separator:gab99c0b153cdb012f8093f047b1e3b13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4275b8597bcf1f8a32e4ac63d15e8c2e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4275b8597bcf1f8a32e4ac63d15e8c2e">operator&quot;&quot;_kg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga4275b8597bcf1f8a32e4ac63d15e8c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a kilogram unit of Mass.  <a href="group__Unitsymbols.html#ga4275b8597bcf1f8a32e4ac63d15e8c2e">More...</a><br /></td></tr>
<tr class="separator:ga4275b8597bcf1f8a32e4ac63d15e8c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0583d00d5cfbd6ebafb90513fb2e8716"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga0583d00d5cfbd6ebafb90513fb2e8716">operator&quot;&quot;_kg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga0583d00d5cfbd6ebafb90513fb2e8716"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a kilogram unit of Mass.  <a href="group__Unitsymbols.html#ga0583d00d5cfbd6ebafb90513fb2e8716">More...</a><br /></td></tr>
<tr class="separator:ga0583d00d5cfbd6ebafb90513fb2e8716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5ea7c8025fab0245e701dd6b8d007e3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gac5ea7c8025fab0245e701dd6b8d007e3">operator&quot;&quot;_Pg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gac5ea7c8025fab0245e701dd6b8d007e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a petagram unit of Mass.  <a href="group__Unitsymbols.html#gac5ea7c8025fab0245e701dd6b8d007e3">More...</a><br /></td></tr>
<tr class="separator:gac5ea7c8025fab0245e701dd6b8d007e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaac22c102dd87d993148b80a1eee53f5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaaac22c102dd87d993148b80a1eee53f5">operator&quot;&quot;_Pg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaaac22c102dd87d993148b80a1eee53f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a petagram unit of Mass.  <a href="group__Unitsymbols.html#gaaac22c102dd87d993148b80a1eee53f5">More...</a><br /></td></tr>
<tr class="separator:gaaac22c102dd87d993148b80a1eee53f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33cea28a3e64ca1c6d99f7f8faf94fce"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga33cea28a3e64ca1c6d99f7f8faf94fce">operator&quot;&quot;_Yg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga33cea28a3e64ca1c6d99f7f8faf94fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a yottagram unit of Mass.  <a href="group__Unitsymbols.html#ga33cea28a3e64ca1c6d99f7f8faf94fce">More...</a><br /></td></tr>
<tr class="separator:ga33cea28a3e64ca1c6d99f7f8faf94fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72c48eb6e122d69ef30a66c46097e4d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gae72c48eb6e122d69ef30a66c46097e4d">operator&quot;&quot;_Yg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gae72c48eb6e122d69ef30a66c46097e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a yottagram unit of Mass.  <a href="group__Unitsymbols.html#gae72c48eb6e122d69ef30a66c46097e4d">More...</a><br /></td></tr>
<tr class="separator:gae72c48eb6e122d69ef30a66c46097e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44de43c674315e6fbd85b6e5ddfdaf2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gac44de43c674315e6fbd85b6e5ddfdaf2">operator&quot;&quot;_m</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gac44de43c674315e6fbd85b6e5ddfdaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a meter of Length.  <a href="group__Unitsymbols.html#gac44de43c674315e6fbd85b6e5ddfdaf2">More...</a><br /></td></tr>
<tr class="separator:gac44de43c674315e6fbd85b6e5ddfdaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d89f0cf5e3cfca6baca44e120dca07e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga7d89f0cf5e3cfca6baca44e120dca07e">operator&quot;&quot;_m</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga7d89f0cf5e3cfca6baca44e120dca07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a meter of Length.  <a href="group__Unitsymbols.html#ga7d89f0cf5e3cfca6baca44e120dca07e">More...</a><br /></td></tr>
<tr class="separator:ga7d89f0cf5e3cfca6baca44e120dca07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae82c9c088bc93622218a1badc9d03b5a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gae82c9c088bc93622218a1badc9d03b5a">operator&quot;&quot;_dm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gae82c9c088bc93622218a1badc9d03b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a decimeter of Length.  <a href="group__Unitsymbols.html#gae82c9c088bc93622218a1badc9d03b5a">More...</a><br /></td></tr>
<tr class="separator:gae82c9c088bc93622218a1badc9d03b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d299ad14289355c2f342e05e73e1b20"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga0d299ad14289355c2f342e05e73e1b20">operator&quot;&quot;_dm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga0d299ad14289355c2f342e05e73e1b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a decimeter of Length.  <a href="group__Unitsymbols.html#ga0d299ad14289355c2f342e05e73e1b20">More...</a><br /></td></tr>
<tr class="separator:ga0d299ad14289355c2f342e05e73e1b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04dc851fdae513e0f9b14f8a4b74c9a1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga04dc851fdae513e0f9b14f8a4b74c9a1">operator&quot;&quot;_cm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga04dc851fdae513e0f9b14f8a4b74c9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a centimeter of Length.  <a href="group__Unitsymbols.html#ga04dc851fdae513e0f9b14f8a4b74c9a1">More...</a><br /></td></tr>
<tr class="separator:ga04dc851fdae513e0f9b14f8a4b74c9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf7524233f643e271fc50aa6d2a4401"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gadbf7524233f643e271fc50aa6d2a4401">operator&quot;&quot;_cm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gadbf7524233f643e271fc50aa6d2a4401"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a centimeter of Length.  <a href="group__Unitsymbols.html#gadbf7524233f643e271fc50aa6d2a4401">More...</a><br /></td></tr>
<tr class="separator:gadbf7524233f643e271fc50aa6d2a4401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf479ecbf0200f8bd8e17e29f731a4382"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaf479ecbf0200f8bd8e17e29f731a4382">operator&quot;&quot;_Gm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gaf479ecbf0200f8bd8e17e29f731a4382"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gigameter unit of Length.  <a href="group__Unitsymbols.html#gaf479ecbf0200f8bd8e17e29f731a4382">More...</a><br /></td></tr>
<tr class="separator:gaf479ecbf0200f8bd8e17e29f731a4382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bac94ca61f289cd740eee1cc43457a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad6bac94ca61f289cd740eee1cc43457a">operator&quot;&quot;_Gm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gad6bac94ca61f289cd740eee1cc43457a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gigameter unit of Length.  <a href="group__Unitsymbols.html#gad6bac94ca61f289cd740eee1cc43457a">More...</a><br /></td></tr>
<tr class="separator:gad6bac94ca61f289cd740eee1cc43457a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ba59041cd8bad1d0d9cfa25849e83c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga96ba59041cd8bad1d0d9cfa25849e83c">operator&quot;&quot;_Mm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga96ba59041cd8bad1d0d9cfa25849e83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a megameter unit of Length.  <a href="group__Unitsymbols.html#ga96ba59041cd8bad1d0d9cfa25849e83c">More...</a><br /></td></tr>
<tr class="separator:ga96ba59041cd8bad1d0d9cfa25849e83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f21b0a602e2254b1262f893afec589"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga28f21b0a602e2254b1262f893afec589">operator&quot;&quot;_Mm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga28f21b0a602e2254b1262f893afec589"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a megameter unit of Length.  <a href="group__Unitsymbols.html#ga28f21b0a602e2254b1262f893afec589">More...</a><br /></td></tr>
<tr class="separator:ga28f21b0a602e2254b1262f893afec589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4a5ced37bf0be5d99290b2d849ba7c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaec4a5ced37bf0be5d99290b2d849ba7c">operator&quot;&quot;_km</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gaec4a5ced37bf0be5d99290b2d849ba7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a kilometer unit of Length.  <a href="group__Unitsymbols.html#gaec4a5ced37bf0be5d99290b2d849ba7c">More...</a><br /></td></tr>
<tr class="separator:gaec4a5ced37bf0be5d99290b2d849ba7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2666059c4896c7f4ee37638f200f92"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gafb2666059c4896c7f4ee37638f200f92">operator&quot;&quot;_km</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gafb2666059c4896c7f4ee37638f200f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a kilometer unit of Length.  <a href="group__Unitsymbols.html#gafb2666059c4896c7f4ee37638f200f92">More...</a><br /></td></tr>
<tr class="separator:gafb2666059c4896c7f4ee37638f200f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e688fefbc6a775e54e3007452ffb31"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad8e688fefbc6a775e54e3007452ffb31">operator&quot;&quot;_s</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gad8e688fefbc6a775e54e3007452ffb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a second unit of Time.  <a href="group__Unitsymbols.html#gad8e688fefbc6a775e54e3007452ffb31">More...</a><br /></td></tr>
<tr class="separator:gad8e688fefbc6a775e54e3007452ffb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3c7c61bf90f4d1d293c0e21a6b91e6c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad3c7c61bf90f4d1d293c0e21a6b91e6c">operator&quot;&quot;_s</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gad3c7c61bf90f4d1d293c0e21a6b91e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a second unit of Time.  <a href="group__Unitsymbols.html#gad3c7c61bf90f4d1d293c0e21a6b91e6c">More...</a><br /></td></tr>
<tr class="separator:gad3c7c61bf90f4d1d293c0e21a6b91e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76dd9ba5e10ec5fff19e862c6eb6233"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaf76dd9ba5e10ec5fff19e862c6eb6233">operator&quot;&quot;_min</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gaf76dd9ba5e10ec5fff19e862c6eb6233"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a minute unit of Time.  <a href="group__Unitsymbols.html#gaf76dd9ba5e10ec5fff19e862c6eb6233">More...</a><br /></td></tr>
<tr class="separator:gaf76dd9ba5e10ec5fff19e862c6eb6233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18e617896083abcb8613740cccb0256f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga18e617896083abcb8613740cccb0256f">operator&quot;&quot;_min</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga18e617896083abcb8613740cccb0256f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a minute unit of Time.  <a href="group__Unitsymbols.html#ga18e617896083abcb8613740cccb0256f">More...</a><br /></td></tr>
<tr class="separator:ga18e617896083abcb8613740cccb0256f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga600eebec225b23a712127c7abc6fcc7f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga600eebec225b23a712127c7abc6fcc7f">operator&quot;&quot;_h</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga600eebec225b23a712127c7abc6fcc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for an hour unit of Time.  <a href="group__Unitsymbols.html#ga600eebec225b23a712127c7abc6fcc7f">More...</a><br /></td></tr>
<tr class="separator:ga600eebec225b23a712127c7abc6fcc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a7e67e9f6f6ce9afd6b5dd838d403ed"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga8a7e67e9f6f6ce9afd6b5dd838d403ed">operator&quot;&quot;_h</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga8a7e67e9f6f6ce9afd6b5dd838d403ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for an hour unit of Time.  <a href="group__Unitsymbols.html#ga8a7e67e9f6f6ce9afd6b5dd838d403ed">More...</a><br /></td></tr>
<tr class="separator:ga8a7e67e9f6f6ce9afd6b5dd838d403ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a3c470d8b4526200a1d2624ddab62e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab5a3c470d8b4526200a1d2624ddab62e">operator&quot;&quot;_d</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gab5a3c470d8b4526200a1d2624ddab62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for a day unit of Time.  <a href="group__Unitsymbols.html#gab5a3c470d8b4526200a1d2624ddab62e">More...</a><br /></td></tr>
<tr class="separator:gab5a3c470d8b4526200a1d2624ddab62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac162fd06cbec0dd5f6139bbe9a84a6af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gac162fd06cbec0dd5f6139bbe9a84a6af">operator&quot;&quot;_d</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gac162fd06cbec0dd5f6139bbe9a84a6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for a day unit of Time.  <a href="group__Unitsymbols.html#gac162fd06cbec0dd5f6139bbe9a84a6af">More...</a><br /></td></tr>
<tr class="separator:gac162fd06cbec0dd5f6139bbe9a84a6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9f386c8751e2883dddc4893dc0182c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaab9f386c8751e2883dddc4893dc0182c">operator&quot;&quot;_rad</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gaab9f386c8751e2883dddc4893dc0182c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a radian unit of Angle.  <a href="group__Unitsymbols.html#gaab9f386c8751e2883dddc4893dc0182c">More...</a><br /></td></tr>
<tr class="separator:gaab9f386c8751e2883dddc4893dc0182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga508a82478f814f16e0a59d960ae70590"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga508a82478f814f16e0a59d960ae70590">operator&quot;&quot;_rad</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga508a82478f814f16e0a59d960ae70590"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a radian unit of Angle.  <a href="group__Unitsymbols.html#ga508a82478f814f16e0a59d960ae70590">More...</a><br /></td></tr>
<tr class="separator:ga508a82478f814f16e0a59d960ae70590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c63e873b437f0cb242bc4bdc6f8af6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaf8c63e873b437f0cb242bc4bdc6f8af6">operator&quot;&quot;_deg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gaf8c63e873b437f0cb242bc4bdc6f8af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for a degree unit of Angle.  <a href="group__Unitsymbols.html#gaf8c63e873b437f0cb242bc4bdc6f8af6">More...</a><br /></td></tr>
<tr class="separator:gaf8c63e873b437f0cb242bc4bdc6f8af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6f526d13a814b761e72261aff8f2f57"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab6f526d13a814b761e72261aff8f2f57">operator&quot;&quot;_deg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab6f526d13a814b761e72261aff8f2f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for a degree unit of Angle.  <a href="group__Unitsymbols.html#gab6f526d13a814b761e72261aff8f2f57">More...</a><br /></td></tr>
<tr class="separator:gab6f526d13a814b761e72261aff8f2f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga930727b91c3eb0546d44b7ae6618222c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga930727b91c3eb0546d44b7ae6618222c">operator&quot;&quot;_N</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga930727b91c3eb0546d44b7ae6618222c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton unit of Force.  <a href="group__Unitsymbols.html#ga930727b91c3eb0546d44b7ae6618222c">More...</a><br /></td></tr>
<tr class="separator:ga930727b91c3eb0546d44b7ae6618222c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571aff9a2615a7a0bed40f9e054b66a7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga571aff9a2615a7a0bed40f9e054b66a7">operator&quot;&quot;_N</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga571aff9a2615a7a0bed40f9e054b66a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton unit of Force.  <a href="group__Unitsymbols.html#ga571aff9a2615a7a0bed40f9e054b66a7">More...</a><br /></td></tr>
<tr class="separator:ga571aff9a2615a7a0bed40f9e054b66a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c8357df9fe338a73682102308ecca7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gac6c8357df9fe338a73682102308ecca7">operator&quot;&quot;_m2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gac6c8357df9fe338a73682102308ecca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter squared unit of Area.  <a href="group__Unitsymbols.html#gac6c8357df9fe338a73682102308ecca7">More...</a><br /></td></tr>
<tr class="separator:gac6c8357df9fe338a73682102308ecca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c8b53142a362994deef473436686e5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga39c8b53142a362994deef473436686e5">operator&quot;&quot;_m2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga39c8b53142a362994deef473436686e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter squared unit of Area.  <a href="group__Unitsymbols.html#ga39c8b53142a362994deef473436686e5">More...</a><br /></td></tr>
<tr class="separator:ga39c8b53142a362994deef473436686e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5523ffa4958cae83ead5ca14aed1d3e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gac5523ffa4958cae83ead5ca14aed1d3e">operator&quot;&quot;_mps</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gac5523ffa4958cae83ead5ca14aed1d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second.  <a href="group__Unitsymbols.html#gac5523ffa4958cae83ead5ca14aed1d3e">More...</a><br /></td></tr>
<tr class="separator:gac5523ffa4958cae83ead5ca14aed1d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbde261f2aeea6755fb870a29530438"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaebbde261f2aeea6755fb870a29530438">operator&quot;&quot;_mps</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaebbde261f2aeea6755fb870a29530438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second.  <a href="group__Unitsymbols.html#gaebbde261f2aeea6755fb870a29530438">More...</a><br /></td></tr>
<tr class="separator:gaebbde261f2aeea6755fb870a29530438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac876272e650fa5949583536207e8d047"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gac876272e650fa5949583536207e8d047">operator&quot;&quot;_kps</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gac876272e650fa5949583536207e8d047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilometer per second.  <a href="group__Unitsymbols.html#gac876272e650fa5949583536207e8d047">More...</a><br /></td></tr>
<tr class="separator:gac876272e650fa5949583536207e8d047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa92eb53b542247ea1a4546ea5d296a7e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaa92eb53b542247ea1a4546ea5d296a7e">operator&quot;&quot;_kps</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaa92eb53b542247ea1a4546ea5d296a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilometer per second.  <a href="group__Unitsymbols.html#gaa92eb53b542247ea1a4546ea5d296a7e">More...</a><br /></td></tr>
<tr class="separator:gaa92eb53b542247ea1a4546ea5d296a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29fd0c08001cd86d9fffaeba8db0bad2"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga29fd0c08001cd86d9fffaeba8db0bad2">operator&quot;&quot;_mps2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga29fd0c08001cd86d9fffaeba8db0bad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second squared.  <a href="group__Unitsymbols.html#ga29fd0c08001cd86d9fffaeba8db0bad2">More...</a><br /></td></tr>
<tr class="separator:ga29fd0c08001cd86d9fffaeba8db0bad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dcac2c8c0ba41800377dfa7fc1396d9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4dcac2c8c0ba41800377dfa7fc1396d9">operator&quot;&quot;_mps2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga4dcac2c8c0ba41800377dfa7fc1396d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second squared.  <a href="group__Unitsymbols.html#ga4dcac2c8c0ba41800377dfa7fc1396d9">More...</a><br /></td></tr>
<tr class="separator:ga4dcac2c8c0ba41800377dfa7fc1396d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1f5fa0f1ce0785ae11f789eb69a2f4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga0e1f5fa0f1ce0785ae11f789eb69a2f4">operator&quot;&quot;_Hz</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga0e1f5fa0f1ce0785ae11f789eb69a2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a hertz unit of Frequency.  <a href="group__Unitsymbols.html#ga0e1f5fa0f1ce0785ae11f789eb69a2f4">More...</a><br /></td></tr>
<tr class="separator:ga0e1f5fa0f1ce0785ae11f789eb69a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b528013add62057edbddb11c79c8a36"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga6b528013add62057edbddb11c79c8a36">operator&quot;&quot;_Hz</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga6b528013add62057edbddb11c79c8a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a hertz unit of Frequency.  <a href="group__Unitsymbols.html#ga6b528013add62057edbddb11c79c8a36">More...</a><br /></td></tr>
<tr class="separator:ga6b528013add62057edbddb11c79c8a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad274f795522e2b024bac4ce6b4a1636d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad274f795522e2b024bac4ce6b4a1636d">operator&quot;&quot;_Nm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gad274f795522e2b024bac4ce6b4a1636d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for newton-meter unit of torque.  <a href="group__Unitsymbols.html#gad274f795522e2b024bac4ce6b4a1636d">More...</a><br /></td></tr>
<tr class="separator:gad274f795522e2b024bac4ce6b4a1636d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44dd10192e584c1ff4094a3b1035732"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaf44dd10192e584c1ff4094a3b1035732">operator&quot;&quot;_Nm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaf44dd10192e584c1ff4094a3b1035732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for newton-meter unit of torque.  <a href="group__Unitsymbols.html#gaf44dd10192e584c1ff4094a3b1035732">More...</a><br /></td></tr>
<tr class="separator:gaf44dd10192e584c1ff4094a3b1035732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e4af46280404d4cb71047dd34d67097"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4e4af46280404d4cb71047dd34d67097">operator&quot;&quot;_Ns</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga4e4af46280404d4cb71047dd34d67097"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton second of impulse.  <a href="group__Unitsymbols.html#ga4e4af46280404d4cb71047dd34d67097">More...</a><br /></td></tr>
<tr class="separator:ga4e4af46280404d4cb71047dd34d67097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4efb2b2f16bc784b7d57ca46ed3f6a13"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4efb2b2f16bc784b7d57ca46ed3f6a13">operator&quot;&quot;_Ns</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga4efb2b2f16bc784b7d57ca46ed3f6a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton second of impulse.  <a href="group__Unitsymbols.html#ga4efb2b2f16bc784b7d57ca46ed3f6a13">More...</a><br /></td></tr>
<tr class="separator:ga4efb2b2f16bc784b7d57ca46ed3f6a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948148b4234cf1f7030a336d64868129"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga948148b4234cf1f7030a336d64868129">operator&quot;&quot;_kgpm2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga948148b4234cf1f7030a336d64868129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilogram per square meter. <br /></td></tr>
<tr class="separator:ga948148b4234cf1f7030a336d64868129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb329e2432dd4b9d459faf7a89501847"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gacb329e2432dd4b9d459faf7a89501847">operator&quot;&quot;_kgpm2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gacb329e2432dd4b9d459faf7a89501847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilogram per square meter. <br /></td></tr>
<tr class="separator:gacb329e2432dd4b9d459faf7a89501847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca4e4146c562c10b7b630bb5e84f791"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga9ca4e4146c562c10b7b630bb5e84f791">operator&quot;&quot;_rpm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga9ca4e4146c562c10b7b630bb5e84f791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for revolutions per minute.  <a href="group__Unitsymbols.html#ga9ca4e4146c562c10b7b630bb5e84f791">More...</a><br /></td></tr>
<tr class="separator:ga9ca4e4146c562c10b7b630bb5e84f791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fba9a464320ef807425a9696f4af414"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga7fba9a464320ef807425a9696f4af414">operator&quot;&quot;_rpm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga7fba9a464320ef807425a9696f4af414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for revolutions per minute.  <a href="group__Unitsymbols.html#ga7fba9a464320ef807425a9696f4af414">More...</a><br /></td></tr>
<tr class="separator:ga7fba9a464320ef807425a9696f4af414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9c2dd1eed20474efacf71573727d31"><td class="memItemLeft" align="right" valign="top"><a id="aac9c2dd1eed20474efacf71573727d31"></a>
constexpr <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aac9c2dd1eed20474efacf71573727d31">StripUnit</a> (const <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> value)</td></tr>
<tr class="memdesc:aac9c2dd1eed20474efacf71573727d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the units off of the given value. <br /></td></tr>
<tr class="separator:aac9c2dd1eed20474efacf71573727d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5351f2762c5c98b723679795e0a79287"><td class="memItemLeft" align="right" valign="top"><a id="a5351f2762c5c98b723679795e0a79287"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5351f2762c5c98b723679795e0a79287"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5351f2762c5c98b723679795e0a79287">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a5351f2762c5c98b723679795e0a79287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a5351f2762c5c98b723679795e0a79287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d92fceef8d7757ae713bd166391c21"><td class="memTemplParams" colspan="2"><a id="ab0d92fceef8d7757ae713bd166391c21"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab0d92fceef8d7757ae713bd166391c21"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab0d92fceef8d7757ae713bd166391c21">operator==</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab0d92fceef8d7757ae713bd166391c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:ab0d92fceef8d7757ae713bd166391c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16f08723028c63f043c1ad42891b11"><td class="memTemplParams" colspan="2"><a id="a0e16f08723028c63f043c1ad42891b11"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0e16f08723028c63f043c1ad42891b11"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0e16f08723028c63f043c1ad42891b11">operator!=</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0e16f08723028c63f043c1ad42891b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a0e16f08723028c63f043c1ad42891b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e36a6e89835f4d0de7cc4bbc30004f"><td class="memTemplParams" colspan="2"><a id="a56e36a6e89835f4d0de7cc4bbc30004f"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a56e36a6e89835f4d0de7cc4bbc30004f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T, decltype(+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a56e36a6e89835f4d0de7cc4bbc30004f">operator+</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; v) noexcept</td></tr>
<tr class="memdesc:a56e36a6e89835f4d0de7cc4bbc30004f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus operator. <br /></td></tr>
<tr class="separator:a56e36a6e89835f4d0de7cc4bbc30004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581f6521190fcbbfc1aa0813a6f33c04"><td class="memTemplParams" colspan="2"><a id="a581f6521190fcbbfc1aa0813a6f33c04"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a581f6521190fcbbfc1aa0813a6f33c04"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T, decltype(-T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a581f6521190fcbbfc1aa0813a6f33c04">operator-</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; v) noexcept</td></tr>
<tr class="memdesc:a581f6521190fcbbfc1aa0813a6f33c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation operator. <br /></td></tr>
<tr class="separator:a581f6521190fcbbfc1aa0813a6f33c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85453187a044f3d22a4c9ffea440eeac"><td class="memTemplParams" colspan="2"><a id="a85453187a044f3d22a4c9ffea440eeac"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a85453187a044f3d22a4c9ffea440eeac"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T, decltype(T{}+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a85453187a044f3d22a4c9ffea440eeac">operator+=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a85453187a044f3d22a4c9ffea440eeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the left hand side value by the right hand side value. <br /></td></tr>
<tr class="separator:a85453187a044f3d22a4c9ffea440eeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92dcbdea02307ed29e5dc13ea59f7655"><td class="memTemplParams" colspan="2"><a id="a92dcbdea02307ed29e5dc13ea59f7655"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a92dcbdea02307ed29e5dc13ea59f7655"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T, decltype(T{} - T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a92dcbdea02307ed29e5dc13ea59f7655">operator-=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a92dcbdea02307ed29e5dc13ea59f7655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the left hand side value by the right hand side value. <br /></td></tr>
<tr class="separator:a92dcbdea02307ed29e5dc13ea59f7655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc7b8a4526dd9380a689345a1dff9d4"><td class="memTemplParams" colspan="2"><a id="aadc7b8a4526dd9380a689345a1dff9d4"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aadc7b8a4526dd9380a689345a1dff9d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T, decltype(T{}+T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aadc7b8a4526dd9380a689345a1dff9d4">operator+</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:aadc7b8a4526dd9380a689345a1dff9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors component-wise. <br /></td></tr>
<tr class="separator:aadc7b8a4526dd9380a689345a1dff9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d04501374b86e6de10706672bdc38d"><td class="memTemplParams" colspan="2"><a id="a75d04501374b86e6de10706672bdc38d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a75d04501374b86e6de10706672bdc38d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T, decltype(T{} - T{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a75d04501374b86e6de10706672bdc38d">operator-</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a75d04501374b86e6de10706672bdc38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two vectors component-wise. <br /></td></tr>
<tr class="separator:a75d04501374b86e6de10706672bdc38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af372c516420203fe11aa71d881d376e6"><td class="memTemplParams" colspan="2"><a id="af372c516420203fe11aa71d881d376e6"></a>
template&lt;typename T1 , typename T2 , std::size_t N&gt; </td></tr>
<tr class="memitem:af372c516420203fe11aa71d881d376e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T1, decltype(T1{} *T2{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af372c516420203fe11aa71d881d376e6">operator*=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;lhs, const T2 rhs) noexcept</td></tr>
<tr class="memdesc:af372c516420203fe11aa71d881d376e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator. <br /></td></tr>
<tr class="separator:af372c516420203fe11aa71d881d376e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e53e0fc25f63401b26f557d4f0dc74"><td class="memTemplParams" colspan="2"><a id="a86e53e0fc25f63401b26f557d4f0dc74"></a>
template&lt;typename T1 , typename T2 , std::size_t N&gt; </td></tr>
<tr class="memitem:a86e53e0fc25f63401b26f557d4f0dc74"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same&lt; T1, decltype(T1{}/T2{})&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a86e53e0fc25f63401b26f557d4f0dc74">operator/=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;lhs, const T2 rhs) noexcept</td></tr>
<tr class="memdesc:a86e53e0fc25f63401b26f557d4f0dc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator. <br /></td></tr>
<tr class="separator:a86e53e0fc25f63401b26f557d4f0dc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26c32a67232c258f6792be57799a485"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, std::size_t C, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:ab26c32a67232c258f6792be57799a485"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, C &gt;, A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab26c32a67232c258f6792be57799a485">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, B &gt;, A &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, C &gt;, B &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab26c32a67232c258f6792be57799a485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the matrix product of the two given vector of vectors (matrices).  <a href="namespaceplayrho.html#ab26c32a67232c258f6792be57799a485">More...</a><br /></td></tr>
<tr class="separator:ab26c32a67232c258f6792be57799a485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026460fcdfec17743564ddb912641b32"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a026460fcdfec17743564ddb912641b32"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T1 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a026460fcdfec17743564ddb912641b32">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, B &gt;, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a026460fcdfec17743564ddb912641b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an A-element vector by a A-by-B vector of vectors.  <a href="namespaceplayrho.html#a026460fcdfec17743564ddb912641b32">More...</a><br /></td></tr>
<tr class="separator:a026460fcdfec17743564ddb912641b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5954c938ca0d2ec534a155f7c1ea692d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a5954c938ca0d2ec534a155f7c1ea692d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5954c938ca0d2ec534a155f7c1ea692d">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt;, B &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5954c938ca0d2ec534a155f7c1ea692d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a B-by-A vector of vectors by an A-element vector.  <a href="namespaceplayrho.html#a5954c938ca0d2ec534a155f7c1ea692d">More...</a><br /></td></tr>
<tr class="separator:a5954c938ca0d2ec534a155f7c1ea692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83592354f1ddb5b4c4a578b758e3b6f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:ab83592354f1ddb5b4c4a578b758e3b6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T1 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab83592354f1ddb5b4c4a578b758e3b6f">operator*</a> (const T1 s, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, N &gt; a) noexcept</td></tr>
<tr class="memdesc:ab83592354f1ddb5b4c4a578b758e3b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for non-vector times vector.  <a href="namespaceplayrho.html#ab83592354f1ddb5b4c4a578b758e3b6f">More...</a><br /></td></tr>
<tr class="separator:ab83592354f1ddb5b4c4a578b758e3b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd667ff0c1d11b44e9ad19b06db6713e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:acd667ff0c1d11b44e9ad19b06db6713e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acd667ff0c1d11b44e9ad19b06db6713e">operator*</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; a, const T2 s) noexcept</td></tr>
<tr class="memdesc:acd667ff0c1d11b44e9ad19b06db6713e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for vector times non-vector.  <a href="namespaceplayrho.html#acd667ff0c1d11b44e9ad19b06db6713e">More...</a><br /></td></tr>
<tr class="separator:acd667ff0c1d11b44e9ad19b06db6713e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab846bf628e71b3aeea2fc26d282143eb"><td class="memTemplParams" colspan="2"><a id="ab846bf628e71b3aeea2fc26d282143eb"></a>
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} / T2{})&gt; </td></tr>
<tr class="memitem:ab846bf628e71b3aeea2fc26d282143eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsDivisable.html">IsDivisable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab846bf628e71b3aeea2fc26d282143eb">operator/</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; a, const T2 s) noexcept</td></tr>
<tr class="memdesc:ab846bf628e71b3aeea2fc26d282143eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:ab846bf628e71b3aeea2fc26d282143eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10d9373a7aa5e3492fee0877900f738"><td class="memTemplParams" colspan="2"><a id="aa10d9373a7aa5e3492fee0877900f738"></a>
template&lt;std::size_t I, std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:aa10d9373a7aa5e3492fee0877900f738"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:aa10d9373a7aa5e3492fee0877900f738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified element of the given collection. <br /></td></tr>
<tr class="separator:aa10d9373a7aa5e3492fee0877900f738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a27488878deb0db4face63ec9749b1"><td class="memTemplParams" colspan="2"><a id="a32a27488878deb0db4face63ec9749b1"></a>
template&lt;std::size_t I, std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a32a27488878deb0db4face63ec9749b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a32a27488878deb0db4face63ec9749b1">get</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a32a27488878deb0db4face63ec9749b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified element of the given collection. <br /></td></tr>
<tr class="separator:a32a27488878deb0db4face63ec9749b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda91572806860fa512fff0f01a001b"><td class="memTemplParams" colspan="2"><a id="a6bda91572806860fa512fff0f01a001b"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6bda91572806860fa512fff0f01a001b"><td class="memTemplItemLeft" align="right" valign="top">::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6bda91572806860fa512fff0f01a001b">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value)</td></tr>
<tr class="memdesc:a6bda91572806860fa512fff0f01a001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator. <br /></td></tr>
<tr class="separator:a6bda91572806860fa512fff0f01a001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1095a7a1708bef4b32bc0f6cc44a58f2"><td class="memItemLeft" align="right" valign="top"><a id="a1095a7a1708bef4b32bc0f6cc44a58f2"></a>
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1095a7a1708bef4b32bc0f6cc44a58f2">GetVec2</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt; value)</td></tr>
<tr class="memdesc:a1095a7a1708bef4b32bc0f6cc44a58f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the given value as a 2-element vector of reals (<code>Vec2</code>). <br /></td></tr>
<tr class="separator:a1095a7a1708bef4b32bc0f6cc44a58f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="memTemplParams" colspan="2"><a id="ab698eb521c2d14d3d88ee3ac4cacd7c6"></a>
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab698eb521c2d14d3d88ee3ac4cacd7c6">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; TYPE &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given vector contains finite coordinates. <br /></td></tr>
<tr class="separator:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904477c2aa4c83f49b1c55f393bd79d2"><td class="memItemLeft" align="right" valign="top"><a id="a904477c2aa4c83f49b1c55f393bd79d2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a904477c2aa4c83f49b1c55f393bd79d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a904477c2aa4c83f49b1c55f393bd79d2">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Velocity.html">d2::Velocity</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a904477c2aa4c83f49b1c55f393bd79d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a904477c2aa4c83f49b1c55f393bd79d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ad5413c876b34dcf8430c045986cc"><td class="memItemLeft" align="right" valign="top"><a id="af43ad5413c876b34dcf8430c045986cc"></a>
<a class="el" href="structplayrho_1_1Version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af43ad5413c876b34dcf8430c045986cc">GetVersion</a> () noexcept</td></tr>
<tr class="memdesc:af43ad5413c876b34dcf8430c045986cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the version information of the library. <br /></td></tr>
<tr class="separator:af43ad5413c876b34dcf8430c045986cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e36c723d641ea2e8dad6e8653f6ffd"><td class="memItemLeft" align="right" valign="top"><a id="a66e36c723d641ea2e8dad6e8653f6ffd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a66e36c723d641ea2e8dad6e8653f6ffd">GetBuildDetails</a> () noexcept</td></tr>
<tr class="memdesc:a66e36c723d641ea2e8dad6e8653f6ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the build details of the library. <br /></td></tr>
<tr class="separator:a66e36c723d641ea2e8dad6e8653f6ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b564ef69823dc4c3faaa8cbc3268040"><td class="memItemLeft" align="right" valign="top"><a id="a7b564ef69823dc4c3faaa8cbc3268040"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7b564ef69823dc4c3faaa8cbc3268040">operator==</a> (<a class="el" href="structplayrho_1_1Version.html">Version</a> lhs, <a class="el" href="structplayrho_1_1Version.html">Version</a> rhs)</td></tr>
<tr class="memdesc:a7b564ef69823dc4c3faaa8cbc3268040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a7b564ef69823dc4c3faaa8cbc3268040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4bec997d1e880aac48a69ca41c656c"><td class="memItemLeft" align="right" valign="top"><a id="a0a4bec997d1e880aac48a69ca41c656c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0a4bec997d1e880aac48a69ca41c656c">operator!=</a> (<a class="el" href="structplayrho_1_1Version.html">Version</a> lhs, <a class="el" href="structplayrho_1_1Version.html">Version</a> rhs)</td></tr>
<tr class="memdesc:a0a4bec997d1e880aac48a69ca41c656c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a0a4bec997d1e880aac48a69ca41c656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7404128f6225cf6915219bb784c7843"><td class="memItemLeft" align="right" valign="top"><a id="ab7404128f6225cf6915219bb784c7843"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab7404128f6225cf6915219bb784c7843"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab7404128f6225cf6915219bb784c7843">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ab7404128f6225cf6915219bb784c7843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:ab7404128f6225cf6915219bb784c7843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2dcc5aeb221351e51ad965e9de893"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893">IsSpeedable</a> (<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a> type)</td></tr>
<tr class="memdesc:a76e2dcc5aeb221351e51ad965e9de893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is "speedable".  <a href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893">More...</a><br /></td></tr>
<tr class="separator:a76e2dcc5aeb221351e51ad965e9de893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6514752c0838613cfaf76ea7e03581cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd">IsAccelerable</a> (<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a> type)</td></tr>
<tr class="memdesc:a6514752c0838613cfaf76ea7e03581cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is "accelerable".  <a href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd">More...</a><br /></td></tr>
<tr class="separator:a6514752c0838613cfaf76ea7e03581cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf6573afe5f3fb0803faa353dc9c65"><td class="memItemLeft" align="right" valign="top"><a id="aacaf6573afe5f3fb0803faa353dc9c65"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aacaf6573afe5f3fb0803faa353dc9c65">GetRegConstraintSolverConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:aacaf6573afe5f3fb0803faa353dc9c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the regular phase constraint solver configuration for the given step configuration. <br /></td></tr>
<tr class="separator:aacaf6573afe5f3fb0803faa353dc9c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8daa84d36ac948934ee05eb4cb242"><td class="memItemLeft" align="right" valign="top"><a id="afdb8daa84d36ac948934ee05eb4cb242"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afdb8daa84d36ac948934ee05eb4cb242">GetToiConstraintSolverConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:afdb8daa84d36ac948934ee05eb4cb242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the TOI phase constraint solver configuration for the given step configuration. <br /></td></tr>
<tr class="separator:afdb8daa84d36ac948934ee05eb4cb242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081dbfc95d4d3139eb2817a1f11a5af3"><td class="memItemLeft" align="right" valign="top"><a id="a081dbfc95d4d3139eb2817a1f11a5af3"></a>
constexpr <a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a081dbfc95d4d3139eb2817a1f11a5af3">GetDefaultPositionSolverConf</a> () noexcept</td></tr>
<tr class="memdesc:a081dbfc95d4d3139eb2817a1f11a5af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default position solver configuration. <br /></td></tr>
<tr class="separator:a081dbfc95d4d3139eb2817a1f11a5af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b5137ea90045d15dfb2279d5773b46"><td class="memItemLeft" align="right" valign="top"><a id="a56b5137ea90045d15dfb2279d5773b46"></a>
constexpr <a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a56b5137ea90045d15dfb2279d5773b46">GetDefaultToiPositionSolverConf</a> () noexcept</td></tr>
<tr class="memdesc:a56b5137ea90045d15dfb2279d5773b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default TOI position solver configuration. <br /></td></tr>
<tr class="separator:a56b5137ea90045d15dfb2279d5773b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d46e6e45df1f7049decee120ce9922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a50d46e6e45df1f7049decee120ce9922">MixFriction</a> (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> friction1, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> friction2)</td></tr>
<tr class="memdesc:a50d46e6e45df1f7049decee120ce9922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes friction.  <a href="namespaceplayrho.html#a50d46e6e45df1f7049decee120ce9922">More...</a><br /></td></tr>
<tr class="separator:a50d46e6e45df1f7049decee120ce9922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd2574637d4c8869ae345d3975829cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abdd2574637d4c8869ae345d3975829cc">MixRestitution</a> (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> restitution1, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> restitution2) noexcept</td></tr>
<tr class="memdesc:abdd2574637d4c8869ae345d3975829cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes restitution.  <a href="namespaceplayrho.html#abdd2574637d4c8869ae345d3975829cc">More...</a><br /></td></tr>
<tr class="separator:abdd2574637d4c8869ae345d3975829cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42b14180314ff41872c38c5596970c"><td class="memItemLeft" align="right" valign="top"><a id="adc42b14180314ff41872c38c5596970c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc42b14180314ff41872c38c5596970c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adc42b14180314ff41872c38c5596970c">IsValid</a> (const <a class="el" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:adc42b14180314ff41872c38c5596970c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:adc42b14180314ff41872c38c5596970c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0addcd9e78acfcc5f23418814f2a8f57"><td class="memItemLeft" align="right" valign="top"><a id="a0addcd9e78acfcc5f23418814f2a8f57"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0addcd9e78acfcc5f23418814f2a8f57">operator==</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a0addcd9e78acfcc5f23418814f2a8f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a0addcd9e78acfcc5f23418814f2a8f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae970f7a9e7fa198ddadce868c1116325"><td class="memItemLeft" align="right" valign="top"><a id="ae970f7a9e7fa198ddadce868c1116325"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae970f7a9e7fa198ddadce868c1116325">operator!=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:ae970f7a9e7fa198ddadce868c1116325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ae970f7a9e7fa198ddadce868c1116325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80c31195a04b4af5891934d0ed1ed3c"><td class="memItemLeft" align="right" valign="top"><a id="af80c31195a04b4af5891934d0ed1ed3c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af80c31195a04b4af5891934d0ed1ed3c">operator&lt;</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:af80c31195a04b4af5891934d0ed1ed3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:af80c31195a04b4af5891934d0ed1ed3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225f691c1b9ee3969221ae49170ba178"><td class="memItemLeft" align="right" valign="top"><a id="a225f691c1b9ee3969221ae49170ba178"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a225f691c1b9ee3969221ae49170ba178">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a225f691c1b9ee3969221ae49170ba178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a225f691c1b9ee3969221ae49170ba178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef072ea2c5a69df2050c1a1557206ef"><td class="memItemLeft" align="right" valign="top"><a id="a7ef072ea2c5a69df2050c1a1557206ef"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7ef072ea2c5a69df2050c1a1557206ef">operator&gt;</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a7ef072ea2c5a69df2050c1a1557206ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:a7ef072ea2c5a69df2050c1a1557206ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f2a5fe81c028b473be52b47b7c7e9"><td class="memItemLeft" align="right" valign="top"><a id="ae75f2a5fe81c028b473be52b47b7c7e9"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae75f2a5fe81c028b473be52b47b7c7e9">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:ae75f2a5fe81c028b473be52b47b7c7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:ae75f2a5fe81c028b473be52b47b7c7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecc5b25e8e89a47a552caf672bd69c"><td class="memItemLeft" align="right" valign="top"><a id="a9cecc5b25e8e89a47a552caf672bd69c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9cecc5b25e8e89a47a552caf672bd69c">operator==</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> lhs, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9cecc5b25e8e89a47a552caf672bd69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a9cecc5b25e8e89a47a552caf672bd69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71806508440416ef208f51580a6c50c"><td class="memItemLeft" align="right" valign="top"><a id="ab71806508440416ef208f51580a6c50c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab71806508440416ef208f51580a6c50c">operator!=</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> lhs, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> rhs) noexcept</td></tr>
<tr class="memdesc:ab71806508440416ef208f51580a6c50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ab71806508440416ef208f51580a6c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223329721a8138f316898ed9a4877250"><td class="memItemLeft" align="right" valign="top"><a id="a223329721a8138f316898ed9a4877250"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a223329721a8138f316898ed9a4877250">ShouldCollide</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> filterA, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> filterB) noexcept</td></tr>
<tr class="memdesc:a223329721a8138f316898ed9a4877250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether collision processing should be performed. <br /></td></tr>
<tr class="separator:a223329721a8138f316898ed9a4877250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39223a08030d99fb1c58ca8635e8cc3"><td class="memItemLeft" align="right" valign="top"><a id="af39223a08030d99fb1c58ca8635e8cc3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af39223a08030d99fb1c58ca8635e8cc3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af39223a08030d99fb1c58ca8635e8cc3">IsValid</a> (const <a class="el" href="namespaceplayrho.html#aeb0ae1f76104ef8214134a5be96027f6">FixtureID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:af39223a08030d99fb1c58ca8635e8cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:af39223a08030d99fb1c58ca8635e8cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7144be2e84f00033cbbadfae783092ed"><td class="memItemLeft" align="right" valign="top"><a id="a7144be2e84f00033cbbadfae783092ed"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7144be2e84f00033cbbadfae783092ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7144be2e84f00033cbbadfae783092ed">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a7144be2e84f00033cbbadfae783092ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a7144be2e84f00033cbbadfae783092ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5227d01d6f7c75ac2399c3da7b5572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9f5227d01d6f7c75ac2399c3da7b5572">GetMovementConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a9f5227d01d6f7c75ac2399c3da7b5572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the movement configuration from the given value.  <a href="namespaceplayrho.html#a9f5227d01d6f7c75ac2399c3da7b5572">More...</a><br /></td></tr>
<tr class="separator:a9f5227d01d6f7c75ac2399c3da7b5572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d21c386ca6d39d5cc35cbad350a8c9"><td class="memItemLeft" align="right" valign="top"><a id="a05d21c386ca6d39d5cc35cbad350a8c9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a05d21c386ca6d39d5cc35cbad350a8c9">IsMaxTranslationWithinTolerance</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a05d21c386ca6d39d5cc35cbad350a8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the maximum translation is within tolerance. <br /></td></tr>
<tr class="separator:a05d21c386ca6d39d5cc35cbad350a8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f543b42eadf60ef9e730edc77912c"><td class="memItemLeft" align="right" valign="top"><a id="a396f543b42eadf60ef9e730edc77912c"></a>
<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a396f543b42eadf60ef9e730edc77912c">GetMaxRegLinearCorrection</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a396f543b42eadf60ef9e730edc77912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum regular linear correction from the given value. <br /></td></tr>
<tr class="separator:a396f543b42eadf60ef9e730edc77912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3129f24959327f2ae255de4d0b2badba"><td class="memItemLeft" align="right" valign="top"><a id="a3129f24959327f2ae255de4d0b2badba"></a>
<a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3129f24959327f2ae255de4d0b2badba">Update</a> (<a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a> &amp;lhs, const <a class="el" href="structplayrho_1_1IslandStats.html">IslandStats</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3129f24959327f2ae255de4d0b2badba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates regular-phase per-step statistics with island statistics. <br /></td></tr>
<tr class="separator:a3129f24959327f2ae255de4d0b2badba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6fb9d11a6fadb62b0e68aee9797059ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">InvalidIndexPair</a></td></tr>
<tr class="memdesc:a6fb9d11a6fadb62b0e68aee9797059ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid index-pair value.  <a href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">More...</a><br /></td></tr>
<tr class="separator:a6fb9d11a6fadb62b0e68aee9797059ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6388dedf49acce87859ad2e9bd3e2cc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae6388dedf49acce87859ad2e9bd3e2cc">InvalidIndexPair3</a></td></tr>
<tr class="memdesc:ae6388dedf49acce87859ad2e9bd3e2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid array of three index-pair elements.  <a href="namespaceplayrho.html#ae6388dedf49acce87859ad2e9bd3e2cc">More...</a><br /></td></tr>
<tr class="separator:ae6388dedf49acce87859ad2e9bd3e2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe0bdbb0ea9c449b7504f7c75840993"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(3.14159265358979323846264338327950288)</td></tr>
<tr class="memdesc:a3fe0bdbb0ea9c449b7504f7c75840993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pi.  <a href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">More...</a><br /></td></tr>
<tr class="separator:a3fe0bdbb0ea9c449b7504f7c75840993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1bd392cbafcb91d60633c893ff0742"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aae1bd392cbafcb91d60633c893ff0742">SquareRootTwo</a></td></tr>
<tr class="memdesc:aae1bd392cbafcb91d60633c893ff0742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of two.  <a href="namespaceplayrho.html#aae1bd392cbafcb91d60633c893ff0742">More...</a><br /></td></tr>
<tr class="separator:aae1bd392cbafcb91d60633c893ff0742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0367ca8edd23b32c868e3fe5f79082ef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga0367ca8edd23b32c868e3fe5f79082ef">Centi</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e-2)</td></tr>
<tr class="memdesc:ga0367ca8edd23b32c868e3fe5f79082ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centi- (1 x 10^-2).  <a href="group__DecimalUnitPrefices.html#ga0367ca8edd23b32c868e3fe5f79082ef">More...</a><br /></td></tr>
<tr class="separator:ga0367ca8edd23b32c868e3fe5f79082ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a49a7e54c1b478f5b1cc882aa55f2d3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga5a49a7e54c1b478f5b1cc882aa55f2d3">Deci</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e-1)</td></tr>
<tr class="memdesc:ga5a49a7e54c1b478f5b1cc882aa55f2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deci- (1 x 10^-1).  <a href="group__DecimalUnitPrefices.html#ga5a49a7e54c1b478f5b1cc882aa55f2d3">More...</a><br /></td></tr>
<tr class="separator:ga5a49a7e54c1b478f5b1cc882aa55f2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae537180a6f4ceb3a3192ee623fc2c8bc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#gae537180a6f4ceb3a3192ee623fc2c8bc">Kilo</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e3)</td></tr>
<tr class="memdesc:gae537180a6f4ceb3a3192ee623fc2c8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilo- (1 x 10^3).  <a href="group__DecimalUnitPrefices.html#gae537180a6f4ceb3a3192ee623fc2c8bc">More...</a><br /></td></tr>
<tr class="separator:gae537180a6f4ceb3a3192ee623fc2c8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b2132b6101f0d7f6b3658147025168"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#gad7b2132b6101f0d7f6b3658147025168">Mega</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e6)</td></tr>
<tr class="memdesc:gad7b2132b6101f0d7f6b3658147025168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mega- (1 x 10^6).  <a href="group__DecimalUnitPrefices.html#gad7b2132b6101f0d7f6b3658147025168">More...</a><br /></td></tr>
<tr class="separator:gad7b2132b6101f0d7f6b3658147025168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ca2124fd143e2433bb2f409dc83f92"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga66ca2124fd143e2433bb2f409dc83f92">Giga</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e9)</td></tr>
<tr class="memdesc:ga66ca2124fd143e2433bb2f409dc83f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Giga- (1 x 10^9).  <a href="group__DecimalUnitPrefices.html#ga66ca2124fd143e2433bb2f409dc83f92">More...</a><br /></td></tr>
<tr class="separator:ga66ca2124fd143e2433bb2f409dc83f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30f732f080ece0b4e695da15e9da2a4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#gaf30f732f080ece0b4e695da15e9da2a4">Tera</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e12)</td></tr>
<tr class="memdesc:gaf30f732f080ece0b4e695da15e9da2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tera- (1 x 10^12).  <a href="group__DecimalUnitPrefices.html#gaf30f732f080ece0b4e695da15e9da2a4">More...</a><br /></td></tr>
<tr class="separator:gaf30f732f080ece0b4e695da15e9da2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590efc6f9c2013056da85de7ab4e84ae"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga590efc6f9c2013056da85de7ab4e84ae">Peta</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e15)</td></tr>
<tr class="memdesc:ga590efc6f9c2013056da85de7ab4e84ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peta- (1 x 10^15).  <a href="group__DecimalUnitPrefices.html#ga590efc6f9c2013056da85de7ab4e84ae">More...</a><br /></td></tr>
<tr class="separator:ga590efc6f9c2013056da85de7ab4e84ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57179cfbd588c3d24609ad449a94bb0a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga57179cfbd588c3d24609ad449a94bb0a">Yotta</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e24)</td></tr>
<tr class="memdesc:ga57179cfbd588c3d24609ad449a94bb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yotta- (1 x 10^24).  <a href="group__DecimalUnitPrefices.html#ga57179cfbd588c3d24609ad449a94bb0a">More...</a><br /></td></tr>
<tr class="separator:ga57179cfbd588c3d24609ad449a94bb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95591102a273a4d301f3f795d463b9ba"><td class="memItemLeft" align="right" valign="top"><a id="a95591102a273a4d301f3f795d463b9ba"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a95591102a273a4d301f3f795d463b9ba">MaxSimplexEdges</a> = std::uint8_t{3}</td></tr>
<tr class="memdesc:a95591102a273a4d301f3f795d463b9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of supportable edges in a simplex. <br /></td></tr>
<tr class="separator:a95591102a273a4d301f3f795d463b9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33623a59b7c701aead6d06e88dc2cc6"><td class="memItemLeft" align="right" valign="top"><a id="af33623a59b7c701aead6d06e88dc2cc6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af33623a59b7c701aead6d06e88dc2cc6">MaxChildCount</a> = std::numeric_limits&lt;std::uint32_t&gt;::max() &gt;&gt; 6</td></tr>
<tr class="memdesc:af33623a59b7c701aead6d06e88dc2cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max child count. <br /></td></tr>
<tr class="separator:af33623a59b7c701aead6d06e88dc2cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527c4658d275e6c04ba4b4c9f28d688b"><td class="memItemLeft" align="right" valign="top"><a id="a527c4658d275e6c04ba4b4c9f28d688b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a527c4658d275e6c04ba4b4c9f28d688b">MaxFloat</a> = std::numeric_limits&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::max()</td></tr>
<tr class="memdesc:a527c4658d275e6c04ba4b4c9f28d688b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum float value. <br /></td></tr>
<tr class="separator:a527c4658d275e6c04ba4b4c9f28d688b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae670387c8f37f8812082b1838e18863"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aae670387c8f37f8812082b1838e18863">MaxManifoldPoints</a> = std::uint8_t{2}</td></tr>
<tr class="memdesc:aae670387c8f37f8812082b1838e18863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum manifold points. This is the maximum number of contact points between two convex shapes. Do not change this value.  <a href="namespaceplayrho.html#aae670387c8f37f8812082b1838e18863">More...</a><br /></td></tr>
<tr class="separator:aae670387c8f37f8812082b1838e18863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0774f630ff2e5b9ed9e5f322700d44e4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">MaxShapeVertices</a> = std::uint8_t{254}</td></tr>
<tr class="memdesc:a0774f630ff2e5b9ed9e5f322700d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of vertices for any shape type.  <a href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">More...</a><br /></td></tr>
<tr class="separator:a0774f630ff2e5b9ed9e5f322700d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c511e18a6b72260126cf763c1cd8df"><td class="memItemLeft" align="right" valign="top"><a id="a49c511e18a6b72260126cf763c1cd8df"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">InvalidVertex</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&gt;(-1)</td></tr>
<tr class="memdesc:a49c511e18a6b72260126cf763c1cd8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid vertex index. <br /></td></tr>
<tr class="separator:a49c511e18a6b72260126cf763c1cd8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91e53ba44755653e34147d39695a0a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad91e53ba44755653e34147d39695a0a1">DefaultLinearSlop</a> = <a class="el" href="structplayrho_1_1detail_1_1Defaults.html">detail::Defaults</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::GetLinearSlop()</td></tr>
<tr class="memdesc:ad91e53ba44755653e34147d39695a0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default linear slop.  <a href="namespaceplayrho.html#ad91e53ba44755653e34147d39695a0a1">More...</a><br /></td></tr>
<tr class="separator:ad91e53ba44755653e34147d39695a0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174cfa632eb92c15bc2e48e7d09d216a"><td class="memItemLeft" align="right" valign="top"><a id="a174cfa632eb92c15bc2e48e7d09d216a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a174cfa632eb92c15bc2e48e7d09d216a">DefaultMinVertexRadius</a> = <a class="el" href="namespaceplayrho.html#ad91e53ba44755653e34147d39695a0a1">DefaultLinearSlop</a> * <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{2}</td></tr>
<tr class="memdesc:a174cfa632eb92c15bc2e48e7d09d216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default minimum vertex radius. <br /></td></tr>
<tr class="separator:a174cfa632eb92c15bc2e48e7d09d216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beadf6067bdf66f48ee9b94c337d252"><td class="memItemLeft" align="right" valign="top"><a id="a7beadf6067bdf66f48ee9b94c337d252"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7beadf6067bdf66f48ee9b94c337d252">DefaultMaxVertexRadius</a> = <a class="el" href="structplayrho_1_1detail_1_1Defaults.html">detail::Defaults</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::GetMaxVertexRadius()</td></tr>
<tr class="memdesc:a7beadf6067bdf66f48ee9b94c337d252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum vertex radius. <br /></td></tr>
<tr class="separator:a7beadf6067bdf66f48ee9b94c337d252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd06178e859667c8f65b26c4e91972e"><td class="memItemLeft" align="right" valign="top"><a id="a3dd06178e859667c8f65b26c4e91972e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3dd06178e859667c8f65b26c4e91972e">DefaultAabbExtension</a> = <a class="el" href="namespaceplayrho.html#ad91e53ba44755653e34147d39695a0a1">DefaultLinearSlop</a> * <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{20}</td></tr>
<tr class="memdesc:a3dd06178e859667c8f65b26c4e91972e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default AABB extension amount. <br /></td></tr>
<tr class="separator:a3dd06178e859667c8f65b26c4e91972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2898b34e4bf5fe5af48939ec34e48f6"><td class="memItemLeft" align="right" valign="top"><a id="ab2898b34e4bf5fe5af48939ec34e48f6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab2898b34e4bf5fe5af48939ec34e48f6">DefaultDistanceMultiplier</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{2}</td></tr>
<tr class="memdesc:ab2898b34e4bf5fe5af48939ec34e48f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default distance multiplier. <br /></td></tr>
<tr class="separator:ab2898b34e4bf5fe5af48939ec34e48f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfccbc3cd8cc0bb78701f62e041acdba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adfccbc3cd8cc0bb78701f62e041acdba">DefaultAngularSlop</a> = (<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2_rad) / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{180}</td></tr>
<tr class="memdesc:adfccbc3cd8cc0bb78701f62e041acdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default angular slop.  <a href="namespaceplayrho.html#adfccbc3cd8cc0bb78701f62e041acdba">More...</a><br /></td></tr>
<tr class="separator:adfccbc3cd8cc0bb78701f62e041acdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d2cfbedb9200e2ed973eb18cc3b23b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa7d2cfbedb9200e2ed973eb18cc3b23b">DefaultMaxLinearCorrection</a> = 0.2_m</td></tr>
<tr class="memdesc:aa7d2cfbedb9200e2ed973eb18cc3b23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum linear correction.  <a href="namespaceplayrho.html#aa7d2cfbedb9200e2ed973eb18cc3b23b">More...</a><br /></td></tr>
<tr class="separator:aa7d2cfbedb9200e2ed973eb18cc3b23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fea4a93f741aa800e943957fd23656"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac8fea4a93f741aa800e943957fd23656">DefaultMaxAngularCorrection</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(8.0f / 180.0f) * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 1_rad</td></tr>
<tr class="memdesc:ac8fea4a93f741aa800e943957fd23656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum angular correction.  <a href="namespaceplayrho.html#ac8fea4a93f741aa800e943957fd23656">More...</a><br /></td></tr>
<tr class="separator:ac8fea4a93f741aa800e943957fd23656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71ffce08877ce941d29616eb907114"><td class="memItemLeft" align="right" valign="top"><a id="a6b71ffce08877ce941d29616eb907114"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6b71ffce08877ce941d29616eb907114">DefaultMaxTranslation</a> = 2_m</td></tr>
<tr class="memdesc:a6b71ffce08877ce941d29616eb907114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum translation amount. <br /></td></tr>
<tr class="separator:a6b71ffce08877ce941d29616eb907114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c3a1adc34421b07e930a06ce905db1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a36c3a1adc34421b07e930a06ce905db1">DefaultMaxRotation</a> = <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>{<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 1_rad / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(2)}</td></tr>
<tr class="memdesc:a36c3a1adc34421b07e930a06ce905db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum rotation per world step.  <a href="namespaceplayrho.html#a36c3a1adc34421b07e930a06ce905db1">More...</a><br /></td></tr>
<tr class="separator:a36c3a1adc34421b07e930a06ce905db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c87be197db81dde7d9f64ddd888bae"><td class="memItemLeft" align="right" valign="top"><a id="ab6c87be197db81dde7d9f64ddd888bae"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab6c87be197db81dde7d9f64ddd888bae">DefaultMaxToiIters</a> = std::uint8_t{20}</td></tr>
<tr class="memdesc:ab6c87be197db81dde7d9f64ddd888bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum time of impact iterations. <br /></td></tr>
<tr class="separator:ab6c87be197db81dde7d9f64ddd888bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad369e106022da8a461ed8a515014ee17"><td class="memItemLeft" align="right" valign="top"><a id="ad369e106022da8a461ed8a515014ee17"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad369e106022da8a461ed8a515014ee17">DefaultMaxToiRootIters</a> = std::uint8_t{30}</td></tr>
<tr class="memdesc:ad369e106022da8a461ed8a515014ee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum time of impact root iterator count. <br /></td></tr>
<tr class="separator:ad369e106022da8a461ed8a515014ee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea893c840466088049edc292dcc9dcb"><td class="memItemLeft" align="right" valign="top"><a id="adea893c840466088049edc292dcc9dcb"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adea893c840466088049edc292dcc9dcb">DefaultMaxDistanceIters</a> = std::uint8_t{20}</td></tr>
<tr class="memdesc:adea893c840466088049edc292dcc9dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default max number of distance iterations. <br /></td></tr>
<tr class="separator:adea893c840466088049edc292dcc9dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa678e38c906502e06a90f31e2acc952a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa678e38c906502e06a90f31e2acc952a">DefaultMaxSubSteps</a> = std::uint8_t{8}</td></tr>
<tr class="memdesc:aa678e38c906502e06a90f31e2acc952a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum number of sub steps.  <a href="namespaceplayrho.html#aa678e38c906502e06a90f31e2acc952a">More...</a><br /></td></tr>
<tr class="separator:aa678e38c906502e06a90f31e2acc952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6497dbff92f4140c03fb29f7dc80093d"><td class="memItemLeft" align="right" valign="top"><a id="a6497dbff92f4140c03fb29f7dc80093d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6497dbff92f4140c03fb29f7dc80093d">DefaultVelocityThreshold</a> = 1_mps</td></tr>
<tr class="memdesc:a6497dbff92f4140c03fb29f7dc80093d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default velocity threshold. <br /></td></tr>
<tr class="separator:a6497dbff92f4140c03fb29f7dc80093d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb622479d2ffb28ce1a4e88e8a211f"><td class="memItemLeft" align="right" valign="top"><a id="ab8eb622479d2ffb28ce1a4e88e8a211f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab8eb622479d2ffb28ce1a4e88e8a211f">DefaultRegMinMomentum</a> = <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>{0_Ns / 100}</td></tr>
<tr class="memdesc:ab8eb622479d2ffb28ce1a4e88e8a211f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default regular-phase minimum momentum. <br /></td></tr>
<tr class="separator:ab8eb622479d2ffb28ce1a4e88e8a211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e51d5b5ce397624e803df05ff1c013"><td class="memItemLeft" align="right" valign="top"><a id="a88e51d5b5ce397624e803df05ff1c013"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a88e51d5b5ce397624e803df05ff1c013">DefaultToiMinMomentum</a> = <a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>{0_Ns / 100}</td></tr>
<tr class="memdesc:a88e51d5b5ce397624e803df05ff1c013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TOI-phase minimum momentum. <br /></td></tr>
<tr class="separator:a88e51d5b5ce397624e803df05ff1c013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36288c4602f14acd96242145a546980"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af36288c4602f14acd96242145a546980">MaxFixtures</a></td></tr>
<tr class="memdesc:af36288c4602f14acd96242145a546980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of fixtures in a world.  <a href="namespaceplayrho.html#af36288c4602f14acd96242145a546980">More...</a><br /></td></tr>
<tr class="separator:af36288c4602f14acd96242145a546980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b821c4b23566defba0fd2917d95f0ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a></td></tr>
<tr class="memdesc:a7b821c4b23566defba0fd2917d95f0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bodies in a world.  <a href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">More...</a><br /></td></tr>
<tr class="separator:a7b821c4b23566defba0fd2917d95f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecc8cc059a2a3fa056888a1d405e4bc"><td class="memItemLeft" align="right" valign="top"><a id="a4ecc8cc059a2a3fa056888a1d405e4bc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4ecc8cc059a2a3fa056888a1d405e4bc">InvalidContactIndex</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>&gt;(-1)</td></tr>
<tr class="memdesc:a4ecc8cc059a2a3fa056888a1d405e4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid contact index. <br /></td></tr>
<tr class="separator:a4ecc8cc059a2a3fa056888a1d405e4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac18ab5fe22782c56d7ab92b397468e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5ac18ab5fe22782c56d7ab92b397468e">MaxContacts</a> = <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>} * <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a> - 1} / <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{2}</td></tr>
<tr class="memdesc:a5ac18ab5fe22782c56d7ab92b397468e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of contacts in a world (2147319811).  <a href="namespaceplayrho.html#a5ac18ab5fe22782c56d7ab92b397468e">More...</a><br /></td></tr>
<tr class="separator:a5ac18ab5fe22782c56d7ab92b397468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cde8c9e938d138a9a4ae8355501684"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">MaxJoints</a></td></tr>
<tr class="memdesc:a69cde8c9e938d138a9a4ae8355501684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of joints in a world.  <a href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">More...</a><br /></td></tr>
<tr class="separator:a69cde8c9e938d138a9a4ae8355501684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e5b3bf0a53f853c75244a15b08caee"><td class="memItemLeft" align="right" valign="top"><a id="a51e5b3bf0a53f853c75244a15b08caee"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a51e5b3bf0a53f853c75244a15b08caee">DefaultStepTime</a> = <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>{1_s / 60}</td></tr>
<tr class="memdesc:a51e5b3bf0a53f853c75244a15b08caee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step time. <br /></td></tr>
<tr class="separator:a51e5b3bf0a53f853c75244a15b08caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65202bedf970d0db4ad0d3e22ab3a0dd"><td class="memItemLeft" align="right" valign="top"><a id="a65202bedf970d0db4ad0d3e22ab3a0dd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a65202bedf970d0db4ad0d3e22ab3a0dd">DefaultStepFrequency</a> = 60_Hz</td></tr>
<tr class="memdesc:a65202bedf970d0db4ad0d3e22ab3a0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step frequency. <br /></td></tr>
<tr class="separator:a65202bedf970d0db4ad0d3e22ab3a0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e76508577c61a5bc9cc3107d60f3c1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0e76508577c61a5bc9cc3107d60f3c1b">DefaultMinStillTimeToSleep</a> = <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>{1_s / 2}</td></tr>
<tr class="memdesc:a0e76508577c61a5bc9cc3107d60f3c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default minimum still time to sleep.  <a href="namespaceplayrho.html#a0e76508577c61a5bc9cc3107d60f3c1b">More...</a><br /></td></tr>
<tr class="separator:a0e76508577c61a5bc9cc3107d60f3c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490b0d336b7a74ae18cf57632eeb7aa9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a490b0d336b7a74ae18cf57632eeb7aa9">DefaultLinearSleepTolerance</a> = 0.01_mps</td></tr>
<tr class="memdesc:a490b0d336b7a74ae18cf57632eeb7aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default linear sleep tolerance.  <a href="namespaceplayrho.html#a490b0d336b7a74ae18cf57632eeb7aa9">More...</a><br /></td></tr>
<tr class="separator:a490b0d336b7a74ae18cf57632eeb7aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31907e80be5889667f03ef86ee3bbf0a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a31907e80be5889667f03ef86ee3bbf0a">DefaultAngularSleepTolerance</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{(<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2) / 180} * <a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a></td></tr>
<tr class="memdesc:a31907e80be5889667f03ef86ee3bbf0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default angular sleep tolerance.  <a href="namespaceplayrho.html#a31907e80be5889667f03ef86ee3bbf0a">More...</a><br /></td></tr>
<tr class="separator:a31907e80be5889667f03ef86ee3bbf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12a28e4c1a2b9138c79d895d3ccb3aa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac12a28e4c1a2b9138c79d895d3ccb3aa">DefaultCirclesRatio</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{10}</td></tr>
<tr class="memdesc:ac12a28e4c1a2b9138c79d895d3ccb3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default circles ratio.  <a href="namespaceplayrho.html#ac12a28e4c1a2b9138c79d895d3ccb3aa">More...</a><br /></td></tr>
<tr class="separator:ac12a28e4c1a2b9138c79d895d3ccb3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f0b15d8cf3a0f200c50fc8bc6c4e08"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab8f0b15d8cf3a0f200c50fc8bc6c4e08">InvalidTypeID</a></td></tr>
<tr class="memdesc:ab8f0b15d8cf3a0f200c50fc8bc6c4e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid type ID value.  <a href="namespaceplayrho.html#ab8f0b15d8cf3a0f200c50fc8bc6c4e08">More...</a><br /></td></tr>
<tr class="separator:ab8f0b15d8cf3a0f200c50fc8bc6c4e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dacec03532687e9bac4ac6a882b35ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>, boost::units::si::second)</td></tr>
<tr class="memdesc:ga6dacec03532687e9bac4ac6a882b35ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second unit of time.  <a href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">More...</a><br /></td></tr>
<tr class="separator:ga6dacec03532687e9bac4ac6a882b35ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64467fca61de8c359a4e019f977ff320"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga64467fca61de8c359a4e019f977ff320">SquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a></td></tr>
<tr class="memdesc:ga64467fca61de8c359a4e019f977ff320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square second unit.  <a href="group__PhysicalUnits.html#ga64467fca61de8c359a4e019f977ff320">More...</a><br /></td></tr>
<tr class="separator:ga64467fca61de8c359a4e019f977ff320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef54036b9480e0cf730100688e20570"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gadef54036b9480e0cf730100688e20570">Hertz</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gad39135cf298be76964c70829ec84a51e">Frequency</a>, boost::units::si::hertz)</td></tr>
<tr class="memdesc:gadef54036b9480e0cf730100688e20570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hertz unit of Frequency.  <a href="group__PhysicalUnits.html#gadef54036b9480e0cf730100688e20570">More...</a><br /></td></tr>
<tr class="separator:gadef54036b9480e0cf730100688e20570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d1d9c70d11cff5fb552e939de39b9c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>, boost::units::si::meter)</td></tr>
<tr class="memdesc:gab5d1d9c70d11cff5fb552e939de39b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter unit of Length.  <a href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">More...</a><br /></td></tr>
<tr class="separator:gab5d1d9c70d11cff5fb552e939de39b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d80fc94ec9d5990d2fa6b9e4b67267d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga9d80fc94ec9d5990d2fa6b9e4b67267d">MeterPerSecond</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>, boost::units::si::meter_per_second)</td></tr>
<tr class="memdesc:ga9d80fc94ec9d5990d2fa6b9e4b67267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter per second unit of linear velocity.  <a href="group__PhysicalUnits.html#ga9d80fc94ec9d5990d2fa6b9e4b67267d">More...</a><br /></td></tr>
<tr class="separator:ga9d80fc94ec9d5990d2fa6b9e4b67267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc87db1f0fbc1b5f1ae9b44c66b6e82"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga0bc87db1f0fbc1b5f1ae9b44c66b6e82">MeterPerSquareSecond</a></td></tr>
<tr class="memdesc:ga0bc87db1f0fbc1b5f1ae9b44c66b6e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter per square second unit of linear acceleration.  <a href="group__PhysicalUnits.html#ga0bc87db1f0fbc1b5f1ae9b44c66b6e82">More...</a><br /></td></tr>
<tr class="separator:ga0bc87db1f0fbc1b5f1ae9b44c66b6e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ca745853415c1b3df906848978df9d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gad4ca745853415c1b3df906848978df9d">Kilogram</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga5edfc295416b7690b4f949223b551bc1">Mass</a>, boost::units::si::kilogram)</td></tr>
<tr class="memdesc:gad4ca745853415c1b3df906848978df9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilogram unit of mass.  <a href="group__PhysicalUnits.html#gad4ca745853415c1b3df906848978df9d">More...</a><br /></td></tr>
<tr class="separator:gad4ca745853415c1b3df906848978df9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb0acbda4409a1a132baf7df83b9870"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga1fb0acbda4409a1a132baf7df83b9870">SquareMeter</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#ga3ea2a7de91fdafccb2e49c3a84117ab5">Area</a>, boost::units::si::square_meter)</td></tr>
<tr class="memdesc:ga1fb0acbda4409a1a132baf7df83b9870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square meter unit of area.  <a href="group__PhysicalUnits.html#ga1fb0acbda4409a1a132baf7df83b9870">More...</a><br /></td></tr>
<tr class="separator:ga1fb0acbda4409a1a132baf7df83b9870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0107011ec7329a9ac267119f7ff941bb"><td class="memItemLeft" align="right" valign="top">
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga0107011ec7329a9ac267119f7ff941bb">CubicMeter</a> = <a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a> * <a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a> * <a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a></td></tr>
<tr class="memdesc:ga0107011ec7329a9ac267119f7ff941bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic meter unit of volume. <br /></td></tr>
<tr class="separator:ga0107011ec7329a9ac267119f7ff941bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64416f646855741c31802eb689760ba8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga64416f646855741c31802eb689760ba8">KilogramPerSquareMeter</a></td></tr>
<tr class="memdesc:ga64416f646855741c31802eb689760ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilogram per square meter unit of area density.  <a href="group__PhysicalUnits.html#ga64416f646855741c31802eb689760ba8">More...</a><br /></td></tr>
<tr class="separator:ga64416f646855741c31802eb689760ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbe3f5282db32af8292500e505e21e5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>, boost::units::si::radian)</td></tr>
<tr class="memdesc:gaebbe3f5282db32af8292500e505e21e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian unit of angle.  <a href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">More...</a><br /></td></tr>
<tr class="separator:gaebbe3f5282db32af8292500e505e21e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0840a4c6fcfa4ed0f1e25820fea0ca3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">Degree</a> = <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>{<a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{180}}</td></tr>
<tr class="memdesc:gaf0840a4c6fcfa4ed0f1e25820fea0ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree unit of angle quantity.  <a href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">More...</a><br /></td></tr>
<tr class="separator:gaf0840a4c6fcfa4ed0f1e25820fea0ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941b3913fd0dd86a33e695cd9b73318f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga941b3913fd0dd86a33e695cd9b73318f">SquareRadian</a> = <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> * <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a></td></tr>
<tr class="memdesc:ga941b3913fd0dd86a33e695cd9b73318f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square radian unit type.  <a href="group__PhysicalUnits.html#ga941b3913fd0dd86a33e695cd9b73318f">More...</a><br /></td></tr>
<tr class="separator:ga941b3913fd0dd86a33e695cd9b73318f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446e46852ff69dee446aadc44635865c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a>, boost::units::si::radian_per_second)</td></tr>
<tr class="memdesc:ga446e46852ff69dee446aadc44635865c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian per second unit of angular velocity.  <a href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">More...</a><br /></td></tr>
<tr class="separator:ga446e46852ff69dee446aadc44635865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987ba57899c87b7d6734d046d1c854b8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga987ba57899c87b7d6734d046d1c854b8">DegreePerSecond</a> = <a class="el" href="group__PhysicalQuantities.html#gac33f92018f7e8821550296aece465028">AngularVelocity</a>{<a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a> * <a class="el" href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">Degree</a> / <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a>}</td></tr>
<tr class="memdesc:ga987ba57899c87b7d6734d046d1c854b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree per second unit of angular velocity.  <a href="group__PhysicalUnits.html#ga987ba57899c87b7d6734d046d1c854b8">More...</a><br /></td></tr>
<tr class="separator:ga987ba57899c87b7d6734d046d1c854b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da7c45fe3ebc86d397e684154033742"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga0da7c45fe3ebc86d397e684154033742">RadianPerSquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> / (<a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a>)</td></tr>
<tr class="memdesc:ga0da7c45fe3ebc86d397e684154033742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian per square second unit of angular acceleration.  <a href="group__PhysicalUnits.html#ga0da7c45fe3ebc86d397e684154033742">More...</a><br /></td></tr>
<tr class="separator:ga0da7c45fe3ebc86d397e684154033742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7cdea552b0f98a011b3287850433a2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga7a7cdea552b0f98a011b3287850433a2">DegreePerSquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">Degree</a> / (<a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a>)</td></tr>
<tr class="memdesc:ga7a7cdea552b0f98a011b3287850433a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree per square second unit of angular acceleration.  <a href="group__PhysicalUnits.html#ga7a7cdea552b0f98a011b3287850433a2">More...</a><br /></td></tr>
<tr class="separator:ga7a7cdea552b0f98a011b3287850433a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88db74a1ddb390655f0837d9c970f76"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gac88db74a1ddb390655f0837d9c970f76">Newton</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>, boost::units::si::newton)</td></tr>
<tr class="memdesc:gac88db74a1ddb390655f0837d9c970f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton unit of force.  <a href="group__PhysicalUnits.html#gac88db74a1ddb390655f0837d9c970f76">More...</a><br /></td></tr>
<tr class="separator:gac88db74a1ddb390655f0837d9c970f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab920bd1046410474258f9e8630e557a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gab920bd1046410474258f9e8630e557a1">NewtonMeter</a> = PLAYRHO_UNIT(<a class="el" href="group__PhysicalQuantities.html#gaa13e620479b6e4a34fae5a90bcaf9355">Torque</a>, boost::units::si::newton_meter)</td></tr>
<tr class="memdesc:gab920bd1046410474258f9e8630e557a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton meter unit of torque.  <a href="group__PhysicalUnits.html#gab920bd1046410474258f9e8630e557a1">More...</a><br /></td></tr>
<tr class="separator:gab920bd1046410474258f9e8630e557a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64db6556e1824d11178c3d68301c2adc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga64db6556e1824d11178c3d68301c2adc">NewtonSecond</a> = <a class="el" href="group__PhysicalUnits.html#gac88db74a1ddb390655f0837d9c970f76">Newton</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a></td></tr>
<tr class="memdesc:ga64db6556e1824d11178c3d68301c2adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton second unit of momentum.  <a href="group__PhysicalUnits.html#ga64db6556e1824d11178c3d68301c2adc">More...</a><br /></td></tr>
<tr class="separator:ga64db6556e1824d11178c3d68301c2adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae55524173aec32daa74def2b8dddc0bb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gae55524173aec32daa74def2b8dddc0bb">NewtonMeterSecond</a> = <a class="el" href="group__PhysicalUnits.html#gab920bd1046410474258f9e8630e557a1">NewtonMeter</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a></td></tr>
<tr class="memdesc:gae55524173aec32daa74def2b8dddc0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton meter second unit of angular momentum.  <a href="group__PhysicalUnits.html#gae55524173aec32daa74def2b8dddc0bb">More...</a><br /></td></tr>
<tr class="separator:gae55524173aec32daa74def2b8dddc0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46b97afc56560699033e7c3fb480a4f7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga46b97afc56560699033e7c3fb480a4f7">RevolutionsPerMinute</a> = 2 * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> / (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{60} * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a>)</td></tr>
<tr class="memdesc:ga46b97afc56560699033e7c3fb480a4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revolutions per minute units of angular velocity.  <a href="group__PhysicalUnits.html#ga46b97afc56560699033e7c3fb480a4f7">More...</a><br /></td></tr>
<tr class="separator:ga46b97afc56560699033e7c3fb480a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770e7e3c14510e96d5115b36988e5dde"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UnitConstants.html#ga770e7e3c14510e96d5115b36988e5dde">EarthlyLinearAcceleration</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{-9.8f} * <a class="el" href="group__PhysicalUnits.html#ga0bc87db1f0fbc1b5f1ae9b44c66b6e82">MeterPerSquareSecond</a></td></tr>
<tr class="memdesc:ga770e7e3c14510e96d5115b36988e5dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Earthly gravity.  <a href="group__UnitConstants.html#ga770e7e3c14510e96d5115b36988e5dde">More...</a><br /></td></tr>
<tr class="separator:ga770e7e3c14510e96d5115b36988e5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4435a07d3cb65258172c132b134c02fb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UnitConstants.html#ga4435a07d3cb65258172c132b134c02fb">BigG</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{6.67408e-11f} * <a class="el" href="group__PhysicalUnits.html#ga0107011ec7329a9ac267119f7ff941bb">CubicMeter</a> / (<a class="el" href="group__PhysicalUnits.html#gad4ca745853415c1b3df906848978df9d">Kilogram</a> * <a class="el" href="group__PhysicalUnits.html#ga64467fca61de8c359a4e019f977ff320">SquareSecond</a>)</td></tr>
<tr class="memdesc:ga4435a07d3cb65258172c132b134c02fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Big "G".  <a href="group__UnitConstants.html#ga4435a07d3cb65258172c132b134c02fb">More...</a><br /></td></tr>
<tr class="separator:ga4435a07d3cb65258172c132b134c02fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fa6c4a45ec8fd218dc962396685c3f"><td class="memItemLeft" align="right" valign="top"><a id="a38fa6c4a45ec8fd218dc962396685c3f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a38fa6c4a45ec8fd218dc962396685c3f">InvalidBodyID</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a>&gt;(static_cast&lt;<a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html#a2ed01bf69779b0880b5092c6bbad560b">BodyID::underlying_type</a>&gt;(-1))</td></tr>
<tr class="memdesc:a38fa6c4a45ec8fd218dc962396685c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid body ID value. <br /></td></tr>
<tr class="separator:a38fa6c4a45ec8fd218dc962396685c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7a2c4f0ce447813c94060e1ea4c0f9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1a7a2c4f0ce447813c94060e1ea4c0f9">InvalidContactID</a></td></tr>
<tr class="memdesc:a1a7a2c4f0ce447813c94060e1ea4c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid contact ID value.  <a href="namespaceplayrho.html#a1a7a2c4f0ce447813c94060e1ea4c0f9">More...</a><br /></td></tr>
<tr class="separator:a1a7a2c4f0ce447813c94060e1ea4c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fdab88f7f4e1fdf64360e3d9501fa1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad7fdab88f7f4e1fdf64360e3d9501fa1">InvalidFixtureID</a></td></tr>
<tr class="memdesc:ad7fdab88f7f4e1fdf64360e3d9501fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid fixture ID value.  <a href="namespaceplayrho.html#ad7fdab88f7f4e1fdf64360e3d9501fa1">More...</a><br /></td></tr>
<tr class="separator:ad7fdab88f7f4e1fdf64360e3d9501fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d10419efd6effdd41617992a76cbcd"><td class="memItemLeft" align="right" valign="top"><a id="a67d10419efd6effdd41617992a76cbcd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a67d10419efd6effdd41617992a76cbcd">InvalidJointID</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a>&gt;(static_cast&lt;<a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html#a2ed01bf69779b0880b5092c6bbad560b">JointID::underlying_type</a>&gt;(-1))</td></tr>
<tr class="memdesc:a67d10419efd6effdd41617992a76cbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid joint ID value. <br /></td></tr>
<tr class="separator:a67d10419efd6effdd41617992a76cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Name space for all PlayRho related names. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a4106d8a0e998a2485196534514527a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4106d8a0e998a2485196534514527a5a">&#9670;&nbsp;</a></span>BodyCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">playrho::BodyCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count type for bodies. </p>
<dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxBodies</code> value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a8">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a31">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aed352724e203ca09595faf0dc6a76e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed352724e203ca09595faf0dc6a76e5c">&#9670;&nbsp;</a></span>ChildCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">playrho::ChildCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#af33623a59b7c701aead6d06e88dc2cc6">MaxChildCount</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Child counter type. </p>
<p>Relating to "children" of shape where each child is a convex shape possibly comprising a concave shape. </p><dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxChildCount</code> value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Shape_8cpp-example.html#a11">Shape.cpp</a>, <a class="el" href="World_8cpp-example.html#a31">World.cpp</a>, and <a class="el" href="WorldContact_8cpp-example.html#a36">WorldContact.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2bf0674233f83e8b83b30db98332e129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf0674233f83e8b83b30db98332e129">&#9670;&nbsp;</a></span>ContactCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">playrho::ContactCounter</a> = typedef <a class="el" href="structplayrho_1_1Wider.html">Wider</a>&lt;<a class="el" href="namespaceplayrho.html#a4106d8a0e998a2485196534514527a5a">BodyCounter</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count type for contacts. </p>
<dl class="section note"><dt>Note</dt><dd>This type must be able to contain the squared value of <code>BodyCounter</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a14">World.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a51e61fee8a0be399ed24773ebc3135f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e61fee8a0be399ed24773ebc3135f8">&#9670;&nbsp;</a></span>Fixed32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a51e61fee8a0be399ed24773ebc3135f8">playrho::Fixed32</a> = typedef <a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt;std::int32_t,9&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>32-bit fixed precision type. </p>
<p>This is a 32-bit fixed precision type with a Q number-format of <code>Q23.9</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The available numeric fidelity of any 32-bit fixed point type is very limited. Using a 32-bit fixed point type for Real should only be considered for simulations where it's been found to work and where the dynamics won't be changing between runs.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Maximum value (with 9 fraction bits) is approximately 4194303.99609375. </dd>
<dd>
Minimum value (with 9 fraction bits) is approximately 0.001953125.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers.">Fixed</a>, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87" title="Real-number type.">Real</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Q_(number_format)">https://en.wikipedia.org/wiki/Q_(number_format)</a> </dd></dl>

</div>
</div>
<a id="a15fb4e1b050424d59666b3b2b7b6c935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fb4e1b050424d59666b3b2b7b6c935">&#9670;&nbsp;</a></span>FixtureCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a15fb4e1b050424d59666b3b2b7b6c935">playrho::FixtureCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#af36288c4602f14acd96242145a546980">MaxFixtures</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter type for fixtures. </p>
<dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxFixtures</code> value. </dd></dl>

</div>
</div>
<a id="a2d09dc7b51321c052b071485357ca1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d09dc7b51321c052b071485357ca1f9">&#9670;&nbsp;</a></span>Force2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">playrho::Force2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gabdbf955ed1cafec5062f074511ee4829">Force</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Force quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional force vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a127">World.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad9c300db3a063bd5b4c1d947cc302577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c300db3a063bd5b4c1d947cc302577">&#9670;&nbsp;</a></span>HasNullaryFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad9c300db3a063bd5b4c1d947cc302577">playrho::HasNullaryFunctor</a> = typedef <a class="el" href="structplayrho_1_1HasFunctor.html">HasFunctor</a>&lt;Type,Return()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has nullary functor type alias. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#acbd75892346a971d244693bb9d97a33e" title="Has unary functor type alias.">HasUnaryFunctor</a>. </dd></dl>

</div>
</div>
<a id="acbd75892346a971d244693bb9d97a33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd75892346a971d244693bb9d97a33e">&#9670;&nbsp;</a></span>HasUnaryFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Return , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#acbd75892346a971d244693bb9d97a33e">playrho::HasUnaryFunctor</a> = typedef <a class="el" href="structplayrho_1_1HasFunctor.html">HasFunctor</a>&lt;Type,Return(Arg)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has unary functor type alias. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ad9c300db3a063bd5b4c1d947cc302577" title="Has nullary functor type alias.">HasNullaryFunctor</a>. </dd></dl>

</div>
</div>
<a id="a7d449e0a1528c10ae0f241713fb69b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d449e0a1528c10ae0f241713fb69b40">&#9670;&nbsp;</a></span>IndexPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">playrho::IndexPair</a> = typedef std::pair&lt;<a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>, <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">VertexCounter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index pair. </p>
<dl class="section note"><dt>Note</dt><dd>This data structure is at least 2-bytes large. </dd>
<dd>
Using <code>std::array</code> would make more sense if it weren't for the fact that <code>std::pair</code>, but not <code>std::array</code>, has <code>constexpr</code> equality and inequality operators. </dd></dl>

</div>
</div>
<a id="a704da3b24d9b1f9135e140dcd5420518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704da3b24d9b1f9135e140dcd5420518">&#9670;&nbsp;</a></span>IndexPair3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">playrho::IndexPair3</a> = typedef std::array&lt;<a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>, <a class="el" href="namespaceplayrho.html#a95591102a273a4d301f3f795d463b9ba">MaxSimplexEdges</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of three index-pair elements. </p>
<dl class="section note"><dt>Note</dt><dd>An element having the <code>InvalidIndexPair</code> value, denotes an unused or invalid elements. </dd>
<dd>
This data type is 6-bytes large (on at least one 64-bit platform). </dd></dl>

</div>
</div>
<a id="aeb8ea60dc388d1e92e2e6fa277a32495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8ea60dc388d1e92e2e6fa277a32495">&#9670;&nbsp;</a></span>JointCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#aeb8ea60dc388d1e92e2e6fa277a32495">playrho::JointCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">MaxJoints</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter type for joints. </p>
<dl class="section note"><dt>Note</dt><dd>This type must be able to contain the <code>MaxJoints</code> value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a12">World.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7dc68cd0ce177e175ae0bb6c39db158d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc68cd0ce177e175ae0bb6c39db158d">&#9670;&nbsp;</a></span>Length2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">playrho::Length2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Length quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional distance or location vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DistanceJoint_8cpp-example.html#a49">DistanceJoint.cpp</a>, <a class="el" href="PrismaticJoint_8cpp-example.html#a4">PrismaticJoint.cpp</a>, <a class="el" href="PulleyJoint_8cpp-example.html#a48">PulleyJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#a4">RevoluteJoint.cpp</a>, <a class="el" href="RopeJoint_8cpp-example.html#a16">RopeJoint.cpp</a>, <a class="el" href="Shape_8cpp-example.html#a30">Shape.cpp</a>, <a class="el" href="TargetJoint_8cpp-example.html#a1">TargetJoint.cpp</a>, <a class="el" href="WeldJoint_8cpp-example.html#a27">WeldJoint.cpp</a>, <a class="el" href="WheelJoint_8cpp-example.html#a37">WheelJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#a32">World.cpp</a>, <a class="el" href="WorldBody_8cpp-example.html#a97">WorldBody.cpp</a>, and <a class="el" href="WorldFixture_8cpp-example.html#a27">WorldFixture.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5822921028100052d4c6dfb43c7f6c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822921028100052d4c6dfb43c7f6c4b">&#9670;&nbsp;</a></span>LinearAcceleration2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">playrho::LinearAcceleration2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gadf7de472e7f4a6fa26bff6a655f100e7">LinearAcceleration</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of linear acceleration (<code>LinearAcceleration</code>) quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional linear acceleration vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="WorldBody_8cpp-example.html#a96">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2faa31bff8794a0c4191d8b042f7deeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faa31bff8794a0c4191d8b042f7deeb">&#9670;&nbsp;</a></span>LinearVelocity2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">playrho::LinearVelocity2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga6e944c18ed210626b5829b8ad2813fde">LinearVelocity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of linear velocity (<code>LinearVelocity</code>) quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional speed vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="WorldBody_8cpp-example.html#a103">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acbf97bd8e3f0f2ce4588735388f4089a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf97bd8e3f0f2ce4588735388f4089a">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">playrho::Matrix</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, N&gt;, M&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic M by N matrix. </p>
<dl class="section note"><dt>Note</dt><dd>M is the number of rows of the matrix. </dd>
<dd>
N is the number of columns of the matrix. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">https://en.wikipedia.org/wiki/Matrix_(mathematics)</a> </dd>
<dd>
<a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>, <a class="el" href="group__MatrixTraitsGroup.html" title="Collection of trait classes for matrices.">Matrix Traits</a>, <a class="el" href="structplayrho_1_1IsVector.html" title="Trait class for checking if type is a Vector type.">IsVector</a> </dd></dl>

</div>
</div>
<a id="a1fa6ffb2e67c2e2f620eed088412b146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa6ffb2e67c2e2f620eed088412b146">&#9670;&nbsp;</a></span>Momentum2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">playrho::Momentum2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga1d281ffd7cf8e2c8897d03a1cae9f1f8">Momentum</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Momentum quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional momentum vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Joint_8cpp-example.html#a21">Joint.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae444a62491fcb2b10f0f06a41b1ac406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae444a62491fcb2b10f0f06a41b1ac406">&#9670;&nbsp;</a></span>PairLength2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">playrho::PairLength2</a> = typedef std::pair&lt;<a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>, <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of <code>Length2</code> values. </p>
<dl class="section note"><dt>Note</dt><dd>Uses <code>std::pair</code> because this is a pair and also because <code>std::pair</code> has more support for constant expressions. </dd></dl>

</div>
</div>
<a id="a1fc125070a08100d083a1360f7167f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc125070a08100d083a1360f7167f87">&#9670;&nbsp;</a></span>Real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">playrho::Real</a> = typedef float</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real-number type. </p>
<p>This is the number type underlying numerical calculations conceptually involving real-numbers. Ideally the implementation of this type doesn't suffer from things like: catastrophic cancellation, catastrophic division, overflows, nor underflows.</p>
<dl class="section note"><dt>Note</dt><dd>This can be implemented using any of the fundamental floating point types ( <code>float</code>, <code>double</code>, or <code>long double</code>). </dd>
<dd>
This can also be implemented using a <code>LiteralType</code> that has the necessary support: all common mathematical functions, support for infinity and NaN, and a specialization of the <code>std::numeric_limits</code> class template for it. </dd>
<dd>
At present, the <code>Fixed32</code> and <code>Fixed64</code> aliases of the <code><a class="el" href="classplayrho_1_1Fixed.html" title="Template class for fixed-point numbers.">Fixed</a></code> template type are provided as examples of qualifying literal types though the usability of these are limited and their use is discouraged.</dd>
<dd>
Regarding division:<ul>
<li>While dividing 1 by a real, caching the result, and then doing multiplications with the result may well be faster (than repeatedly dividing), dividing 1 by the real can also result in an underflow situation that's then compounded every time it's multiplied with other values.</li>
<li>Meanwhile, dividing every time by a real isolates any underflows to the particular division where underflow occurs.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Using <code>Fixed32</code> is not advised as its numerical limitations are more likely to result in problems like overflows or underflows. </dd>
<dd>
The note regarding division applies even more so when using a fixed-point type (for <code>Real</code>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a> </dd>
<dd>
<a href="https://en.cppreference.com/w/cpp/types/is_floating_point">https://en.cppreference.com/w/cpp/types/is_floating_point</a> </dd>
<dd>
<a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">https://en.cppreference.com/w/cpp/named_req/LiteralType</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Body_8cpp-example.html#a17">Body.cpp</a>, <a class="el" href="DistanceJoint_8cpp-example.html#a8">DistanceJoint.cpp</a>, <a class="el" href="GearJoint_8cpp-example.html#a20">GearJoint.cpp</a>, <a class="el" href="MotorJoint_8cpp-example.html#a4">MotorJoint.cpp</a>, <a class="el" href="PrismaticJoint_8cpp-example.html#a50">PrismaticJoint.cpp</a>, <a class="el" href="PulleyJoint_8cpp-example.html#a31">PulleyJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#a51">RevoluteJoint.cpp</a>, <a class="el" href="Shape_8cpp-example.html#a5">Shape.cpp</a>, <a class="el" href="TargetJoint_8cpp-example.html#a9">TargetJoint.cpp</a>, <a class="el" href="WeldJoint_8cpp-example.html#a46">WeldJoint.cpp</a>, <a class="el" href="WheelJoint_8cpp-example.html#a40">WheelJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#a4">World.cpp</a>, <a class="el" href="WorldBody_8cpp-example.html#a16">WorldBody.cpp</a>, <a class="el" href="WorldContact_8cpp-example.html#a19">WorldContact.cpp</a>, and <a class="el" href="WorldFixture_8cpp-example.html#a14">WorldFixture.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3898807006fd29cd5c4fc2e1a9cf5536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3898807006fd29cd5c4fc2e1a9cf5536">&#9670;&nbsp;</a></span>TimestepIters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a3898807006fd29cd5c4fc2e1a9cf5536">playrho::TimestepIters</a> = typedef std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time step iterations type. </p>
<p>A type for counting iterations per time-step. </p>

</div>
</div>
<a id="a592a9fb888eae63605b73b61c61ccd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592a9fb888eae63605b73b61c61ccd17">&#9670;&nbsp;</a></span>TupleContainsType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a592a9fb888eae63605b73b61c61ccd17">playrho::TupleContainsType</a> = typedef typename <a class="el" href="structplayrho_1_1HasType.html">HasType</a>&lt;T, Tuple&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tuple contains type alias. </p>
<p>Alias in case the trait itself should be <code>std::true_type</code> or <code>std::false_type</code>. </p><dl class="section note"><dt>Note</dt><dd>This is from Piotr Skotnicki's answer on the <em>StackOverflow</em> website to the question of: "How do I find out if a tuple contains a type?". </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/a/25958302/7410358">https://stackoverflow.com/a/25958302/7410358</a> </dd></dl>

</div>
</div>
<a id="ad93c0cd83df090aba6593ffac4b628ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93c0cd83df090aba6593ffac4b628ec">&#9670;&nbsp;</a></span>Vec2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">playrho::Vec2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2 Real elements. </p>
<dl class="section note"><dt>Note</dt><dd>This data structure is two-times the size of the <code>Real</code> type (or 8 using Real of float). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a133">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a62">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a63f6dcdf3763052ea25099973c7c00ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f6dcdf3763052ea25099973c7c00ad">&#9670;&nbsp;</a></span>Vec3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">playrho::Vec3</a> = typedef <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A 3-dimensional column vector with 3 elements. </p>
<dl class="section note"><dt>Note</dt><dd>This data structure is 3 times the size of <code>Real</code> - i.e. 12-bytes (with 4-byte Real). </dd></dl>

</div>
</div>
<a id="a97243f194a9406d0fdcf5f6f833851ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97243f194a9406d0fdcf5f6f833851ab">&#9670;&nbsp;</a></span>Vector2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">playrho::Vector2</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2-elements. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a C++11 alias template for 2-element uses of the <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> template. </dd></dl>

</div>
</div>
<a id="ad07b44f811ac4c7551067fb1d3554ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07b44f811ac4c7551067fb1d3554ec5">&#9670;&nbsp;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">playrho::Vector3</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 3-elements. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a C++11 alias template for 3-element uses of the <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> template. </dd></dl>

</div>
</div>
<a id="a16da705f1b3c51c7fd1b9b1162c258b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16da705f1b3c51c7fd1b9b1162c258b9">&#9670;&nbsp;</a></span>VertexCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a16da705f1b3c51c7fd1b9b1162c258b9">playrho::VertexCounter</a> = typedef std::remove_const&lt;decltype(<a class="el" href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">MaxShapeVertices</a>)&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertex count type. </p>
<dl class="section note"><dt>Note</dt><dd>This type must not support more than 255 vertices as that would conflict with the <code><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041" title="Index type.">ContactFeature::Index</a></code> type. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a098b0ef528e3b728af8e3e17873963f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098b0ef528e3b728af8e3e17873963f7">&#9670;&nbsp;</a></span>BodyType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">playrho::BodyType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of body. </p>
<dl class="section note"><dt>Note</dt><dd>static: zero mass, zero velocity, may be manually moved. </dd>
<dd>
kinematic: zero mass, non-zero velocity set by user, moved by solver. </dd>
<dd>
dynamic: positive mass, non-zero velocity determined by forces, moved by solver. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893" title="Is &quot;speedable&quot;.">IsSpeedable(BodyType)</a>, <a class="el" href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd" title="Is &quot;accelerable&quot;.">IsAccelerable(BodyType)</a>. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a84a8921b25f505d0d2077aeb5db4bc16"></a>Static&#160;</td><td class="fielddoc"><p>Static body type. </p>
<p>Static bodies have no mass, have no forces applied to them, and aren't moved by physical processes. They are impenetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: none. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a40c78b58b86002ee38fad2d3c9dd787e"></a>Kinematic&#160;</td><td class="fielddoc"><p>Kinematic body type. </p>
<p>Kinematic bodies: have no mass, cannot have forces applied to them, can move at set velocities (they are "speedable"), and are impenetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: velocity. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a971fd8cc345d8bd9f92e9f7d88fdf20c"></a>Dynamic&#160;</td><td class="fielddoc"><p>Dynamic body type. </p>
<p>Dynamic bodies are fully simulated bodies - they are "speedable" and "accelerable". Dynamic bodies always have a positive non-zero mass. They may be penetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: velocity, acceleration. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a06f67e158a928ef59e4263facac8fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f67e158a928ef59e4263facac8fb0b">&#9670;&nbsp;</a></span>PointState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">playrho::PointState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point state enumeration. </p>
<dl class="section note"><dt>Note</dt><dd>This is used for determining the state of contact points. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba5ac8cf2fb7a90ff2d0829f5fca4db5b8"></a>NullState&#160;</td><td class="fielddoc"><p>point does not exist </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba494a3e62657370358107e2edf3fca5a0"></a>AddState&#160;</td><td class="fielddoc"><p>point was added in the update </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba60a7f32dd91e5f33a4ca2bc7b7255343"></a>PersistState&#160;</td><td class="fielddoc"><p>point persisted across the update </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba3500ff358c0521359118fe519bd8f605"></a>RemoveState&#160;</td><td class="fielddoc"><p>point was removed in the update </p>
</td></tr>
</table>

</div>
</div>
<a id="a66189f1fe36ac717e284ab1099171106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66189f1fe36ac717e284ab1099171106">&#9670;&nbsp;</a></span>RayCastOpcode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">playrho::RayCastOpcode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ray cast opcode enumeration. </p>
<p>Instructs some ray casting methods on what to do next. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a056fa3d840f48b7bfbbd68c19a4797b3"></a>Terminate&#160;</td><td class="fielddoc"><p>End the ray-cast search for fixtures. </p>
<p>Use this to stop searching for fixtures. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106aaf8767ee039cdc51717435bb815da593"></a>IgnoreFixture&#160;</td><td class="fielddoc"><p>Ignore the current fixture. </p>
<p>Use this to continue searching for fixtures along the ray. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a8dcfe18b6245b17c9cd69d5af7ef1847"></a>ClipRay&#160;</td><td class="fielddoc"><p>Clip the ray end to the current point. </p>
<p>Use this shorten the ray to the current point and to continue searching for fixtures now along the newly shortened ray. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a4592f28dc9d11de3ce507bebafd9de16"></a>ResetRay&#160;</td><td class="fielddoc"><p>Reset the ray end back to the second point. </p>
<p>Use this to restore the ray to its full length and to continue searching for fixtures now along the restored full length ray. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a516a3bbb73371cdc53f348b67f43bb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516a3bbb73371cdc53f348b67f43bb1f">&#9670;&nbsp;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * playrho::Alloc </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory. </p>
<dl class="section note"><dt>Note</dt><dd>One can change this function to use ones own memory allocator. Be sure to conform to this function's interface: throw a <code>std::bad_alloc</code> exception if unable to allocate non-zero sized memory and return a null pointer if the requested size is zero. This is done to ensure that the behavior is not implementation defined unlike <code>std::malloc</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to allocate non-zero sized memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if size is not zero else <code>nullptr</code>. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>, <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0" title="Reallocates memory.">Realloc</a>, <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62" title="Reallocates memory for an array.">ReallocArray</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">AllocArray()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#abbb25555e5d25ed67a4748136ff7b8ed">playrho::BlockAllocator::Allocate()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a1ecbcaa8d549ffa1522e7128fc8a684d">playrho::StackAllocator::Allocate()</a>, and <a class="el" href="classplayrho_1_1StackAllocator.html#ae4eae1341918e7a7e5a6ed3d10edc84b">playrho::StackAllocator::StackAllocator()</a>.</p>

</div>
</div>
<a id="a2943dd9a79b7fc1fa196af1208b00388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2943dd9a79b7fc1fa196af1208b00388">&#9670;&nbsp;</a></span>AllocArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* playrho::AllocArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for an array. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to allocate non-zero sized memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if size is not zero else <code>nullptr</code>. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>, <a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f" title="Allocates memory.">Alloc</a>, <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62" title="Reallocates memory for an array.">ReallocArray</a>. </dd></dl>

</div>
</div>
<a id="a87b5e301c1a03179e49ed7ee3a9408d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b5e301c1a03179e49ed7ee3a9408d9">&#9670;&nbsp;</a></span>AlmostZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BT , unsigned int FB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Fixed.html">Fixed</a>&lt; BT, FB &gt;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether a given value is almost zero. </p>
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga00c5f66dc1a40a727a7983aab1d92929">AlmostEqual()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a073a93c54a20aa68f2c56e759b7976ab">playrho::d2::ClipSegmentToLine()</a>, <a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">ComputeCentroid()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::Distance()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a7304da106cfaa394b4d0179ded468aa6">playrho::d2::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad3851d0c3b764c9fe4dbaad8268ea201">playrho::d2::GetToiViaSat()</a>, <a class="el" href="group__Math.html#ga00cc9646bab6ce84d6b4704f8c1e0ade">Invert()</a>, <a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">Normalize()</a>, <a class="el" href="group__RayCastGroup.html#gad7a1b955a57a2bb043750bf32cde2549">playrho::d2::RayCast()</a>, and <a class="el" href="group__Math.html#ga3846333746b73978c91e250c6f239ce3">Solve()</a>.</p>

</div>
</div>
<a id="aa5b77298f0fc2a2ae88ececbc3fb23d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b77298f0fc2a2ae88ececbc3fb23d1">&#9670;&nbsp;</a></span>EraseAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::EraseAll </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(distance(container.erase(remove(begin(container), end(container), value), end(container)), end(container)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template function for erasing specified value from container. </p>
<dl class="section note"><dt>Note</dt><dd>This basically is the C++20 <code>std::erase</code> function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements erased. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ad559996a9d085eb07a18b5b88525761f" title="Convenience template function for erasing first found value from container.">EraseFirst</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a497b22f2480ab65cf01ad56a76143721">playrho::d2::WorldImpl::Destroy()</a>.</p>

</div>
</div>
<a id="ad559996a9d085eb07a18b5b88525761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad559996a9d085eb07a18b5b88525761f">&#9670;&nbsp;</a></span>EraseFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::EraseFirst </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(container.erase(find(begin(container), end(container), value)) != end(container))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template function for erasing first found value from container. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value was found and erased, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#aa5b77298f0fc2a2ae88ececbc3fb23d1" title="Convenience template function for erasing specified value from container.">EraseAll</a>. </dd></dl>

</div>
</div>
<a id="a62c138018c11ab3c255b410f2dedd7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c138018c11ab3c255b410f2dedd7d2">&#9670;&nbsp;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playrho::Free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory. </p>
<dl class="section note"><dt>Note</dt><dd>If you change <code>Alloc</code>, consider also changing this function. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f" title="Allocates memory.">Alloc</a>, <a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388" title="Allocates memory for an array.">AllocArray</a>, <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0" title="Reallocates memory.">Realloc</a>, <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62" title="Reallocates memory for an array.">ReallocArray</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1BlockAllocator.html#a12d8426f4a31b8ed042b2a62699d04e4">playrho::BlockAllocator::Clear()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#ad8b0e591e1c43454b16d924e628cb1e8">playrho::d2::DynamicTree::Clear()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a74aadaded9475221a0ea343bff727df5">playrho::StackAllocator::Free()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a06536ee49cdb1a8c2f79de7522c8bd33">playrho::BlockAllocator::Free()</a>, <a class="el" href="classplayrho_1_1GrowableStack.html#a9a52c69b5e506bef0d458f1631ca3514">playrho::GrowableStack&lt; T, N &gt;::push()</a>, <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">Realloc()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#a47cbaffc41092844c1b4812057e37f13">playrho::d2::DynamicTree::RebuildBottomUp()</a>, and <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#ad81a322bcd52726dba15394783eea8fb">playrho::d2::DynamicTree::~DynamicTree()</a>.</p>

</div>
</div>
<a id="a6ddf94310b3145c842e6365e3ec69226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddf94310b3145c842e6365e3ec69226">&#9670;&nbsp;</a></span>GetCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T GetCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the center of the given interval. </p>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the difference between the given range's max and min values overflows the range of the <code><a class="el" href="classplayrho_1_1Interval.html#af3f2912d491535ecbe0f8b03da2357b7" title="Value type.">Interval::value_type</a></code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__RayCastGroup.html#gadf0ec62e1852e3bc9b017eae4a5616b4">playrho::d2::RayCast()</a>.</p>

</div>
</div>
<a id="a982dd137f465f53dd7c84e6d6286a3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982dd137f465f53dd7c84e6d6286a3ad">&#9670;&nbsp;</a></span>GetIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;<a class="el" href="structplayrho_1_1IsSquareMatrix.html">IsSquareMatrix</a>&lt;T&gt;::value, T&gt; playrho::GetIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the identity matrix of the template type and size as given by the argument. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Identity_matrix">https://en.wikipedia.org/wiki/Identity_matrix</a> </dd>
<dd>
<a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a" title="Generic M by N matrix.">Matrix</a>, <a class="el" href="structplayrho_1_1IsMatrix.html" title="Trait class for checking if type is a matrix type.">IsMatrix</a>, <a class="el" href="structplayrho_1_1IsSquareMatrix.html" title="Trait class for checking if type is a square matrix type.">IsSquareMatrix</a> </dd></dl>

</div>
</div>
<a id="a9e64649a393ae84ea092662d18089732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e64649a393ae84ea092662d18089732">&#9670;&nbsp;</a></span>GetIdentityMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt;T&gt;::value, <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt;T, N, N&gt; &gt; playrho::GetIdentityMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the identity matrix of the template type and size. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Identity_matrix">https://en.wikipedia.org/wiki/Identity_matrix</a> </dd>
<dd>
<a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a" title="Generic M by N matrix.">Matrix</a>, <a class="el" href="structplayrho_1_1IsMatrix.html" title="Trait class for checking if type is a matrix type.">IsMatrix</a>, <a class="el" href="structplayrho_1_1IsSquareMatrix.html" title="Trait class for checking if type is a square matrix type.">IsSquareMatrix</a> </dd></dl>

</div>
</div>
<a id="aa4c22718accfc68e3baba71b3747a4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c22718accfc68e3baba71b3747a4ba">&#9670;&nbsp;</a></span>GetInvalid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a> playrho::GetInvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an invalid AABB value. </p>
<p>Gets an invalid value for the JointID type.</p>
<p>Gets an invalid value for the FixtureID type.</p>
<p>Gets an invalid value for the ContactID type.</p>
<p>Gets an invalid value for the BodyID type.</p>
<p>Gets an invalid value for the 3-element vector of real (<code>Vec3</code>) type.</p>
<p>Gets an invalid value for the <code>Vec2</code> type.</p>
<p>Gets an invalid value for the <code>UnitVec</code> type.</p>
<p>Gets an invalid value for the TypeID type.</p>
<p>Gets an invalid value for the std::size_t type.</p>
<p>Gets an invalid value for the long double type.</p>
<p>Gets an invalid value for the double type.</p>
<p>Gets an invalid value for the float type.</p>
<p>Gets an invalid value for the type.</p>
<p>Gets an invalid value for a <code>Mat22</code>.</p>
<p>Gets an invalid value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to get an invalid value for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Specialize this function for the types which have an invalid value concept. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ab903c93dd80fcff6148a66dbc7c89687" title="Gets whether the given manifold is valid.">IsValid</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="TargetJoint_8cpp-example.html#a14">TargetJoint.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9f5227d01d6f7c75ac2399c3da7b5572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5227d01d6f7c75ac2399c3da7b5572">&#9670;&nbsp;</a></span>GetMovementConf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a> GetMovementConf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the movement configuration from the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>The <code>maxTranslation</code> and <code>maxRotation</code> fields of the given value respectively are returned. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a78cad5bc045344c27000a93663cf36ae">playrho::d2::WorldImpl::SolveRegIslandViaGS()</a>, and <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a8bdf8dc97f575361394a47d4f53c0146">playrho::d2::WorldImpl::SolveToiViaGS()</a>.</p>

</div>
</div>
<a id="ad136f8db9fd6c0c583c1890b8a3cc504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136f8db9fd6c0c583c1890b8a3cc504">&#9670;&nbsp;</a></span>GetNumValidIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t playrho::GetNumValidIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of valid indices in the given collection of index pairs. </p>
<dl class="section note"><dt>Note</dt><dd>Any element with a value of <code>InvalidIndexPair</code> is interpreted as being invalid in this context. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Value between 0 and 3 inclusive. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a98ab78cb47da6f6d872d617cc66040a6">empty()</a>, and <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size()</a>.</p>

</div>
</div>
<a id="a0f5ae61330e0553509baa283129e8e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5ae61330e0553509baa283129e8e53">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T playrho::GetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the given interval. </p>
<p>Gets the difference between the max and min values. </p><dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if the difference between the given range's max and min values overflows the range of the <code><a class="el" href="classplayrho_1_1Interval.html#af3f2912d491535ecbe0f8b03da2357b7" title="Value type.">Interval::value_type</a></code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative value unless the given interval is "unset" or invalid. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1detail.html#a3f0de4fdd4cecf5567090bf345c42ead">playrho::detail::GetDimensions()</a>, and <a class="el" href="namespaceplayrho_1_1d2.html#ace87984d1541a40a6c850825acb43742">playrho::d2::GetPerimeter()</a>.</p>

</div>
</div>
<a id="a6514752c0838613cfaf76ea7e03581cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6514752c0838613cfaf76ea7e03581cd">&#9670;&nbsp;</a></span>IsAccelerable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool playrho::IsAccelerable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is "accelerable". </p>
<p>Whether or not the given type value is for a body which can have a non-zero acceleration associated with it. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given type value represents an "accelerable" type value, <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Would be nice if the Doxygen "relatedalso BodyType" command worked for this but seems that doesn't work for scoped enumeration. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893" title="Is &quot;speedable&quot;.">IsSpeedable(BodyType)</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a125">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#ac33af5ec304e45152ffb2d275ba5093c">playrho::d2::IsAccelerable()</a>.</p>

</div>
</div>
<a id="a76e2dcc5aeb221351e51ad965e9de893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e2dcc5aeb221351e51ad965e9de893">&#9670;&nbsp;</a></span>IsSpeedable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool playrho::IsSpeedable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is "speedable". </p>
<p>Whether or not the given type value is for a body which can have a non-zero speed associated with it. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given type value represents a "speedable" type value, <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Would be nice if the Doxygen "relatedalso BodyType" command worked for this but seems that doesn't work for scoped enumeration. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd" title="Is &quot;accelerable&quot;.">IsAccelerable(BodyType)</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a124">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a5a9a1e21b5e0f1b2200d902a3f577e6e">playrho::d2::IsSpeedable()</a>.</p>

</div>
</div>
<a id="a0fa02e6b0d55e9363ad4afb89a755fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa02e6b0d55e9363ad4afb89a755fc1">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>
<p>Determines whether the given vector contains finite coordinates. </p>

</div>
</div>
<a id="a7dde95b5e9b50eb6552368d0c57cfc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dde95b5e9b50eb6552368d0c57cfc88">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#aa4c22718accfc68e3baba71b3747a4ba" title="Gets an invalid AABB value.">GetInvalid</a>. </dd></dl>

</div>
</div>
<a id="a49e0e4246787f364251d07688fea46e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e0e4246787f364251d07688fea46e5">&#9670;&nbsp;</a></span>MakeUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;std::is_signed&lt;T&gt;::value, std::make_unsigned_t&lt;T&gt; &gt; playrho::MakeUnsigned </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the given <b>value</b> into an <b>unsigned value</b>. </p>
<dl class="section note"><dt>Note</dt><dd>If the given value is negative, this will result in an unsigned value which is the two's complement modulo-wrapped value. </dd>
<dd>
This is different from <code>std::make_unsigned</code> in that this changes the <b>value</b> to the value in the type that's the unsigned type equivalent of the input value. <code>std::make_unsigned</code> merely provides the unsigned <b>type</b> equivalent. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a3063d5a0619a13b6a4e9c7dd682d2b8c">playrho::d2::Count()</a>.</p>

</div>
</div>
<a id="ac32367e964a575ebee3ed45c8ddb0afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32367e964a575ebee3ed45c8ddb0afe">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::max_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> -&gt; decltype(pairs.max_size())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum size of the given container of index pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns 3. </dd></dl>

</div>
</div>
<a id="a50d46e6e45df1f7049decee120ce9922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d46e6e45df1f7049decee120ce9922">&#9670;&nbsp;</a></span>MixFriction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> playrho::MixFriction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>friction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>friction2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mixes friction. </p>
<p>Friction mixing formula. The idea is to allow either fixture to drive the resulting friction to zero. For example, anything slides on ice.</p>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is undefined if either friction values is less than zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">friction1</td><td>A zero or greater value. </td></tr>
    <tr><td class="paramname">friction2</td><td>A zero or greater value. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a6e6f412c2af9722fd3bc32527459feba">playrho::d2::GetDefaultFriction()</a>.</p>

</div>
</div>
<a id="abdd2574637d4c8869ae345d3975829cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd2574637d4c8869ae345d3975829cc">&#9670;&nbsp;</a></span>MixRestitution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> playrho::MixRestitution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>restitution1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>restitution2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mixes restitution. </p>
<p>Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface. For example, a super ball bounces on anything. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#ab39f3148c511e1a82d6d23701423da43">playrho::d2::GetDefaultRestitution()</a>.</p>

</div>
</div>
<a id="a0878dcd8f25150f77ebea43e908e3023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0878dcd8f25150f77ebea43e908e3023">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) != RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value inequality operator for value types which support it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af25888243d04857183fbff9a515bcbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25888243d04857183fbff9a515bcbfd">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) != rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value inequality operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861fb100d29d58d6f26f3767017886b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861fb100d29d58d6f26f3767017886b3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<dl class="section note"><dt>Note</dt><dd>Satisfies the <code>EqualityComparable</code> named requirement for <a class="el" href="classplayrho_1_1Interval.html" title="Interval template type.">Interval</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">https://en.cppreference.com/w/cpp/named_req/EqualityComparable</a> </dd></dl>

</div>
</div>
<a id="a2a6bef32507b31e3d1ae0935a6719e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6bef32507b31e3d1ae0935a6719e71">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator!= </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs != ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value inequality operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab695c5da4298cd1267ccb84710dc5dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab695c5da4298cd1267ccb84710dc5dc4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) * RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value multiplication operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a344c62fec7ff32c28d2a98fb3eff0cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344c62fec7ff32c28d2a98fb3eff0cee">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt;<a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt;ValueType, CheckerType&gt;, Other&gt;::value, decltype(ValueType()*Other())&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value multiplication operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14860a28f9b31d3c16987c19762c227a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14860a28f9b31d3c16987c19762c227a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator* </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;!<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt;Other, <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt;ValueType, CheckerType&gt;&gt;::value, decltype(Other()*ValueType())&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value multiplication operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab83592354f1ddb5b4c4a578b758e3b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83592354f1ddb5b4c4a578b758e3b6f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T1 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T1&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for non-vector times vector. </p>
<dl class="section note"><dt>Note</dt><dd>Explicitly disabled for <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> * <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> to prevent this function from existing in that case and prevent errors like "use of overloaded operator '*' is ambiguous". </dd></dl>

</div>
</div>
<a id="a026460fcdfec17743564ddb912641b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026460fcdfec17743564ddb912641b32">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt;T1, T2&gt;::value &amp;&amp; !<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt;T1&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;OT, B&gt; &gt; playrho::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, B &gt;, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies an A-element vector by a A-by-B vector of vectors. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm favors column major ordering of the vector of vectors. </dd>
<dd>
This treats the left-hand-side argument as though it's a 1-by-A vector of vectors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side vector treated as if it were of type: <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>&lt;Vector&lt;T1, A&gt;, 1&gt;</code>. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side vector of vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B-element vector product. </dd></dl>

</div>
</div>
<a id="a5954c938ca0d2ec534a155f7c1ea692d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5954c938ca0d2ec534a155f7c1ea692d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;<a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt;T1, T2&gt;::value &amp;&amp; !<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt;T2&gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;OT, B&gt; &gt; playrho::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt;, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a B-by-A vector of vectors by an A-element vector. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm favors row major ordering of the vector of vectors. </dd>
<dd>
This treats the right-hand-side argument as though it's an A-by-1 vector of vectors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side vector of vectors. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side vector treated as if it were of type: <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>&lt;Vector&lt;T2, 1&gt;, A&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B-element vector product. </dd></dl>

</div>
</div>
<a id="ab26c32a67232c258f6792be57799a485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26c32a67232c258f6792be57799a485">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, std::size_t C, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, C &gt;, A &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, B &gt;, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, C &gt;, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the matrix product of the two given vector of vectors (matrices). </p>
<p>Multiplies an A-by-B vector of vectors by a B-by-C vector of vectors returning an A-by-C vector of vectors. </p><dl class="section note"><dt>Note</dt><dd>From Wikipedia: <blockquote class="doxtable">
<p>Multiplication of two matrices is defined if and only if the number of columns of the left matrix is the same as the number of rows of the right matrix. </p>
</blockquote>
</dd>
<dd>
Matrix multiplication is not commutative. </dd>
<dd>
Algorithmically speaking, this implementation is called the "naive" algorithm. For small matrices, like 3-by-3 or smaller matrices, its complexity shouldn't be an issue. The matrix dimensions are compile time constants anyway which can help compilers automatically identify loop unrolling and hardware level parallelism opportunities. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side matrix. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A-by-C matrix product of the left-hand-side matrix and the right-hand-side matrix. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_multiplication">https://en.wikipedia.org/wiki/Matrix_multiplication</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm">https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Commutative_property">https://en.wikipedia.org/wiki/Commutative_property</a> </dd></dl>

</div>
</div>
<a id="acd667ff0c1d11b44e9ad19b06db6713e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd667ff0c1d11b44e9ad19b06db6713e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; <a class="el" href="structplayrho_1_1IsMultipliable.html">IsMultipliable</a>&lt; T1, T2 &gt;::value &amp;&amp;!<a class="el" href="structplayrho_1_1IsVector.html">IsVector</a>&lt; T2 &gt;::value, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for vector times non-vector. </p>
<dl class="section note"><dt>Note</dt><dd>Explicitly disabled for <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> * <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> to prevent this function from existing in that case and prevent errors like "use of overloaded operator '*' is ambiguous". </dd></dl>

</div>
</div>
<a id="ace19087d3c9f0e9cf7b83eb131626bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace19087d3c9f0e9cf7b83eb131626bee">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) + RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value addition operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a687d59516f156855de42eea778eccc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a687d59516f156855de42eea778eccc49">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) + rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value addition operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41f0c49a750ed51bb02cef10158e8d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0c49a750ed51bb02cef10158e8d7f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix addition operator for two same-type, same-sized matrices. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_addition">https://en.wikipedia.org/wiki/Matrix_addition</a> </dd></dl>

</div>
</div>
<a id="a75202d7d29b1ce5418c1ae4e32c95a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75202d7d29b1ce5418c1ae4e32c95a08">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator+ </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs + ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value addition operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa918349e3179ab2f97d04b41085d0a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa918349e3179ab2f97d04b41085d0a48">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) - RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value subtraction operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf1adc96b8c69fa7bb0ce08582f93de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1adc96b8c69fa7bb0ce08582f93de7">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) - rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value subtraction operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89118d71eeeffa541c76f6d566a8546d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89118d71eeeffa541c76f6d566a8546d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix subtraction operator for two same-type, same-sized matrices. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_addition">https://en.wikipedia.org/wiki/Matrix_addition</a> </dd></dl>

</div>
</div>
<a id="a5783466a0028f61a1e70076f410ac4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5783466a0028f61a1e70076f410ac4ee">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator- </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs - ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value subtraction operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a5b28003deb87e06a3c9e51f44fb096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5b28003deb87e06a3c9e51f44fb096">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) / RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value division operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21a68e7bc007582c16847ed8615d8c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a68e7bc007582c16847ed8615d8c26">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) / rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value division operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a740ddde1b6038fc20e0e763e0eabac6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740ddde1b6038fc20e0e763e0eabac6a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator/ </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs / ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value division operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e50b7f361b27adaf57e0b275b849cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e50b7f361b27adaf57e0b275b849cb2">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) &lt; RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value less-than operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9f2a8be4da1677e412b8eabc2146873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f2a8be4da1677e412b8eabc2146873">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) &lt; rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value less-than operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a815e65e38974a8bb60ef0a096bea0241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815e65e38974a8bb60ef0a096bea0241">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison. </dd>
<dd>
Obeys the <code>LessThanComparable</code> named requirement: <code>for all a, !(a &lt; a); if (a &lt; b) then !(b &lt; a); if (a &lt; b) and (b &lt; c) then (a &lt; c); with equiv = !(a &lt; b) &amp;&amp; !(b &lt; a), if equiv(a, b) and equiv(b, c), then equiv(a, c).</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd>
<dd>
<a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">https://en.cppreference.com/w/cpp/named_req/LessThanComparable</a> </dd></dl>

</div>
</div>
<a id="a6f64d5e0d888eb6813af5fa103a16b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f64d5e0d888eb6813af5fa103a16b16">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs &lt; ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value less-than operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc045bd4bbb560077978ce21cd20c49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc045bd4bbb560077978ce21cd20c49f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">::std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(os &lt;&lt; ValueType(value))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrained value stream output operator for value types which support it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17f5c3cf62f38463edf89ddc5bf05b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f5c3cf62f38463edf89ddc5bf05b80">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) &lt;= RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value less-than or equal-to operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e696d4bb8a0294762be3428301ebbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e696d4bb8a0294762be3428301ebbec">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) &lt;= rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value less-than or equal-to operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbf50e7e086182f69dc09e011aef6345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf50e7e086182f69dc09e011aef6345">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than or equal-to operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="a55fa5e47ada221e269711dbbf90eedd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fa5e47ada221e269711dbbf90eedd7">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs &lt;= ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value less-than or equal-to operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab21e9430d6c13f5645a8a5af6a64a23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21e9430d6c13f5645a8a5af6a64a23a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) == RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value equality operator for value types which support it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adafba64613de79315803f30e1c800aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adafba64613de79315803f30e1c800aad">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) == rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value equality operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1b97d7e2f5894048236948061068fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b97d7e2f5894048236948061068fb5">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="section note"><dt>Note</dt><dd>Satisfies the <code>EqualityComparable</code> named requirement for <a class="el" href="classplayrho_1_1Interval.html" title="Interval template type.">Interval</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">https://en.cppreference.com/w/cpp/named_req/EqualityComparable</a> </dd></dl>

</div>
</div>
<a id="aa8fc70d9f3c91ab4c9afb7730f920243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8fc70d9f3c91ab4c9afb7730f920243">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator== </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs == ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value equality operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab6a70eaafe3d414d9ebb561150a5ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6a70eaafe3d414d9ebb561150a5ae0">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) &gt; RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value greater-than operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b2ff344394e8157985fe636a85f18d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2ff344394e8157985fe636a85f18d9">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) &gt; rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value greater-than operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc58a55aab3f8bdd7ea411a6b2a4ddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc58a55aab3f8bdd7ea411a6b2a4ddfb">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="a6ea68ce25d18cda2a9a333fa224f0558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea68ce25d18cda2a9a333fa224f0558">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs &gt; ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value greater-than ooperator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c18729fd53f4bb5275874c8cd1eb644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c18729fd53f4bb5275874c8cd1eb644">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsValueType , typename LhsCheckerType , typename RhsValueType , typename RhsCheckerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; LhsValueType, LhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; RhsValueType, RhsCheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(LhsValueType(lhs) &gt;= RhsValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value greater-than or equal-to operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LhsValueType</td><td>Type of the value used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">LhsCheckerType</td><td>Type of the checker used by the left hand side checked value. </td></tr>
    <tr><td class="paramname">RhsValueType</td><td>Type of the value used by the right hand side checked value. </td></tr>
    <tr><td class="paramname">RhsCheckerType</td><td>Type of the checker used by the right hand side checked value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcb14439b5fd9f3daf2b518c786865b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb14439b5fd9f3daf2b518c786865b7">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(ValueType(lhs) &gt;= rhs)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value greater-than or equal-to operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca7f35c089808652f6c5d6c06a85ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca7f35c089808652f6c5d6c06a85ae7">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than or equal-to operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="a092ab700ddc3c1dba9a60a49ce75cf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092ab700ddc3c1dba9a60a49ce75cf6e">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename CheckerType , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1CheckedValue.html">CheckedValue</a>&lt; ValueType, CheckerType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(lhs &gt;= ValueType(rhs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrained value greater-than or equal-to operator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>Type of the value used by the checked value. </td></tr>
    <tr><td class="paramname">CheckerType</td><td>Type of the checker used by the checked value. </td></tr>
    <tr><td class="paramname">Other</td><td>Type of the other value that this operation will operator with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb651f620aefb4ee65ec0cc8c10b27b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb651f620aefb4ee65ec0cc8c10b27b0">&#9670;&nbsp;</a></span>Realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * playrho::Realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates memory. </p>
<dl class="section note"><dt>Note</dt><dd>One can change this function to use ones own memory allocator. Be sure to conform to this function's interface: throw a <code>std::bad_alloc</code> exception if unable to allocate non-zero sized memory, return a null pointer if the requested size is zero, and free old memory if the new size is zero. This is done to ensure that the behavior is not implementation defined unlike <code>std::realloc</code>. </dd>
<dd>
If the new size for memory is zero, then the old memory is freed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to reallocate non-zero sized memory. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if size is not zero else <code>nullptr</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f" title="Allocates memory.">Alloc</a>, <a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62">ReallocArray()</a>.</p>

</div>
</div>
<a id="a197482cbffdd702c8926a00f42a76e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197482cbffdd702c8926a00f42a76e62">&#9670;&nbsp;</a></span>ReallocArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* playrho::ReallocArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates memory for an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the old memory. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements to reallocate for. This value must be less than the value of <code>std::numeric_limits&lt;std::size_t&gt;::max() / sizeof(T)</code> or an exception will be thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the new size for memory is zero, then the old memory is freed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to reallocate non-zero sized memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if count is not zero else <code>nullptr</code>. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0" title="Reallocates memory.">Realloc</a>, <a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>. </dd></dl>

</div>
</div>
<a id="af33cf35b33c93168aedcbf5a986a3472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33cf35b33c93168aedcbf5a986a3472">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices</a>(pairs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dynamic size of the given collection of index pairs. </p>
<dl class="section note"><dt>Note</dt><dd>This just calls <code>GetNumValidIndices</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504" title="Gets the number of valid indices in the given collection of index pairs.">GetNumValidIndices</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f">Alloc()</a>, <a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">AllocArray()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#abbb25555e5d25ed67a4748136ff7b8ed">playrho::BlockAllocator::Allocate()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a1ecbcaa8d549ffa1522e7128fc8a684d">playrho::StackAllocator::Allocate()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a1902b15365c55a19c21e9103565e3447">playrho::StackAllocator::AllocateArray()</a>, <a class="el" href="group__Math.html#ga8b2133f1c2e5299035bb059d2d2706cd">Average()</a>, <a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">ComputeCentroid()</a>, <a class="el" href="group__Math.html#ga451c8554a408d41df85a41650e0ada93">Dot()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a06536ee49cdb1a8c2f79de7522c8bd33">playrho::BlockAllocator::Free()</a>, <a class="el" href="classplayrho_1_1d2_1_1ConvexHull.html#a678ba0811f2975d1cdba6bfca49005eb">playrho::d2::ConvexHull::Get()</a>, <a class="el" href="group__Math.html#ga118f8284073d2638e48ef8f13177e1d9">GetAreaOfPolygon()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a5aa7655c98fb927d7bc7a2fc936ec6cc">playrho::BlockAllocator::GetMaxBlockSize()</a>, <a class="el" href="group__Math.html#ga760adfdd1cb30bdae8cd37c1ae5da485">GetPolarMoment()</a>, <a class="el" href="namespaceplayrho_1_1detail.html#a9c6ef61517707043fb5fd0891647687f">playrho::detail::IsFull()</a>, <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">Realloc()</a>, and <a class="el" href="namespaceplayrho_1_1detail.html#aa36e925a21b13b0e209f0d29e350ac83">playrho::detail::Size()</a>.</p>

</div>
</div>
<a id="abcf5bea73a392ad1b2be520e79fb9b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf5bea73a392ad1b2be520e79fb9b4a">&#9670;&nbsp;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::to_underlying </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceplayrho.html#a79f10d34cd7e0d7f7cbbafb638373818">underlying_type_t</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given value to the value as the underlying type. </p>
<dl class="section note"><dt>Note</dt><dd>This is like <code>std::to_underlying</code> slated for C++23. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a00e1689252447eae1fc374d630695a6a">playrho::d2::WorldImpl::Add()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ac9241a3a232d68e75e21f35113801a5e">playrho::d2::WorldImpl::AddContactsToIsland()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a90ea4abd1ebff7927eeb6902e6ca5111">playrho::d2::WorldImpl::AddFixture()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a79152907de292bae25ebb6416163c161">playrho::d2::WorldImpl::AddJointsToIsland()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a0ee4c488eef9a3c16977b7fc06b5dceb">playrho::d2::WorldImpl::AddToIsland()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a344ffe5766a20bea9c69eaeae76f0907">playrho::d2::At()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a45766f0643fca6561f909b896f02822e">playrho::d2::WorldImpl::Clear()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ae5fe49982bfae5ec82d52e1a895fbd49">playrho::d2::WorldImpl::CreateAndDestroyProxies()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a5c2c258e0632e2daa11c2f5e042eaa99">playrho::d2::WorldImpl::CreateFixture()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a497b22f2480ab65cf01ad56a76143721">playrho::d2::WorldImpl::Destroy()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a202439718913778688275f902686b76b">playrho::d2::WorldImpl::DestroyContacts()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a32fd07d852bd60f0ecfd793ea04bc2ba">playrho::d2::WorldImpl::GetBody()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a87742d5f6c76e4b5a53270f09b5c5909">playrho::d2::WorldImpl::GetContact()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a7f85b891a2c3595523855ab218d9e5fd">playrho::d2::WorldImpl::GetContacts()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ad78400b236d1d09294647aa8c3eab67c">playrho::d2::WorldImpl::GetFixture()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a042ecf583acbbc7911f6cc6cbc73dab3">playrho::d2::WorldImpl::GetFixtures()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a11f1f4638eefbf9bb7a23b7c92fafaec">playrho::d2::WorldImpl::GetJoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ad7be6bf064faf9d79d27284a92f36ad5">playrho::d2::WorldImpl::GetJoints()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a680d31c2afa68a9775bc9c993bbb3516">playrho::d2::WorldImpl::GetManifold()</a>, <a class="el" href="namespaceplayrho.html#a470dc644f20793cbc54ed79ad49fb491">GetName()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#aeafd25182ffe4017f95e6098afc59528">playrho::d2::VelocityConstraint::GetPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a11ae988a8f6f65fbabc1f7cb05ae7512">playrho::d2::WorldImpl::GetProxies()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a94672b3b074267dea80f38ea49cba7e2">playrho::d2::WorldImpl::GetSoonestContact()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ae007d8ebcdf237028b261cd99053f54a">playrho::d2::WorldImpl::InternalDestroy()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a9143a09221070b4ab01fb51460e2d63a">playrho::d2::WorldImpl::IsDestroyed()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ac04cfc5657ac89627f1fef0a700f385b">playrho::d2::WorldImpl::ProcessContactsForTOI()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#aca772cb9784a4d8e72f876441314f996">playrho::d2::WorldImpl::Remove()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a56c74cc1b1f084b2d2c9e7fa139b1bc9">playrho::d2::WorldImpl::RemoveFixture()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#af8ea7267009619b52281753e5eae0c29">playrho::d2::WorldImpl::RemoveUnspeedablesFromIslanded()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a41cc43a409194b7cbab845f8bae69f95">playrho::d2::WorldImpl::SetBody()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a75f903a4325ba025c7dbf458c415a90d">playrho::d2::WorldImpl::SetContact()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a6eddde22e7f0dbdb461a2c0a6c17fc21">playrho::d2::WorldImpl::SetFixture()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ab2e58310b1aba79de5640ae920b2ebeb">playrho::d2::WorldImpl::SetJoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a1d280b15a6d77c374c2515363c16cf28">playrho::d2::WorldImpl::ShiftOrigin()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ad713a4babfc5defee138076b69dc372d">playrho::d2::WorldImpl::SolveReg()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a78cad5bc045344c27000a93663cf36ae">playrho::d2::WorldImpl::SolveRegIslandViaGS()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a470ba039f845cd981e31584f37c1f1bf">playrho::d2::WorldImpl::SolveToi()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a8bdf8dc97f575361394a47d4f53c0146">playrho::d2::WorldImpl::SolveToiViaGS()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a61684b789cd63a2f0293c9caae9db832">playrho::d2::WorldImpl::Synchronize()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#aa30a33558a9a9753b84fe65fca9068ba">playrho::d2::WorldImpl::SynchronizeProxies()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#aebd7935e321a9f4beaabe0dc49e56641">playrho::d2::WorldImpl::Update()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ae196693ff57c316f63922e0ab78f1f4b">playrho::d2::WorldImpl::UpdateContacts()</a>, and <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a5c38917b15d28c3a98a2b84d121dbbb2">playrho::d2::WorldImpl::UpdateContactTOIs()</a>.</p>

</div>
</div>
<a id="a8d1619f9e02f66414371891d25a1275f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1619f9e02f66414371891d25a1275f">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1ArrayAllocator.html">ArrayAllocator</a>&lt;T&gt;::size_type playrho::used </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1ArrayAllocator.html">ArrayAllocator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of elements that are used in the specified structure. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of the specified structure minus the size of its free pool. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a210eeeb89b4ff7264efa8b687da8b8d0">playrho::d2::WorldImpl::SolveToi()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a31907e80be5889667f03ef86ee3bbf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31907e80be5889667f03ef86ee3bbf0a">&#9670;&nbsp;</a></span>DefaultAngularSleepTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultAngularSleepTolerance = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{(<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2) / 180} * <a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default angular sleep tolerance. </p>
<p>A body cannot sleep if its angular velocity is above this amount. </p>

</div>
</div>
<a id="adfccbc3cd8cc0bb78701f62e041acdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfccbc3cd8cc0bb78701f62e041acdba">&#9670;&nbsp;</a></span>DefaultAngularSlop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultAngularSlop = (<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2_rad) / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{180}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default angular slop. </p>
<p>A small angle used as a collision and constraint tolerance. Usually it is chosen to be numerically significant, but visually insignificant. </p>

</div>
</div>
<a id="ac12a28e4c1a2b9138c79d895d3ccb3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12a28e4c1a2b9138c79d895d3ccb3aa">&#9670;&nbsp;</a></span>DefaultCirclesRatio</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultCirclesRatio = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{10}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default circles ratio. </p>
<p>Ratio used for switching between rounded-corner collisions and closest-face biased normal collisions. </p>

</div>
</div>
<a id="a490b0d336b7a74ae18cf57632eeb7aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490b0d336b7a74ae18cf57632eeb7aa9">&#9670;&nbsp;</a></span>DefaultLinearSleepTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultLinearSleepTolerance = 0.01_mps</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default linear sleep tolerance. </p>
<p>A body cannot sleep if the magnitude of its linear velocity is above this amount. </p>

</div>
</div>
<a id="ad91e53ba44755653e34147d39695a0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91e53ba44755653e34147d39695a0a1">&#9670;&nbsp;</a></span>DefaultLinearSlop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultLinearSlop = <a class="el" href="structplayrho_1_1detail_1_1Defaults.html">detail::Defaults</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::GetLinearSlop()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default linear slop. </p>
<p>Length used as a collision and constraint tolerance. Usually chosen to be numerically significant, but visually insignificant. Lower or raise to decrease or increase respectively the minimum of space between bodies at rest. </p><dl class="section note"><dt>Note</dt><dd>Smaller values relative to sizes of bodies increases the time it takes for bodies to come to rest. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1DiskShapeConf.html#a694ac3d77cd84cc54f765097f79d6b4c">playrho::d2::DiskShapeConf::GetDefaultRadius()</a>, <a class="el" href="classplayrho_1_1d2_1_1ChainShapeConf.html#abbd9e21a6b8f40b76a2d9efa021126d1">playrho::d2::ChainShapeConf::GetDefaultVertexRadius()</a>, <a class="el" href="classplayrho_1_1d2_1_1EdgeShapeConf.html#a2440d2d407850714f6a96134a8cca0fb">playrho::d2::EdgeShapeConf::GetDefaultVertexRadius()</a>, <a class="el" href="structplayrho_1_1d2_1_1MultiShapeConf.html#a3cb8f8d56c034235091425bdf4fb7288">playrho::d2::MultiShapeConf::GetDefaultVertexRadius()</a>, <a class="el" href="classplayrho_1_1d2_1_1PolygonShapeConf.html#a9805448b8c4a41d0f97f89b6f461eda3">playrho::d2::PolygonShapeConf::GetDefaultVertexRadius()</a>, and <a class="el" href="classplayrho_1_1d2_1_1PolygonShapeConf.html#a0f0f7f5c1e7813f0fddfbec61f67fab6">playrho::d2::PolygonShapeConf::Set()</a>.</p>

</div>
</div>
<a id="ac8fea4a93f741aa800e943957fd23656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fea4a93f741aa800e943957fd23656">&#9670;&nbsp;</a></span>DefaultMaxAngularCorrection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxAngularCorrection = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(8.0f / 180.0f) * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 1_rad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum angular correction. </p>
<dl class="section note"><dt>Note</dt><dd>This value should be greater than the angular slop value. </dd></dl>

</div>
</div>
<a id="aa7d2cfbedb9200e2ed973eb18cc3b23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d2cfbedb9200e2ed973eb18cc3b23b">&#9670;&nbsp;</a></span>DefaultMaxLinearCorrection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxLinearCorrection = 0.2_m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum linear correction. </p>
<p>The maximum linear position correction used when solving constraints. This helps to prevent overshoot. </p><dl class="section note"><dt>Note</dt><dd>This value should be greater than the linear slop value. </dd></dl>

</div>
</div>
<a id="a36c3a1adc34421b07e930a06ce905db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c3a1adc34421b07e930a06ce905db1">&#9670;&nbsp;</a></span>DefaultMaxRotation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxRotation = <a class="el" href="group__PhysicalQuantities.html#gab999341c050df340ff56a65816a63da9">Angle</a>{<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 1_rad / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(2)}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum rotation per world step. </p>
<dl class="section warning"><dt>Warning</dt><dd>This value should be less than Pi * Radian. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This limit is meant to prevent numerical problems. Adjusting this value isn't advised. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structplayrho_1_1StepConf.html#a0ab48d76f772682e5d2d2d937eacdde4" title="Maximum rotation.">StepConf::maxRotation</a>. </dd></dl>

</div>
</div>
<a id="aa678e38c906502e06a90f31e2acc952a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa678e38c906502e06a90f31e2acc952a">&#9670;&nbsp;</a></span>DefaultMaxSubSteps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxSubSteps = std::uint8_t{8}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum number of sub steps. </p>
<p>This is the default maximum number of sub-steps per contact in continuous physics simulation. In other words, this is the default maximum number of times in a world step that a contact will have continuous collision resolution done for it. </p><dl class="section note"><dt>Note</dt><dd>Used in the TOI phase of step processing. </dd></dl>

</div>
</div>
<a id="a0e76508577c61a5bc9cc3107d60f3c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e76508577c61a5bc9cc3107d60f3c1b">&#9670;&nbsp;</a></span>DefaultMinStillTimeToSleep</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMinStillTimeToSleep = <a class="el" href="group__PhysicalQuantities.html#ga250898c9929b0e6eaf56a1967c568888">Time</a>{1_s / 2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default minimum still time to sleep. </p>
<p>The default minimum time bodies must be still for bodies to be put to sleep. </p>

</div>
</div>
<a id="a1a7a2c4f0ce447813c94060e1ea4c0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7a2c4f0ce447813c94060e1ea4c0f9">&#9670;&nbsp;</a></span>InvalidContactID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidContactID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span>ContactID::underlying_type<span class="keyword">&gt;</span>(-1))</div>
</div><!-- fragment -->
<p>Invalid contact ID value. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a16d79d6bcaf6a2c59f269d8587b83c72">playrho::d2::WorldImpl::Destroy()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a94672b3b074267dea80f38ea49cba7e2">playrho::d2::WorldImpl::GetSoonestContact()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#ae007d8ebcdf237028b261cd99053f54a">playrho::d2::WorldImpl::InternalDestroy()</a>, and <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a470ba039f845cd981e31584f37c1f1bf">playrho::d2::WorldImpl::SolveToi()</a>.</p>

</div>
</div>
<a id="ad7fdab88f7f4e1fdf64360e3d9501fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fdab88f7f4e1fdf64360e3d9501fa1">&#9670;&nbsp;</a></span>InvalidFixtureID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidFixtureID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceplayrho.html#aeb0ae1f76104ef8214134a5be96027f6">FixtureID</a><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span>FixtureID::underlying_type<span class="keyword">&gt;</span>(-1))</div>
</div><!-- fragment -->
<p>Invalid fixture ID value. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DistanceJoint_8cpp-example.html#a36">DistanceJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#a47">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a25">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6fb9d11a6fadb62b0e68aee9797059ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb9d11a6fadb62b0e68aee9797059ad">&#9670;&nbsp;</a></span>InvalidIndexPair</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidIndexPair</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>{</div>
<div class="line">    <a class="code" href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">InvalidVertex</a>, <a class="code" href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">InvalidVertex</a></div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Invalid index-pair value. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::Distance()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a70613779e152f647af4f80dce352d83c">playrho::d2::GetIndexPairs()</a>, and <a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices()</a>.</p>

</div>
</div>
<a id="ae6388dedf49acce87859ad2e9bd3e2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6388dedf49acce87859ad2e9bd3e2cc">&#9670;&nbsp;</a></span>InvalidIndexPair3</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidIndexPair3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>{{</div>
<div class="line">    <a class="code" href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">InvalidIndexPair</a>, <a class="code" href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">InvalidIndexPair</a>, <a class="code" href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">InvalidIndexPair</a></div>
<div class="line">}}</div>
</div><!-- fragment -->
<p>Invalid array of three index-pair elements. </p>

</div>
</div>
<a id="ab8f0b15d8cf3a0f200c50fc8bc6c4e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f0b15d8cf3a0f200c50fc8bc6c4e08">&#9670;&nbsp;</a></span>InvalidTypeID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidTypeID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span>TypeID::underlying_type<span class="keyword">&gt;</span>(<span class="keyword">nullptr</span>))</div>
</div><!-- fragment -->
<p>Invalid type ID value. </p>

</div>
</div>
<a id="a7b821c4b23566defba0fd2917d95f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b821c4b23566defba0fd2917d95f0ba">&#9670;&nbsp;</a></span>MaxBodies</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxBodies</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div>
<div class="line">                                                      std::uint16_t{1})</div>
</div><!-- fragment -->
<p>Maximum number of bodies in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a139">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a0ee4c488eef9a3c16977b7fc06b5dceb">playrho::d2::WorldImpl::AddToIsland()</a>, and <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a56f095fe60a50b47f9aa2f3d6664e3f2">playrho::d2::WorldImpl::CreateBody()</a>.</p>

</div>
</div>
<a id="a5ac18ab5fe22782c56d7ab92b397468e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac18ab5fe22782c56d7ab92b397468e">&#9670;&nbsp;</a></span>MaxContacts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxContacts = <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>} * <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a> - 1} / <a class="el" href="namespaceplayrho.html#a2bf0674233f83e8b83b30db98332e129">ContactCounter</a>{2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of contacts in a world (2147319811). </p>
<p>Uses the formula for the maximum number of edges in an unidirectional graph of <code>MaxBodies</code> nodes. This occurs when every possible body is connected to every other body. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a7ef29daf86837d7a5db8333064299230">playrho::d2::WorldImpl::Add()</a>.</p>

</div>
</div>
<a id="af36288c4602f14acd96242145a546980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36288c4602f14acd96242145a546980">&#9670;&nbsp;</a></span>MaxFixtures</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxFixtures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div>
<div class="line">                                                        std::uint16_t{1u})</div>
</div><!-- fragment -->
<p>Maximum number of fixtures in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a5c2c258e0632e2daa11c2f5e042eaa99">playrho::d2::WorldImpl::CreateFixture()</a>.</p>

</div>
</div>
<a id="a69cde8c9e938d138a9a4ae8355501684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cde8c9e938d138a9a4ae8355501684">&#9670;&nbsp;</a></span>MaxJoints</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxJoints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div>
<div class="line">                                                      std::uint16_t{1})</div>
</div><!-- fragment -->
<p>Maximum number of joints in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a141">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1WorldImpl.html#a3dbfa1501f8c3051e3cf96bc2304c3cb">playrho::d2::WorldImpl::CreateJoint()</a>.</p>

</div>
</div>
<a id="aae670387c8f37f8812082b1838e18863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae670387c8f37f8812082b1838e18863">&#9670;&nbsp;</a></span>MaxManifoldPoints</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxManifoldPoints = std::uint8_t{2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum manifold points. This is the maximum number of contact points between two convex shapes. Do not change this value. </p>
<dl class="section note"><dt>Note</dt><dd>For memory efficiency, uses the smallest integral type that can hold the value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1ContactImpulsesList.html#a10582ed9bfbe1061650b20acbaa3787f">playrho::d2::ContactImpulsesList::AddEntry()</a>, <a class="el" href="classplayrho_1_1d2_1_1Manifold.html#a1399ecf9d6951ca8b72dd34dc66d1e75">playrho::d2::Manifold::AddPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#ab527a8be9240a5b922a87e4b3ebf91c3">playrho::d2::VelocityConstraint::AddPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a82d672d8bf598bf27a746423392b72b3">playrho::d2::WorldManifold::GetImpulses()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a4872f3b8f5ec291a4e2d8324829f82b6">playrho::d2::WorldManifold::GetPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#a0522810720f80c9e976e069aaca09cf4">playrho::d2::VelocityConstraint::GetPointAt()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a0e20bfa57459aa27c74c57043b822bd0">playrho::d2::WorldManifold::GetSeparation()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#a5087e20abce45986f04d23834de5f8f3">playrho::d2::VelocityConstraint::PointAt()</a>, and <a class="el" href="classplayrho_1_1d2_1_1Manifold.html#a477022edb23b761024a659e533098047">playrho::d2::Manifold::SetPointImpulses()</a>.</p>

</div>
</div>
<a id="a0774f630ff2e5b9ed9e5f322700d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0774f630ff2e5b9ed9e5f322700d44e4">&#9670;&nbsp;</a></span>MaxShapeVertices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxShapeVertices = std::uint8_t{254}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of vertices for any shape type. </p>
<dl class="section note"><dt>Note</dt><dd>For memory efficiency, uses the smallest integral type that can hold the value minus one that's left out as a sentinel value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#ad3851d0c3b764c9fe4dbaad8268ea201">playrho::d2::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="a3fe0bdbb0ea9c449b7504f7c75840993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe0bdbb0ea9c449b7504f7c75840993">&#9670;&nbsp;</a></span>Pi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Pi = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(3.14159265358979323846264338327950288)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pi. </p>
<p>An "irrational number" that's defined as the ratio of a circle's circumference to its diameter.</p>
<dl class="section note"><dt>Note</dt><dd>While the include file definition of M_PI may be a POSIX compliance requirement and initially attractive to use, it's apparently not a C++ standards requirement and casually including it pollutes the name space of all code that uses this library. Whatever the case, MSVC 2017 doesn't make it part of the <code>cmath</code> include without enabling <code>_USE_MATH_DEFINES</code>. So rather than add yet more C preprocessor macros to all sources that this library may be compiled with, it's simply hard-coded in here instead using a C++ mechanism that also keeps it with the enclosing name space. </dd>
<dd>
Any narrowing is intentional.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Pi">https://en.wikipedia.org/wiki/Pi</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a136">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga0eb57dabfe8d3db9e509a6b493173358">GetAreaOfCircle()</a>, <a class="el" href="group__Math.html#ga3b8e8abc999b0c63cf1921b0edcf0b36">GetCircleVertices()</a>, <a class="el" href="group__Math.html#ga8c036532db1260373b97c1d85360894c">GetDelta()</a>, <a class="el" href="classplayrho_1_1d2_1_1ChainShapeConf.html#a212282d094f3bb26c9182f72eac6319d">playrho::d2::ChainShapeConf::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a9b3b93dcaddc83a77e35b87b54960d5e">playrho::d2::GetMassData()</a>, <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">GetNormalized()</a>, and <a class="el" href="namespaceplayrho_1_1d2.html#af55559c8bf6c930582040cf3321b691f">playrho::d2::InitVelocity()</a>.</p>

</div>
</div>
<a id="aae1bd392cbafcb91d60633c893ff0742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1bd392cbafcb91d60633c893ff0742">&#9670;&nbsp;</a></span>SquareRootTwo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::SquareRootTwo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1.414213562373095048801688724209698078569671875376948073176679737990732478462)</div>
</div><!-- fragment -->
<p>Square root of two. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Square_root_of_2">https://en.wikipedia.org/wiki/Square_root_of_2</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html#ad253c43a96160cfccf89cf650abd225e">playrho::d2::UnitVec::GetBottomRight()</a>, and <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html#a1e841cb8279292e8fbaf0d83b4cd0ddb">playrho::d2::UnitVec::GetTopRight()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceplayrho_html_a704da3b24d9b1f9135e140dcd5420518"><div class="ttname"><a href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">playrho::IndexPair3</a></div><div class="ttdeci">std::array&lt; IndexPair, MaxSimplexEdges &gt; IndexPair3</div><div class="ttdoc">Array of three index-pair elements.</div><div class="ttdef"><b>Definition:</b> IndexPair.hpp:47</div></div>
<div class="ttc" id="anamespaceplayrho_html_a6fb9d11a6fadb62b0e68aee9797059ad"><div class="ttname"><a href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">playrho::InvalidIndexPair</a></div><div class="ttdeci">constexpr auto InvalidIndexPair</div><div class="ttdoc">Invalid index-pair value.</div><div class="ttdef"><b>Definition:</b> IndexPair.hpp:39</div></div>
<div class="ttc" id="anamespaceplayrho_html_a7d449e0a1528c10ae0f241713fb69b40"><div class="ttname"><a href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">playrho::IndexPair</a></div><div class="ttdeci">std::pair&lt; VertexCounter, VertexCounter &gt; IndexPair</div><div class="ttdoc">Index pair.</div><div class="ttdef"><b>Definition:</b> IndexPair.hpp:36</div></div>
<div class="ttc" id="anamespaceplayrho_html_abe7a48a3a0e57fa1a9dd9e396b6b24f7"><div class="ttname"><a href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">playrho::ContactID</a></div><div class="ttdeci">detail::IndexingNamedType&lt; ContactCounter, struct ContactIdentifier &gt; ContactID</div><div class="ttdoc">Contact identifier.</div><div class="ttdef"><b>Definition:</b> ContactID.hpp:30</div></div>
<div class="ttc" id="anamespaceplayrho_html_aeb0ae1f76104ef8214134a5be96027f6"><div class="ttname"><a href="namespaceplayrho.html#aeb0ae1f76104ef8214134a5be96027f6">playrho::FixtureID</a></div><div class="ttdeci">detail::IndexingNamedType&lt; FixtureCounter, struct FixtureIdentifier &gt; FixtureID</div><div class="ttdoc">Fixture identifier.</div><div class="ttdef"><b>Definition:</b> FixtureID.hpp:30</div></div>
<div class="ttc" id="anamespaceplayrho_html_a1fc125070a08100d083a1360f7167f87"><div class="ttname"><a href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">playrho::Real</a></div><div class="ttdeci">float Real</div><div class="ttdoc">Real-number type.</div><div class="ttdef"><b>Definition:</b> Real.hpp:69</div></div>
<div class="ttc" id="anamespaceplayrho_html_a922c3472852863ed46d7551b1dd8ba9d"><div class="ttname"><a href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">playrho::TypeID</a></div><div class="ttdeci">detail::IndexingNamedType&lt; const char *const *, struct TypeIdentifier &gt; TypeID</div><div class="ttdoc">Type identifier.</div><div class="ttdef"><b>Definition:</b> TypeInfo.hpp:91</div></div>
<div class="ttc" id="anamespaceplayrho_html_a49c511e18a6b72260126cf763c1cd8df"><div class="ttname"><a href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">playrho::InvalidVertex</a></div><div class="ttdeci">constexpr auto InvalidVertex</div><div class="ttdoc">Invalid vertex index.</div><div class="ttdef"><b>Definition:</b> Settings.hpp:125</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceplayrho.html">playrho</a></li>
    <li class="footer">Generated on Sat Apr 24 2021 12:19:35 for PlayRho by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
