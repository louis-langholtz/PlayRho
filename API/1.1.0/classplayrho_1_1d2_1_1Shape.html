<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PlayRho: playrho::d2::Shape Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlayRho
   &#160;<span id="projectnumber">1.1.0</span>
   </div>
   <div id="projectbrief">An Interactive Real-Time-Oriented C++ Physics Engine &amp; Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classplayrho_1_1d2_1_1Shape.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classplayrho_1_1d2_1_1Shape-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">playrho::d2::Shape Class Reference<div class="ingroups"><a class="el" href="group__PartsGroup.html">Shape Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classplayrho_1_1d2_1_1Shape.html" title="Shape.">Shape</a>.  
 <a href="classplayrho_1_1d2_1_1Shape.html#details">More...</a></p>

<p><code>#include &lt;Shape.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for playrho::d2::Shape:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classplayrho_1_1d2_1_1Shape__coll__graph.svg" width="184" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Concept.html">Concept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal configuration concept.  <a href="structplayrho_1_1d2_1_1Shape_1_1Concept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html">Model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal model configuration concept.  <a href="structplayrho_1_1d2_1_1Shape_1_1Model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb58ed48e6319ee154511d7cf777cc65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#abb58ed48e6319ee154511d7cf777cc65">Shape</a> () noexcept=default</td></tr>
<tr class="memdesc:abb58ed48e6319ee154511d7cf777cc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classplayrho_1_1d2_1_1Shape.html#abb58ed48e6319ee154511d7cf777cc65">More...</a><br /></td></tr>
<tr class="separator:abb58ed48e6319ee154511d7cf777cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4115a5df86a7d55dd2bc6b2a550ade6b"><td class="memItemLeft" align="right" valign="top"><a id="a4115a5df86a7d55dd2bc6b2a550ade6b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a4115a5df86a7d55dd2bc6b2a550ade6b">Shape</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;other)=default</td></tr>
<tr class="memdesc:a4115a5df86a7d55dd2bc6b2a550ade6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a4115a5df86a7d55dd2bc6b2a550ade6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e2bdf92a75c20cd217306b8eca737"><td class="memItemLeft" align="right" valign="top"><a id="a3b3e2bdf92a75c20cd217306b8eca737"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a3b3e2bdf92a75c20cd217306b8eca737">Shape</a> (<a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a3b3e2bdf92a75c20cd217306b8eca737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a3b3e2bdf92a75c20cd217306b8eca737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f403b88ce9b5418b70a1cafd83f327"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tp  = DecayedTypeIfNotSelf&lt;T&gt;, typename  = std::enable_if_t&lt;std::is_copy_constructible&lt;Tp&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a62f403b88ce9b5418b70a1cafd83f327"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a62f403b88ce9b5418b70a1cafd83f327">Shape</a> (T &amp;&amp;arg)</td></tr>
<tr class="memdesc:a62f403b88ce9b5418b70a1cafd83f327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializing constructor.  <a href="classplayrho_1_1d2_1_1Shape.html#a62f403b88ce9b5418b70a1cafd83f327">More...</a><br /></td></tr>
<tr class="separator:a62f403b88ce9b5418b70a1cafd83f327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae45d39c259d86a251a19183e56e703"><td class="memItemLeft" align="right" valign="top"><a id="afae45d39c259d86a251a19183e56e703"></a>
<a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#afae45d39c259d86a251a19183e56e703">operator=</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;other)=default</td></tr>
<tr class="memdesc:afae45d39c259d86a251a19183e56e703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:afae45d39c259d86a251a19183e56e703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbee1b56e39a192551950a196bb8b6be"><td class="memItemLeft" align="right" valign="top"><a id="acbee1b56e39a192551950a196bb8b6be"></a>
<a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#acbee1b56e39a192551950a196bb8b6be">operator=</a> (<a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:acbee1b56e39a192551950a196bb8b6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:acbee1b56e39a192551950a196bb8b6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a076ce927458c2b43f6c3b21706cf3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tp  = DecayedTypeIfNotSelf&lt;T&gt;, typename  = std::enable_if_t&lt;std::is_copy_constructible&lt;Tp&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a08a076ce927458c2b43f6c3b21706cf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a08a076ce927458c2b43f6c3b21706cf3">operator=</a> (T &amp;&amp;other)</td></tr>
<tr class="memdesc:a08a076ce927458c2b43f6c3b21706cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classplayrho_1_1d2_1_1Shape.html#a08a076ce927458c2b43f6c3b21706cf3">More...</a><br /></td></tr>
<tr class="separator:a08a076ce927458c2b43f6c3b21706cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cf8a6770b252e74335895bc5e2cdcc"><td class="memItemLeft" align="right" valign="top"><a id="a63cf8a6770b252e74335895bc5e2cdcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a63cf8a6770b252e74335895bc5e2cdcc">swap</a> (<a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a63cf8a6770b252e74335895bc5e2cdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap support. <br /></td></tr>
<tr class="separator:a63cf8a6770b252e74335895bc5e2cdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca717d0407529c53735c9b71df6a3b87"><td class="memItemLeft" align="right" valign="top"><a id="aca717d0407529c53735c9b71df6a3b87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aca717d0407529c53735c9b71df6a3b87">has_value</a> () const noexcept</td></tr>
<tr class="memdesc:aca717d0407529c53735c9b71df6a3b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this instance contains a value. <br /></td></tr>
<tr class="separator:aca717d0407529c53735c9b71df6a3b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:af291fdd001874a50febb300fcbed228f"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename DecayedType  = std::decay_t&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:af291fdd001874a50febb300fcbed228f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#af291fdd001874a50febb300fcbed228f">DecayedTypeIfNotSelf</a> = std::enable_if_t&lt;!std::is_same_v&lt; DecayedType, <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &gt;, DecayedType &gt;</td></tr>
<tr class="memdesc:af291fdd001874a50febb300fcbed228f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decayed type if not same as this class.  <a href="classplayrho_1_1d2_1_1Shape.html#af291fdd001874a50febb300fcbed228f">More...</a><br /></td></tr>
<tr class="separator:af291fdd001874a50febb300fcbed228f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aed8187741a62d95d0d6e0ab657fed045"><td class="memItemLeft" align="right" valign="top"><a id="aed8187741a62d95d0d6e0ab657fed045"></a>
std::shared_ptr&lt; const <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Concept.html">Concept</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aed8187741a62d95d0d6e0ab657fed045">m_self</a></td></tr>
<tr class="memdesc:aed8187741a62d95d0d6e0ab657fed045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self pointer. <br /></td></tr>
<tr class="separator:aed8187741a62d95d0d6e0ab657fed045"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac04194136cade2a9cb3db0ce6234b3fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#ac04194136cade2a9cb3db0ce6234b3fc">GetChildCount</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape) noexcept</td></tr>
<tr class="memdesc:ac04194136cade2a9cb3db0ce6234b3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of child primitives of the shape.  <a href="classplayrho_1_1d2_1_1Shape.html#ac04194136cade2a9cb3db0ce6234b3fc">More...</a><br /></td></tr>
<tr class="separator:ac04194136cade2a9cb3db0ce6234b3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5a495e8d68c39d47d049f51ec5452f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html">DistanceProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aef5a495e8d68c39d47d049f51ec5452f">GetChild</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape, <a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a> index)</td></tr>
<tr class="memdesc:aef5a495e8d68c39d47d049f51ec5452f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "child" for the given index.  <a href="classplayrho_1_1d2_1_1Shape.html#aef5a495e8d68c39d47d049f51ec5452f">More...</a><br /></td></tr>
<tr class="separator:aef5a495e8d68c39d47d049f51ec5452f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9e8db270c93956369ac55920c462d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho_1_1d2.html#a1afff43f96a91b8c26b8f0de7b9a71da">MassData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a1f9e8db270c93956369ac55920c462d7">GetMassData</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape) noexcept</td></tr>
<tr class="memdesc:a1f9e8db270c93956369ac55920c462d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mass properties of this shape using its dimensions and density.  <a href="classplayrho_1_1d2_1_1Shape.html#a1f9e8db270c93956369ac55920c462d7">More...</a><br /></td></tr>
<tr class="separator:a1f9e8db270c93956369ac55920c462d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d425ca5951dc633c1a63d5449091871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a9d425ca5951dc633c1a63d5449091871">GetVertexRadius</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape, <a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a> idx)</td></tr>
<tr class="memdesc:a9d425ca5951dc633c1a63d5449091871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex radius of the indexed child of the given shape.  <a href="classplayrho_1_1d2_1_1Shape.html#a9d425ca5951dc633c1a63d5449091871">More...</a><br /></td></tr>
<tr class="separator:a9d425ca5951dc633c1a63d5449091871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7391adc084afda958cdb54b10229990c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a7391adc084afda958cdb54b10229990c">GetFriction</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape) noexcept</td></tr>
<tr class="memdesc:a7391adc084afda958cdb54b10229990c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the coefficient of friction.  <a href="classplayrho_1_1d2_1_1Shape.html#a7391adc084afda958cdb54b10229990c">More...</a><br /></td></tr>
<tr class="separator:a7391adc084afda958cdb54b10229990c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab731ba8dc3b08ed048d5348def3f0ab6"><td class="memItemLeft" align="right" valign="top"><a id="ab731ba8dc3b08ed048d5348def3f0ab6"></a>
<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#ab731ba8dc3b08ed048d5348def3f0ab6">GetRestitution</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape) noexcept</td></tr>
<tr class="memdesc:ab731ba8dc3b08ed048d5348def3f0ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the coefficient of restitution value of the given shape. <br /></td></tr>
<tr class="separator:ab731ba8dc3b08ed048d5348def3f0ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154958fa91ee5653a279fc28e1472ab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a154958fa91ee5653a279fc28e1472ab8">GetDensity</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape) noexcept</td></tr>
<tr class="memdesc:a154958fa91ee5653a279fc28e1472ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the density of the given shape.  <a href="classplayrho_1_1d2_1_1Shape.html#a154958fa91ee5653a279fc28e1472ab8">More...</a><br /></td></tr>
<tr class="separator:a154958fa91ee5653a279fc28e1472ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5affc9e0eb1efb455e629467b34f12fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a5affc9e0eb1efb455e629467b34f12fd">Transform</a> (<a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;m)</td></tr>
<tr class="memdesc:a5affc9e0eb1efb455e629467b34f12fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms all of the given shape's vertices by the given transformation matrix.  <a href="classplayrho_1_1d2_1_1Shape.html#a5affc9e0eb1efb455e629467b34f12fd">More...</a><br /></td></tr>
<tr class="separator:a5affc9e0eb1efb455e629467b34f12fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3ae4694d7e8995f4500e9a84e25046"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a2b3ae4694d7e8995f4500e9a84e25046">GetData</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape) noexcept</td></tr>
<tr class="memdesc:a2b3ae4694d7e8995f4500e9a84e25046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to the underlying data.  <a href="classplayrho_1_1d2_1_1Shape.html#a2b3ae4694d7e8995f4500e9a84e25046">More...</a><br /></td></tr>
<tr class="separator:a2b3ae4694d7e8995f4500e9a84e25046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0874edd64ea7ae7e3dc4a49f88cd15f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aa0874edd64ea7ae7e3dc4a49f88cd15f">GetType</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape) noexcept</td></tr>
<tr class="memdesc:aa0874edd64ea7ae7e3dc4a49f88cd15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type info of the use of the given shape.  <a href="classplayrho_1_1d2_1_1Shape.html#aa0874edd64ea7ae7e3dc4a49f88cd15f">More...</a><br /></td></tr>
<tr class="separator:aa0874edd64ea7ae7e3dc4a49f88cd15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f0e014fb16e6493ff6fb297d6a726a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26f0e014fb16e6493ff6fb297d6a726a"><td class="memTemplItemLeft" align="right" valign="top">std::add_pointer_t&lt; std::add_const_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a26f0e014fb16e6493ff6fb297d6a726a">TypeCast</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> *value) noexcept</td></tr>
<tr class="memdesc:a26f0e014fb16e6493ff6fb297d6a726a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given shape into its current configuration value.  <a href="classplayrho_1_1d2_1_1Shape.html#a26f0e014fb16e6493ff6fb297d6a726a">More...</a><br /></td></tr>
<tr class="separator:a26f0e014fb16e6493ff6fb297d6a726a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab78335ce5150860eca7156ef23cc6c4"><td class="memItemLeft" align="right" valign="top"><a id="aab78335ce5150860eca7156ef23cc6c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aab78335ce5150860eca7156ef23cc6c4">operator==</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;lhs, const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aab78335ce5150860eca7156ef23cc6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator for shape to shape comparisons. <br /></td></tr>
<tr class="separator:aab78335ce5150860eca7156ef23cc6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8725ac7fabaac950fabc413b492da29e"><td class="memItemLeft" align="right" valign="top"><a id="a8725ac7fabaac950fabc413b492da29e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a8725ac7fabaac950fabc413b492da29e">operator!=</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;lhs, const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8725ac7fabaac950fabc413b492da29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator for shape to shape comparisons. <br /></td></tr>
<tr class="separator:a8725ac7fabaac950fabc413b492da29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a74afc15ef58efc35461a1580887e5363"><td class="memItemLeft" align="right" valign="top"><a id="a74afc15ef58efc35461a1580887e5363"></a>
<a class="el" href="namespaceplayrho_1_1d2.html#abfb3031d97cbdac7eb72cccf26e3c694">AABB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a74afc15ef58efc35461a1580887e5363">ComputeAABB</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape, const <a class="el" href="structplayrho_1_1d2_1_1Transformation.html">Transformation</a> &amp;xf) noexcept</td></tr>
<tr class="memdesc:a74afc15ef58efc35461a1580887e5363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the AABB for the given shape with the given transformation. <br /></td></tr>
<tr class="separator:a74afc15ef58efc35461a1580887e5363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada5f6c5635166baaf1bc81636d8b93a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho_1_1d2.html#a44ee8d7d4fd7ea935b7d952f7834027f">RayCastOutput</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RayCastGroup.html#gaada5f6c5635166baaf1bc81636d8b93a">RayCast</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape, <a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a> childIndex, const <a class="el" href="namespaceplayrho_1_1d2.html#adf053dc4cae3fabb24f6e3c8b8697ffb">RayCastInput</a> &amp;input, const <a class="el" href="structplayrho_1_1d2_1_1Transformation.html">Transformation</a> &amp;transform) noexcept</td></tr>
<tr class="memdesc:gaada5f6c5635166baaf1bc81636d8b93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a ray against the child of the given shape.  <a href="group__RayCastGroup.html#gaada5f6c5635166baaf1bc81636d8b93a">More...</a><br /></td></tr>
<tr class="separator:gaada5f6c5635166baaf1bc81636d8b93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcfbf811dc989043838f0a4c7c64b59b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestPointGroup.html#gafcfbf811dc989043838f0a4c7c64b59b">TestPoint</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;shape, <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> point) noexcept</td></tr>
<tr class="memdesc:gafcfbf811dc989043838f0a4c7c64b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a point for containment in the given shape.  <a href="group__TestPointGroup.html#gafcfbf811dc989043838f0a4c7c64b59b">More...</a><br /></td></tr>
<tr class="separator:gafcfbf811dc989043838f0a4c7c64b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2552f9d7b9b8d2c5cf4b5ef71140b709"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2552f9d7b9b8d2c5cf4b5ef71140b709"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classplayrho_1_1d2_1_1Shape.html#a2552f9d7b9b8d2c5cf4b5ef71140b709">TypeCast</a> (const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;value)</td></tr>
<tr class="memdesc:a2552f9d7b9b8d2c5cf4b5ef71140b709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts the specified instance into the template specified type.  <a href="classplayrho_1_1d2_1_1Shape.html#a2552f9d7b9b8d2c5cf4b5ef71140b709">More...</a><br /></td></tr>
<tr class="separator:a2552f9d7b9b8d2c5cf4b5ef71140b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classplayrho_1_1d2_1_1Shape.html" title="Shape.">Shape</a>. </p>
<p>A shape is used for collision detection. You can create a shape from any supporting type. Shapes are conceptually made up of zero or more convex child shapes where each child shape is made up of zero or more vertices and an associated radius called its "vertex radius". </p><dl class="section note"><dt>Note</dt><dd>This class's design provides a "polymorphic value type" offering polymorphism without public inheritance. This is based on a technique that's described by Sean Parent in his January 2017 Norwegian Developers Conference London talk "Better Code: Runtime
  Polymorphism". With this implementation, different shapes types can be had by constructing instances of this class with the different types that provide the required support. Different shapes of a given type meanwhile are had by providing different values for the type. </dd>
<dd>
A shape can be constructor from or have its value set to any value whose type <code>T</code> has at least the following function definitions available for it:<ul>
<li><code>bool operator==(const T&amp; lhs, const T&amp; rhs) noexcept;</code></li>
<li><code>ChildCounter GetChildCount(const T&amp;) noexcept;</code></li>
<li><code><a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html" title="Distance Proxy.">DistanceProxy</a> GetChild(const T&amp;, ChildCounter index);</code></li>
<li><code>MassData GetMassData(const T&amp;) noexcept;</code></li>
<li><code>NonNegative&lt;Length&gt; GetVertexRadius(const T&amp;, ChildCounter idx);</code></li>
<li><code>NonNegative&lt;AreaDensity&gt; GetDensity(const T&amp;) noexcept;</code></li>
<li><code>Real GetFriction(const T&amp;) noexcept;</code></li>
<li><code>Real GetRestitution(const T&amp;) noexcept;</code></li>
<li><code>void Transform(T&amp;, const Mat22&amp; value);</code></li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structplayrho_1_1d2_1_1FixtureConf.html" title="Fixture definition.">FixtureConf</a> </dd>
<dd>
<a href="https://youtu.be/QGcVXgEVMJg">https://youtu.be/QGcVXgEVMJg</a> </dd>
<dd>
<a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Polymorphic_Value_Types">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Polymorphic_Value_Types</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DistanceJoint_8cpp-example.html#_a31">DistanceJoint.cpp</a>, <a class="el" href="FrictionJoint_8cpp-example.html#_a24">FrictionJoint.cpp</a>, <a class="el" href="GearJoint_8cpp-example.html#_a26">GearJoint.cpp</a>, <a class="el" href="HelloWorld_8cpp-example.html#_a5">HelloWorld.cpp</a>, <a class="el" href="MotorJoint_8cpp-example.html#_a29">MotorJoint.cpp</a>, <a class="el" href="PrismaticJoint_8cpp-example.html#_a71">PrismaticJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#_a41">RevoluteJoint.cpp</a>, <a class="el" href="RopeJoint_8cpp-example.html#_a22">RopeJoint.cpp</a>, <a class="el" href="Shape_8cpp-example.html#_a0">Shape.cpp</a>, <a class="el" href="WeldJoint_8cpp-example.html#_a28">WeldJoint.cpp</a>, <a class="el" href="WheelJoint_8cpp-example.html#_a58">WheelJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#_a45">World.cpp</a>, <a class="el" href="WorldBody_8cpp-example.html#_a22">WorldBody.cpp</a>, <a class="el" href="WorldContact_8cpp-example.html#_a8">WorldContact.cpp</a>, and <a class="el" href="WorldFixture_8cpp-example.html#_a4">WorldFixture.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af291fdd001874a50febb300fcbed228f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af291fdd001874a50febb300fcbed228f">&#9670;&nbsp;</a></span>DecayedTypeIfNotSelf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename DecayedType  = std::decay_t&lt;Type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classplayrho_1_1d2_1_1Shape.html#af291fdd001874a50febb300fcbed228f">playrho::d2::Shape::DecayedTypeIfNotSelf</a> =  std::enable_if_t&lt;!std::is_same_v&lt;DecayedType, <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a>&gt;, DecayedType&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decayed type if not same as this class. </p>
<dl class="section note"><dt>Note</dt><dd>This is done separately from other checks to ensure order of compiler's SFINAE processing and to ensure elimination of self class before attempting to process other checks like is_copy_constructible. This prevents a compiler error that started showing up in gcc-9. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb58ed48e6319ee154511d7cf777cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb58ed48e6319ee154511d7cf777cc65">&#9670;&nbsp;</a></span>Shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">playrho::d2::Shape::Shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aca717d0407529c53735c9b71df6a3b87" title="Checks whether this instance contains a value.">has_value()</a></code> returns false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Shape.html#a08a076ce927458c2b43f6c3b21706cf3">operator=()</a>.</p>

</div>
</div>
<a id="a62f403b88ce9b5418b70a1cafd83f327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f403b88ce9b5418b70a1cafd83f327">&#9670;&nbsp;</a></span>Shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tp  = DecayedTypeIfNotSelf&lt;T&gt;, typename  = std::enable_if_t&lt;std::is_copy_constructible&lt;Tp&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">playrho::d2::Shape::Shape </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializing constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Configuration value to construct a shape instance for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>See the class notes section for an explanation of requirements on a type <code>T</code> for its values to be valid candidates for this function. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aca717d0407529c53735c9b71df6a3b87" title="Checks whether this instance contains a value.">has_value()</a></code> returns true. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there's a failure allocating storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08a076ce927458c2b43f6c3b21706cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a076ce927458c2b43f6c3b21706cf3">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tp  = DecayedTypeIfNotSelf&lt;T&gt;, typename  = std::enable_if_t&lt;std::is_copy_constructible&lt;Tp&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a>&amp; playrho::d2::Shape::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aca717d0407529c53735c9b71df6a3b87" title="Checks whether this instance contains a value.">has_value()</a></code> returns true. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aef5a495e8d68c39d47d049f51ec5452f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5a495e8d68c39d47d049f51ec5452f">&#9670;&nbsp;</a></span>GetChild</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html">DistanceProxy</a> GetChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the "child" for the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td><a class="el" href="classplayrho_1_1d2_1_1Shape.html" title="Shape.">Shape</a> to get "child" shape of. </td></tr>
    <tr><td class="paramname">index</td><td>Index to a child element of the shape. Value must be less than the number of child primitives of the shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The shape must remain in scope while the proxy is in use. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplayrho_1_1InvalidArgument.html" title="Invalid argument logic error.">InvalidArgument</a></td><td>if the given index is out of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classplayrho_1_1d2_1_1Shape.html#ac04194136cade2a9cb3db0ce6234b3fc" title="Gets the number of child primitives of the shape.">GetChildCount</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html#a8dfe5bc2e335cd35c9ea5f5d32dfcc9c">playrho::d2::Shape::Model&lt; T &gt;::GetChild_()</a>.</p>

</div>
</div>
<a id="ac04194136cade2a9cb3db0ce6234b3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04194136cade2a9cb3db0ce6234b3fc">&#9670;&nbsp;</a></span>GetChildCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a> GetChildCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of child primitives of the shape. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-negative count. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html#a44e7fc4b6dd5660bcfb11414f288c94f">playrho::d2::Shape::Model&lt; T &gt;::GetChildCount_()</a>.</p>

</div>
</div>
<a id="a2b3ae4694d7e8995f4500e9a84e25046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3ae4694d7e8995f4500e9a84e25046">&#9670;&nbsp;</a></span>GetData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* GetData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to the underlying data. </p>
<dl class="section note"><dt>Note</dt><dd>Provided for introspective purposes like visitation. </dd></dl>

</div>
</div>
<a id="a154958fa91ee5653a279fc28e1472ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154958fa91ee5653a279fc28e1472ab8">&#9670;&nbsp;</a></span>GetDensity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga534c92a63631b49d1e80119a68af8a4a">AreaDensity</a>&gt; GetDensity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the density of the given shape. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-negative density (in mass per area). </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html#aed2ff471344e2b88b54f5ac98083fcd8">playrho::d2::Shape::Model&lt; T &gt;::GetDensity_()</a>.</p>

</div>
</div>
<a id="a7391adc084afda958cdb54b10229990c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7391adc084afda958cdb54b10229990c">&#9670;&nbsp;</a></span>GetFriction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> GetFriction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the coefficient of friction. </p>
<dl class="section return"><dt>Returns</dt><dd>Value of 0 or higher. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html#a74dba1ac19345274dd2bbc8a2052fba5">playrho::d2::Shape::Model&lt; T &gt;::GetFriction_()</a>.</p>

</div>
</div>
<a id="a1f9e8db270c93956369ac55920c462d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9e8db270c93956369ac55920c462d7">&#9670;&nbsp;</a></span>GetMassData</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho_1_1d2.html#a1afff43f96a91b8c26b8f0de7b9a71da">MassData</a> GetMassData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the mass properties of this shape using its dimensions and density. </p>
<dl class="section return"><dt>Returns</dt><dd>Mass data for this shape. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html#a37d395a1bce1c10d82aeef07d94c4273">playrho::d2::Shape::Model&lt; T &gt;::GetMassData_()</a>.</p>

</div>
</div>
<a id="aa0874edd64ea7ae7e3dc4a49f88cd15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0874edd64ea7ae7e3dc4a49f88cd15f">&#9670;&nbsp;</a></span>GetType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a922c3472852863ed46d7551b1dd8ba9d">TypeID</a> GetType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the type info of the use of the given shape. </p>
<dl class="section note"><dt>Note</dt><dd>This is not the same as calling <code><a class="el" href="namespaceplayrho.html#ad45e948cf36b820a949cc0a915e12c6c" title="Gets the type ID for the template parameter type.">GetTypeID&lt;Shape&gt;()</a></code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Type info of the underlying value's type. </dd></dl>

</div>
</div>
<a id="a9d425ca5951dc633c1a63d5449091871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d425ca5951dc633c1a63d5449091871">&#9670;&nbsp;</a></span>GetVertexRadius</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CheckedValues.html#gac74ec9c65c8f22cefed941aa486af9e3">NonNegative</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga7361ef2e10e7853a05b64aa433651014">Length</a>&gt; GetVertexRadius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#aed352724e203ca09595faf0dc6a76e5c">ChildCounter</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the vertex radius of the indexed child of the given shape. </p>
<p>This gets the radius from the vertex that the shape's "skin" should extend outward by. While any edges - line segments between multiple vertices - are straight, corners between them (the vertices) are rounded and treated as rounded. Shapes with larger vertex radiuses compared to edge lengths therefore will be more prone to rolling or having other shapes more prone to roll off of them. Here's an image of a shape configured via a <code><a class="el" href="classplayrho_1_1d2_1_1PolygonShapeConf.html" title="Polygon shape configuration.">PolygonShapeConf</a></code> with it's skin drawn: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td><a class="el" href="classplayrho_1_1d2_1_1Shape.html" title="Shape.">Shape</a> to get child's vertex radius for. </td></tr>
    <tr><td class="paramname">idx</td><td>Child index to get vertex radius for. <div class="image">
<img src="SkinnedPolygon.png" alt=""/>
</div>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This must be a non-negative value. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>UseVertexRadius </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplayrho_1_1InvalidArgument.html" title="Invalid argument logic error.">InvalidArgument</a></td><td>if the child index is not less than the child count. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html#a005f9550517d42ae20fa72b90e69f200">playrho::d2::Shape::Model&lt; T &gt;::GetVertexRadius_()</a>.</p>

</div>
</div>
<a id="a5affc9e0eb1efb455e629467b34f12fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5affc9e0eb1efb455e629467b34f12fd">&#9670;&nbsp;</a></span>Transform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms all of the given shape's vertices by the given transformation matrix. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Transformation_matrix">https://en.wikipedia.org/wiki/Transformation_matrix</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This may throw <code>std::bad_alloc</code> or any exception that's thrown by the constructor for the model's underlying data type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there's a failure allocating storage. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Shape_1_1Model.html#a1c9c6a6d9dcb8d314f36cdd6e7216d59">playrho::d2::Shape::Model&lt; T &gt;::Transform_()</a>.</p>

</div>
</div>
<a id="a2552f9d7b9b8d2c5cf4b5ef71140b709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2552f9d7b9b8d2c5cf4b5ef71140b709">&#9670;&nbsp;</a></span>TypeCast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T TypeCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts the specified instance into the template specified type. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_cast</td><td>If the template specified type is not the type of data underlying the given instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classplayrho_1_1d2_1_1Shape.html#aa0874edd64ea7ae7e3dc4a49f88cd15f" title="Gets the type info of the use of the given shape.">GetType(const Shape&amp;)</a> </dd></dl>

</div>
</div>
<a id="a26f0e014fb16e6493ff6fb297d6a726a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f0e014fb16e6493ff6fb297d6a726a">&#9670;&nbsp;</a></span>TypeCast <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::add_pointer_t&lt;std::add_const_t&lt;T&gt; &gt; TypeCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a> *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given shape into its current configuration value. </p>
<dl class="section note"><dt>Note</dt><dd>The design for this was based off the design of the C++17 <code>std::any</code> class and its associated <code>std::any_cast</code> function. The code for this is based off of the <code>std::any</code> code from the LLVM Project. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://llvm.org/">https://llvm.org/</a> </dd>
<dd>
<a class="el" href="classplayrho_1_1d2_1_1Shape.html#aa0874edd64ea7ae7e3dc4a49f88cd15f" title="Gets the type info of the use of the given shape.">GetType(const Shape&amp;)</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Shape.hpp</li>
<li>AABB.hpp</li>
<li>RayCastOutput.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceplayrho.html">playrho</a></li><li class="navelem"><a class="el" href="namespaceplayrho_1_1d2.html">d2</a></li><li class="navelem"><a class="el" href="classplayrho_1_1d2_1_1Shape.html">Shape</a></li>
    <li class="footer">Generated on Sat Apr 24 2021 12:19:36 for PlayRho by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
