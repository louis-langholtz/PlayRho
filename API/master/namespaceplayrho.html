<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PlayRho: playrho Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlayRho
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">An interactive physics engine &amp; library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceplayrho.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">playrho Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceplayrho_1_1d2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho_1_1d2.html">d2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplayrho_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplayrho_1_1pmr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho_1_1pmr.html">pmr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array list.  <a href="classplayrho_1_1ArrayList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1BlockDeallocator.html">BlockDeallocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block deallocator.  <a href="structplayrho_1_1BlockDeallocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint solver configuration data.  <a href="structplayrho_1_1ConstraintSolverConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Contact.html">Contact</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A potential contact between the children of two body associated shapes.  <a href="classplayrho_1_1Contact.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Contactable.html">Contactable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate data for identifying one side (of two) in a contact.  <a href="structplayrho_1_1Contactable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The contact feature.  <a href="structplayrho_1_1ContactFeature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key value class for contacts.  <a href="classplayrho_1_1ContactKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1DynamicTreeBranchData.html">DynamicTreeBranchData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branch data of a tree node.  <a href="structplayrho_1_1DynamicTreeBranchData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1DynamicTreeUnusedData.html">DynamicTreeUnusedData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unused data of a tree node.  <a href="structplayrho_1_1DynamicTreeUnusedData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionplayrho_1_1DynamicTreeVariantData.html">DynamicTreeVariantData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant data.  <a href="unionplayrho_1_1DynamicTreeVariantData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A holder for contact filtering data.  <a href="structplayrho_1_1Filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1FlagGuard.html">FlagGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag guard type.  <a href="classplayrho_1_1FlagGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1GrowableStack.html">GrowableStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classplayrho_1_1Interval.html" title="Interval template type.">Interval</a> template type.  <a href="classplayrho_1_1Interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1InvalidArgument.html">InvalidArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid argument logic error.  <a href="classplayrho_1_1InvalidArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Island.html">Island</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a self-contained constraint "island".  <a href="structplayrho_1_1Island.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1IslandStats.html">IslandStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Island.html" title="Definition of a self-contained constraint &quot;island&quot;.">Island</a> solver statistics.  <a href="structplayrho_1_1IslandStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1LengthError.html">LengthError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length based logic error.  <a href="classplayrho_1_1LengthError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LengthIndexPair.html">LengthIndexPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A length associated with two vertex counter indices.  <a href="structplayrho_1_1LengthIndexPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalGreater.html">LexicographicalGreater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical greater-than comparisons of containers.  <a href="structplayrho_1_1LexicographicalGreater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalGreaterEqual.html">LexicographicalGreaterEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical greater-than or equal-to comparisons of containers.  <a href="structplayrho_1_1LexicographicalGreaterEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalLess.html">LexicographicalLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical less-than comparisons of containers.  <a href="structplayrho_1_1LexicographicalLess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1LexicographicalLessEqual.html">LexicographicalLessEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object for performing lexicographical less-than or equal-to comparisons of containers.  <a href="structplayrho_1_1LexicographicalLessEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Movement configuration.  <a href="structplayrho_1_1MovementConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ObjectPool.html">ObjectPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object pool with indexable properties.  <a href="classplayrho_1_1ObjectPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1PreStepStats.html">PreStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre-phase per-step statistics.  <a href="structplayrho_1_1PreStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1propagate__const.html">propagate_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant propagating template wrapper type.  <a href="classplayrho_1_1propagate__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular-phase per-step statistics.  <a href="structplayrho_1_1RegStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ReversionWrapper.html">ReversionWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for reversing ranged-for loop ordering.  <a href="structplayrho_1_1ReversionWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1Span.html">Span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An encapsulation of an array and its size.  <a href="classplayrho_1_1Span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1StackAllocator.html">StackAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1StepConf.html">StepConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Step configuration.  <a href="structplayrho_1_1StepConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1StepStats.html">StepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-step statistics.  <a href="structplayrho_1_1StepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1ThreadLocalAllocator.html">ThreadLocalAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread local "stateless" allocator.  <a href="classplayrho_1_1ThreadLocalAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ToiConf.html">ToiConf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time of impact configuration.  <a href="structplayrho_1_1ToiConf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ToiOutput.html">ToiOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output data for time of impact.  <a href="structplayrho_1_1ToiOutput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1ToiStepStats.html">ToiStepStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TOI-phase per-step statistics.  <a href="structplayrho_1_1ToiStepStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1TypeID.html">TypeID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type identifier.  <a href="classplayrho_1_1TypeID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Vector.html">Vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>.  <a href="structplayrho_1_1Vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplayrho_1_1Version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Version.html" title="Version numbering scheme.">Version</a> numbering scheme.  <a href="structplayrho_1_1Version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplayrho_1_1WrongState.html">WrongState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrong state logic error.  <a href="classplayrho_1_1WrongState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabb35ed422281bfdf3c41a276958898fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a4d1bc56caf9abb64fdb8d1dd180d7394">detail::plane_angle</a></td></tr>
<tr class="memdesc:gabb35ed422281bfdf3c41a276958898fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angle quantity.  <a href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">More...</a><br /></td></tr>
<tr class="separator:gabb35ed422281bfdf3c41a276958898fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240f19679aa74a8999d4093089351f22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga240f19679aa74a8999d4093089351f22">AngularAcceleration</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a097ed777e057559e1843beed7f261053">detail::angular_acceleration</a></td></tr>
<tr class="memdesc:ga240f19679aa74a8999d4093089351f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular acceleration quantity.  <a href="group__PhysicalQuantities.html#ga240f19679aa74a8999d4093089351f22">More...</a><br /></td></tr>
<tr class="separator:ga240f19679aa74a8999d4093089351f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747a451cf2286bc935336043c212b74d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga747a451cf2286bc935336043c212b74d">AngularMomentum</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a368271e29c9ca2fa4a81619932918883">detail::angular_momentum</a></td></tr>
<tr class="memdesc:ga747a451cf2286bc935336043c212b74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular momentum quantity.  <a href="group__PhysicalQuantities.html#ga747a451cf2286bc935336043c212b74d">More...</a><br /></td></tr>
<tr class="separator:ga747a451cf2286bc935336043c212b74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4603a98e526262c2e4adfe99510672"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga8b4603a98e526262c2e4adfe99510672">AngularVelocity</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a57bc0b9cfe8671823ac510034a03cc0c">detail::angular_velocity</a></td></tr>
<tr class="memdesc:ga8b4603a98e526262c2e4adfe99510672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular velocity quantity.  <a href="group__PhysicalQuantities.html#ga8b4603a98e526262c2e4adfe99510672">More...</a><br /></td></tr>
<tr class="separator:ga8b4603a98e526262c2e4adfe99510672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga708ceb55bdc6043d445776d1886802eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a9eb7643b1171765729a3cd3129e8ec71">detail::area</a></td></tr>
<tr class="memdesc:ga708ceb55bdc6043d445776d1886802eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area quantity.  <a href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">More...</a><br /></td></tr>
<tr class="separator:ga708ceb55bdc6043d445776d1886802eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bcf1d1de9ef60a9833c222efe7ffd57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga6bcf1d1de9ef60a9833c222efe7ffd57">AreaDensity</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a5d70a4f74cac574d76e8dfcfee292895">detail::surface_density</a></td></tr>
<tr class="memdesc:ga6bcf1d1de9ef60a9833c222efe7ffd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Area (surface) density quantity.  <a href="group__PhysicalQuantities.html#ga6bcf1d1de9ef60a9833c222efe7ffd57">More...</a><br /></td></tr>
<tr class="separator:ga6bcf1d1de9ef60a9833c222efe7ffd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261b3039a098762462a17164898bb647"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a261b3039a098762462a17164898bb647">BodyCounter</a> = std::remove_const_t&lt; decltype(<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>)&gt;</td></tr>
<tr class="memdesc:a261b3039a098762462a17164898bb647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count type for bodies.  <a href="namespaceplayrho.html#a261b3039a098762462a17164898bb647">More...</a><br /></td></tr>
<tr class="separator:a261b3039a098762462a17164898bb647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d094e8b19ea714a079a48c336abad92"><td class="memItemLeft" align="right" valign="top"><a id="a9d094e8b19ea714a079a48c336abad92"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#a261b3039a098762462a17164898bb647">BodyCounter</a>, struct BodyIdentifier &gt;</td></tr>
<tr class="memdesc:a9d094e8b19ea714a079a48c336abad92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strongly typed identifier for bodies within <code>World</code> instances. <br /></td></tr>
<tr class="separator:a9d094e8b19ea714a079a48c336abad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e937a573db2db27b95156590ef5dd12"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0e937a573db2db27b95156590ef5dd12">ChildCounter</a> = std::remove_const_t&lt; decltype(<a class="el" href="namespaceplayrho.html#af33623a59b7c701aead6d06e88dc2cc6">MaxChildCount</a>)&gt;</td></tr>
<tr class="memdesc:a0e937a573db2db27b95156590ef5dd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Child counter type.  <a href="namespaceplayrho.html#a0e937a573db2db27b95156590ef5dd12">More...</a><br /></td></tr>
<tr class="separator:a0e937a573db2db27b95156590ef5dd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd824505590e2ca67e0ef804ede6e34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a> = <a class="el" href="namespaceplayrho.html#a0d090b6b86609a8e93cb933b2b223e63">WiderType</a>&lt; <a class="el" href="namespaceplayrho.html#a261b3039a098762462a17164898bb647">BodyCounter</a> &gt;</td></tr>
<tr class="memdesc:a5fd824505590e2ca67e0ef804ede6e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count type for contacts.  <a href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">More...</a><br /></td></tr>
<tr class="separator:a5fd824505590e2ca67e0ef804ede6e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7a48a3a0e57fa1a9dd9e396b6b24f7"><td class="memItemLeft" align="right" valign="top"><a id="abe7a48a3a0e57fa1a9dd9e396b6b24f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>, struct ContactIdentifier &gt;</td></tr>
<tr class="memdesc:abe7a48a3a0e57fa1a9dd9e396b6b24f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strongly typed identifier of contacts within <code>World</code> instances. <br /></td></tr>
<tr class="separator:abe7a48a3a0e57fa1a9dd9e396b6b24f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26feaced5599b43b28c4de2a2f861b4"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Check , typename DecayedType  = std::decay_t&lt;Type&gt;&gt; </td></tr>
<tr class="memitem:ad26feaced5599b43b28c4de2a2f861b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad26feaced5599b43b28c4de2a2f861b4">DecayedTypeIfNotSame</a> = std::enable_if_t&lt;!std::is_same_v&lt; DecayedType, Check &gt;, DecayedType &gt;</td></tr>
<tr class="memdesc:ad26feaced5599b43b28c4de2a2f861b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decayed type if not same as the checked type.  <a href="namespaceplayrho.html#ad26feaced5599b43b28c4de2a2f861b4">More...</a><br /></td></tr>
<tr class="separator:ad26feaced5599b43b28c4de2a2f861b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b77ef4b74a0e14a9d2f7cea193b2245"><td class="memItemLeft" align="right" valign="top"><a id="a1b77ef4b74a0e14a9d2f7cea193b2245"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1b77ef4b74a0e14a9d2f7cea193b2245">DynamicTreeSize</a> = <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a></td></tr>
<tr class="memdesc:a1b77ef4b74a0e14a9d2f7cea193b2245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic tree size type. <br /></td></tr>
<tr class="separator:a1b77ef4b74a0e14a9d2f7cea193b2245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e4df9fe0eb8c6732b0316face647ad"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga60e4df9fe0eb8c6732b0316face647ad"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga60e4df9fe0eb8c6732b0316face647ad">Finite</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1FiniteChecker.html">detail::FiniteChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga60e4df9fe0eb8c6732b0316face647ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finite constrained value type. <br /></td></tr>
<tr class="separator:ga60e4df9fe0eb8c6732b0316face647ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4898ce94c2c3bd2059864e7466ed12"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5c4898ce94c2c3bd2059864e7466ed12"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga5c4898ce94c2c3bd2059864e7466ed12">FiniteFF</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1FiniteChecker.html">detail::FiniteChecker</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="memdesc:ga5c4898ce94c2c3bd2059864e7466ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing finite constrained value type. <br /></td></tr>
<tr class="separator:ga5c4898ce94c2c3bd2059864e7466ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51dd88ec6a5b3bf384dc89a63019d9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gad51dd88ec6a5b3bf384dc89a63019d9d">Force</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a9245466a701c0ace6d5c9ee85826a254">detail::force</a></td></tr>
<tr class="memdesc:gad51dd88ec6a5b3bf384dc89a63019d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force quantity.  <a href="group__PhysicalQuantities.html#gad51dd88ec6a5b3bf384dc89a63019d9d">More...</a><br /></td></tr>
<tr class="separator:gad51dd88ec6a5b3bf384dc89a63019d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d09dc7b51321c052b071485357ca1f9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">Force2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gad51dd88ec6a5b3bf384dc89a63019d9d">Force</a> &gt;</td></tr>
<tr class="memdesc:a2d09dc7b51321c052b071485357ca1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Force quantities.  <a href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">More...</a><br /></td></tr>
<tr class="separator:a2d09dc7b51321c052b071485357ca1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526d114a9d34d7237ed3e41829ab3eff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga526d114a9d34d7237ed3e41829ab3eff">Frequency</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a1281aab63b535f7dd4cbcce87f7d6706">detail::frequency</a></td></tr>
<tr class="memdesc:ga526d114a9d34d7237ed3e41829ab3eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency quantity.  <a href="group__PhysicalQuantities.html#ga526d114a9d34d7237ed3e41829ab3eff">More...</a><br /></td></tr>
<tr class="separator:ga526d114a9d34d7237ed3e41829ab3eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938af6ffa35b77fb176a9533d9b2f902"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Return &gt; </td></tr>
<tr class="memitem:a938af6ffa35b77fb176a9533d9b2f902"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a938af6ffa35b77fb176a9533d9b2f902">HasNullaryFunctor</a> = <a class="el" href="structplayrho_1_1detail_1_1HasFunctor.html">detail::HasFunctor</a>&lt; Type, Return()&gt;</td></tr>
<tr class="memdesc:a938af6ffa35b77fb176a9533d9b2f902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has nullary functor type alias.  <a href="namespaceplayrho.html#a938af6ffa35b77fb176a9533d9b2f902">More...</a><br /></td></tr>
<tr class="separator:a938af6ffa35b77fb176a9533d9b2f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7d6112b6c359e797237cf305277451"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename Return , typename Arg &gt; </td></tr>
<tr class="memitem:a9f7d6112b6c359e797237cf305277451"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9f7d6112b6c359e797237cf305277451">HasUnaryFunctor</a> = <a class="el" href="structplayrho_1_1detail_1_1HasFunctor.html">detail::HasFunctor</a>&lt; Type, Return(Arg)&gt;</td></tr>
<tr class="memdesc:a9f7d6112b6c359e797237cf305277451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has unary functor type alias.  <a href="namespaceplayrho.html#a9f7d6112b6c359e797237cf305277451">More...</a><br /></td></tr>
<tr class="separator:a9f7d6112b6c359e797237cf305277451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d449e0a1528c10ae0f241713fb69b40"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a> = std::pair&lt; <a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a>, <a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a> &gt;</td></tr>
<tr class="memdesc:a7d449e0a1528c10ae0f241713fb69b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index pair.  <a href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">More...</a><br /></td></tr>
<tr class="separator:a7d449e0a1528c10ae0f241713fb69b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704da3b24d9b1f9135e140dcd5420518"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> = std::array&lt; <a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>, <a class="el" href="namespaceplayrho.html#a95591102a273a4d301f3f795d463b9ba">MaxSimplexEdges</a> &gt;</td></tr>
<tr class="memdesc:a704da3b24d9b1f9135e140dcd5420518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of three index-pair elements.  <a href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">More...</a><br /></td></tr>
<tr class="separator:a704da3b24d9b1f9135e140dcd5420518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab878660e71529c9163185103d206f9f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gab878660e71529c9163185103d206f9f4">InvMass</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a4e0fe544dc91c5df25ce8858ee1dda8b">detail::inverse_mass</a></td></tr>
<tr class="memdesc:gab878660e71529c9163185103d206f9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse mass quantity.  <a href="group__PhysicalQuantities.html#gab878660e71529c9163185103d206f9f4">More...</a><br /></td></tr>
<tr class="separator:gab878660e71529c9163185103d206f9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f2424eab18780894e83bbc4127fe67"><td class="memItemLeft" align="right" valign="top"><a id="ab4f2424eab18780894e83bbc4127fe67"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab4f2424eab18780894e83bbc4127fe67">InvMass2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gab878660e71529c9163185103d206f9f4">InvMass</a> &gt;</td></tr>
<tr class="memdesc:ab4f2424eab18780894e83bbc4127fe67"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of inverse mass (<code>InvMass</code>) quantities. <br /></td></tr>
<tr class="separator:ab4f2424eab18780894e83bbc4127fe67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="memItemLeft" align="right" valign="top"><a id="a507cf0b47bd41371f90aa8f78f1d7c8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a507cf0b47bd41371f90aa8f78f1d7c8a">InvMass22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gab878660e71529c9163185103d206f9f4">InvMass</a> &gt;</td></tr>
<tr class="memdesc:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of <code>InvMass</code> elements. <br /></td></tr>
<tr class="separator:a507cf0b47bd41371f90aa8f78f1d7c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3b57b56d804cd09ae743e670e866d3"><td class="memItemLeft" align="right" valign="top"><a id="a9d3b57b56d804cd09ae743e670e866d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9d3b57b56d804cd09ae743e670e866d3">InvMass3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gab878660e71529c9163185103d206f9f4">InvMass</a> &gt;</td></tr>
<tr class="memdesc:a9d3b57b56d804cd09ae743e670e866d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-element vector of inverse mass (<code>InvMass</code>) quantities. <br /></td></tr>
<tr class="separator:a9d3b57b56d804cd09ae743e670e866d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec7c3082c9a05e095b45f6b1c7caaaf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga8ec7c3082c9a05e095b45f6b1c7caaaf">InvRotInertia</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a7057f55e349ca3586994f4a94bb3a5c5">detail::inverse_moment_of_inertia</a></td></tr>
<tr class="memdesc:ga8ec7c3082c9a05e095b45f6b1c7caaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse rotational inertia quantity.  <a href="group__PhysicalQuantities.html#ga8ec7c3082c9a05e095b45f6b1c7caaaf">More...</a><br /></td></tr>
<tr class="separator:ga8ec7c3082c9a05e095b45f6b1c7caaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fff859979ed48e0d223d1584eb985c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3fff859979ed48e0d223d1584eb985c3">JointCounter</a> = std::remove_const_t&lt; decltype(<a class="el" href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">MaxJoints</a>)&gt;</td></tr>
<tr class="memdesc:a3fff859979ed48e0d223d1584eb985c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter type for joints.  <a href="namespaceplayrho.html#a3fff859979ed48e0d223d1584eb985c3">More...</a><br /></td></tr>
<tr class="separator:a3fff859979ed48e0d223d1584eb985c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3114be8fb50493389d7991db4f2b3d"><td class="memItemLeft" align="right" valign="top"><a id="a8e3114be8fb50493389d7991db4f2b3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#a3fff859979ed48e0d223d1584eb985c3">JointCounter</a>, struct JointIdentifier &gt;</td></tr>
<tr class="memdesc:a8e3114be8fb50493389d7991db4f2b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint identifier. <br /></td></tr>
<tr class="separator:a8e3114be8fb50493389d7991db4f2b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4191fb4470c5c3670c83670c53eac824"><td class="memItemLeft" align="right" valign="top"><a id="a4191fb4470c5c3670c83670c53eac824"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4191fb4470c5c3670c83670c53eac824">KeyedContactID</a> = std::pair&lt; <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a>, <a class="el" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a> &gt;</td></tr>
<tr class="memdesc:a4191fb4470c5c3670c83670c53eac824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keyed contact identifier. <br /></td></tr>
<tr class="separator:a4191fb4470c5c3670c83670c53eac824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8705f1923f7cff39bf09f6d01989770d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a89abc2eb85f9ce5226d4cd969ab4cdce">detail::length</a></td></tr>
<tr class="memdesc:ga8705f1923f7cff39bf09f6d01989770d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length quantity.  <a href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">More...</a><br /></td></tr>
<tr class="separator:ga8705f1923f7cff39bf09f6d01989770d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a> &gt;</td></tr>
<tr class="memdesc:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Length quantities.  <a href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">More...</a><br /></td></tr>
<tr class="separator:a7dc68cd0ce177e175ae0bb6c39db158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2069744ddc1c5068705b00f957451a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gaea2069744ddc1c5068705b00f957451a">LinearAcceleration</a> = <a class="el" href="namespaceplayrho_1_1detail.html#aefbb6a898514981d80d8a599a6faed34">detail::acceleration</a></td></tr>
<tr class="memdesc:gaea2069744ddc1c5068705b00f957451a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear acceleration quantity.  <a href="group__PhysicalQuantities.html#gaea2069744ddc1c5068705b00f957451a">More...</a><br /></td></tr>
<tr class="separator:gaea2069744ddc1c5068705b00f957451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5822921028100052d4c6dfb43c7f6c4b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">LinearAcceleration2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gaea2069744ddc1c5068705b00f957451a">LinearAcceleration</a> &gt;</td></tr>
<tr class="memdesc:a5822921028100052d4c6dfb43c7f6c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of linear acceleration (<code>LinearAcceleration</code>) quantities.  <a href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">More...</a><br /></td></tr>
<tr class="separator:a5822921028100052d4c6dfb43c7f6c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4434fe902be456f845c8e478bd48f97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a07bf078d023635979d9fd9bda324a16e">detail::velocity</a></td></tr>
<tr class="memdesc:gaf4434fe902be456f845c8e478bd48f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear velocity quantity.  <a href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">More...</a><br /></td></tr>
<tr class="separator:gaf4434fe902be456f845c8e478bd48f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faa31bff8794a0c4191d8b042f7deeb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">LinearVelocity2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a> &gt;</td></tr>
<tr class="memdesc:a2faa31bff8794a0c4191d8b042f7deeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of linear velocity (<code>LinearVelocity</code>) quantities.  <a href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">More...</a><br /></td></tr>
<tr class="separator:a2faa31bff8794a0c4191d8b042f7deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf74540633aeb472114381118842149e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a38a46160145a84da9c500ffd0df5e1bc">detail::mass</a></td></tr>
<tr class="memdesc:gaaf74540633aeb472114381118842149e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mass quantity.  <a href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">More...</a><br /></td></tr>
<tr class="separator:gaaf74540633aeb472114381118842149e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfba2b26f22dcc026361ed5a0ccf3966"><td class="memItemLeft" align="right" valign="top"><a id="acfba2b26f22dcc026361ed5a0ccf3966"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acfba2b26f22dcc026361ed5a0ccf3966">Mass2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a> &gt;</td></tr>
<tr class="memdesc:acfba2b26f22dcc026361ed5a0ccf3966"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Mass quantities. <br /></td></tr>
<tr class="separator:acfba2b26f22dcc026361ed5a0ccf3966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358c8036b278316ab41b3f35b56342a1"><td class="memItemLeft" align="right" valign="top"><a id="a358c8036b278316ab41b3f35b56342a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a358c8036b278316ab41b3f35b56342a1">Mass22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a> &gt;</td></tr>
<tr class="memdesc:a358c8036b278316ab41b3f35b56342a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of Mass elements. <br /></td></tr>
<tr class="separator:a358c8036b278316ab41b3f35b56342a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996c0271f83c70e94b485ff59bb468a1"><td class="memItemLeft" align="right" valign="top"><a id="a996c0271f83c70e94b485ff59bb468a1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a996c0271f83c70e94b485ff59bb468a1">Mass3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a> &gt;</td></tr>
<tr class="memdesc:a996c0271f83c70e94b485ff59bb468a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-element vector of Mass quantities. <br /></td></tr>
<tr class="separator:a996c0271f83c70e94b485ff59bb468a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c09bb6556e3168c0085871358d2f71"><td class="memItemLeft" align="right" valign="top"><a id="a02c09bb6556e3168c0085871358d2f71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> = <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:a02c09bb6556e3168c0085871358d2f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix of Real elements. <br /></td></tr>
<tr class="separator:a02c09bb6556e3168c0085871358d2f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="memItemLeft" align="right" valign="top"><a id="aabd44d74c5bc530c9b6676c6a61e6b31"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> = <a class="el" href="namespaceplayrho.html#a92e228aada1d7ca23d9f6c2c9ce3b415">Matrix33</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 matrix of Real elements. <br /></td></tr>
<tr class="separator:aabd44d74c5bc530c9b6676c6a61e6b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;, M &gt;</td></tr>
<tr class="memdesc:acbf97bd8e3f0f2ce4588735388f4089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic M by N matrix.  <a href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">More...</a><br /></td></tr>
<tr class="separator:acbf97bd8e3f0f2ce4588735388f4089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aabbb6723402cb9e12cf32e17beebc"><td class="memTemplParams" colspan="2"><a id="a26aabbb6723402cb9e12cf32e17beebc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26aabbb6723402cb9e12cf32e17beebc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a> = <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, 2, 2 &gt;</td></tr>
<tr class="memdesc:a26aabbb6723402cb9e12cf32e17beebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 by 2 matrix. <br /></td></tr>
<tr class="separator:a26aabbb6723402cb9e12cf32e17beebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memTemplParams" colspan="2"><a id="a92e228aada1d7ca23d9f6c2c9ce3b415"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a92e228aada1d7ca23d9f6c2c9ce3b415">Matrix33</a> = <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, 3, 3 &gt;</td></tr>
<tr class="memdesc:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 matrix. <br /></td></tr>
<tr class="separator:a92e228aada1d7ca23d9f6c2c9ce3b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad36b742307f9f19c2c8c95e9372a3613"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">Momentum</a> = <a class="el" href="namespaceplayrho_1_1detail.html#ac761581120ca23f745cf4f362c975bd0">detail::momentum</a></td></tr>
<tr class="memdesc:gad36b742307f9f19c2c8c95e9372a3613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum quantity.  <a href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">More...</a><br /></td></tr>
<tr class="separator:gad36b742307f9f19c2c8c95e9372a3613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa6ffb2e67c2e2f620eed088412b146"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">Momentum2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">Momentum</a> &gt;</td></tr>
<tr class="memdesc:a1fa6ffb2e67c2e2f620eed088412b146"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vector of Momentum quantities.  <a href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">More...</a><br /></td></tr>
<tr class="separator:a1fa6ffb2e67c2e2f620eed088412b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae249aaac842934d7f33e0f90012c409a"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae249aaac842934d7f33e0f90012c409a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#gae249aaac842934d7f33e0f90012c409a">Negative</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NegativeChecker.html">detail::NegativeChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gae249aaac842934d7f33e0f90012c409a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative constrained value type. <br /></td></tr>
<tr class="separator:gae249aaac842934d7f33e0f90012c409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d1fdcdd87aa834539d3b58cdee6db3d"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9d1fdcdd87aa834539d3b58cdee6db3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga9d1fdcdd87aa834539d3b58cdee6db3d">NegativeFF</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NegativeChecker.html">detail::NegativeChecker</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="memdesc:ga9d1fdcdd87aa834539d3b58cdee6db3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing negative constrained value type. <br /></td></tr>
<tr class="separator:ga9d1fdcdd87aa834539d3b58cdee6db3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab2310a74db36363887ad368d5c3118"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7ab2310a74db36363887ad368d5c3118"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga7ab2310a74db36363887ad368d5c3118">NonNegative</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonNegativeChecker.html">detail::NonNegativeChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga7ab2310a74db36363887ad368d5c3118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-negative constrained value type. <br /></td></tr>
<tr class="separator:ga7ab2310a74db36363887ad368d5c3118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcee23e546ebf8053221fa14741f0dc9"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafcee23e546ebf8053221fa14741f0dc9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonNegativeChecker.html">detail::NonNegativeChecker</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="memdesc:gafcee23e546ebf8053221fa14741f0dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing non-negative constrained value type. <br /></td></tr>
<tr class="separator:gafcee23e546ebf8053221fa14741f0dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1e056867aa49f7ac5d12a557fef88c"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9a1e056867aa49f7ac5d12a557fef88c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga9a1e056867aa49f7ac5d12a557fef88c">NonNull</a> = std::enable_if_t&lt; std::is_pointer_v&lt; T &gt;, <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonZeroChecker.html">detail::NonZeroChecker</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga9a1e056867aa49f7ac5d12a557fef88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-null constrained value type. <br /></td></tr>
<tr class="separator:ga9a1e056867aa49f7ac5d12a557fef88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e09f5578ccdd32e48595e68bad4cea"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga11e09f5578ccdd32e48595e68bad4cea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga11e09f5578ccdd32e48595e68bad4cea">NonNullFF</a> = std::enable_if_t&lt; std::is_pointer_v&lt; T &gt;, <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonZeroChecker.html">detail::NonZeroChecker</a>&lt; T &gt;, true &gt; &gt;</td></tr>
<tr class="memdesc:ga11e09f5578ccdd32e48595e68bad4cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing non-null constrained value type. <br /></td></tr>
<tr class="separator:ga11e09f5578ccdd32e48595e68bad4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631ddc4411751edeb5acbbeeb3ea622b"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga631ddc4411751edeb5acbbeeb3ea622b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga631ddc4411751edeb5acbbeeb3ea622b">NonPositive</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonPositiveChecker.html">detail::NonPositiveChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga631ddc4411751edeb5acbbeeb3ea622b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-positive constrained value type. <br /></td></tr>
<tr class="separator:ga631ddc4411751edeb5acbbeeb3ea622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc3093225e2a92cd20e21719cddc120"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabcc3093225e2a92cd20e21719cddc120"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#gabcc3093225e2a92cd20e21719cddc120">NonPositiveFF</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonPositiveChecker.html">detail::NonPositiveChecker</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="memdesc:gabcc3093225e2a92cd20e21719cddc120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing non-positive constrained value type. <br /></td></tr>
<tr class="separator:gabcc3093225e2a92cd20e21719cddc120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02f02efffaeefcfeb7bd228ef7da12a8"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga02f02efffaeefcfeb7bd228ef7da12a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga02f02efffaeefcfeb7bd228ef7da12a8">NonZero</a> = std::enable_if_t&lt;!std::is_pointer_v&lt; T &gt;, <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonZeroChecker.html">detail::NonZeroChecker</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga02f02efffaeefcfeb7bd228ef7da12a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-zero constrained value type. <br /></td></tr>
<tr class="separator:ga02f02efffaeefcfeb7bd228ef7da12a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3ab69bdace3bd39222135fc9646225"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7b3ab69bdace3bd39222135fc9646225"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga7b3ab69bdace3bd39222135fc9646225">NonZeroFF</a> = std::enable_if_t&lt;!std::is_pointer_v&lt; T &gt;, <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1NonZeroChecker.html">detail::NonZeroChecker</a>&lt; T &gt;, true &gt; &gt;</td></tr>
<tr class="memdesc:ga7b3ab69bdace3bd39222135fc9646225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing non-zero constrained value type. <br /></td></tr>
<tr class="separator:ga7b3ab69bdace3bd39222135fc9646225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae444a62491fcb2b10f0f06a41b1ac406"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">PairLength2</a> = std::pair&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>, <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;</td></tr>
<tr class="memdesc:ae444a62491fcb2b10f0f06a41b1ac406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of <code>Length2</code> values.  <a href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">More...</a><br /></td></tr>
<tr class="separator:ae444a62491fcb2b10f0f06a41b1ac406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fce58e6740bd8d9f025e08472071a9b"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1fce58e6740bd8d9f025e08472071a9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga1fce58e6740bd8d9f025e08472071a9b">Positive</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1PositiveChecker.html">detail::PositiveChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga1fce58e6740bd8d9f025e08472071a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive constrained value type. <br /></td></tr>
<tr class="separator:ga1fce58e6740bd8d9f025e08472071a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521f0650a33330a43eafb31ecb6d4ae5"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga521f0650a33330a43eafb31ecb6d4ae5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga521f0650a33330a43eafb31ecb6d4ae5">PositiveFF</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1PositiveChecker.html">detail::PositiveChecker</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="memdesc:ga521f0650a33330a43eafb31ecb6d4ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing positive constrained value type. <br /></td></tr>
<tr class="separator:ga521f0650a33330a43eafb31ecb6d4ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc125070a08100d083a1360f7167f87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> = float</td></tr>
<tr class="memdesc:a1fc125070a08100d083a1360f7167f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-number type.  <a href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">More...</a><br /></td></tr>
<tr class="separator:a1fc125070a08100d083a1360f7167f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81349200b6a963bf87885ab7e89e981d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga81349200b6a963bf87885ab7e89e981d">RotInertia</a> = <a class="el" href="namespaceplayrho_1_1detail.html#ad1d3c743f682c8b2631e7d77b82d6498">detail::moment_of_inertia</a></td></tr>
<tr class="memdesc:ga81349200b6a963bf87885ab7e89e981d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotational inertia quantity.  <a href="group__PhysicalQuantities.html#ga81349200b6a963bf87885ab7e89e981d">More...</a><br /></td></tr>
<tr class="separator:ga81349200b6a963bf87885ab7e89e981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687546b31c191aeeacf223bdbebe6747"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga687546b31c191aeeacf223bdbebe6747">SecondMomentOfArea</a> = <a class="el" href="namespaceplayrho_1_1detail.html#a658b54e98a49b6b4719d84643981de3d">detail::second_moment_of_area</a></td></tr>
<tr class="memdesc:ga687546b31c191aeeacf223bdbebe6747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second moment of area quantity.  <a href="group__PhysicalQuantities.html#ga687546b31c191aeeacf223bdbebe6747">More...</a><br /></td></tr>
<tr class="separator:ga687546b31c191aeeacf223bdbebe6747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238bb543bc4c65753c931c94c8bd70cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a238bb543bc4c65753c931c94c8bd70cf">ShapeCounter</a> = std::remove_const_t&lt; decltype(<a class="el" href="namespaceplayrho.html#a2e673e5e335bf14ece1382b582f2163b">MaxShapes</a>)&gt;</td></tr>
<tr class="memdesc:a238bb543bc4c65753c931c94c8bd70cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count type for shapes.  <a href="namespaceplayrho.html#a238bb543bc4c65753c931c94c8bd70cf">More...</a><br /></td></tr>
<tr class="separator:a238bb543bc4c65753c931c94c8bd70cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664fbedb33a4af92883576fbee62fd28"><td class="memItemLeft" align="right" valign="top"><a id="a664fbedb33a4af92883576fbee62fd28"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a> = <a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html">detail::IndexingNamedType</a>&lt; <a class="el" href="namespaceplayrho.html#a238bb543bc4c65753c931c94c8bd70cf">ShapeCounter</a>, struct ShapeIdentifier &gt;</td></tr>
<tr class="memdesc:a664fbedb33a4af92883576fbee62fd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape identifier. <br /></td></tr>
<tr class="separator:a664fbedb33a4af92883576fbee62fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4842e1cf025b86cafb4b09c0f51bc18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a> = <a class="el" href="namespaceplayrho_1_1detail.html#aec06718803b60f89a200ed9207508f02">detail::time</a></td></tr>
<tr class="memdesc:gaa4842e1cf025b86cafb4b09c0f51bc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time quantity.  <a href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">More...</a><br /></td></tr>
<tr class="separator:gaa4842e1cf025b86cafb4b09c0f51bc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3898807006fd29cd5c4fc2e1a9cf5536">TimestepIters</a> = std::uint8_t</td></tr>
<tr class="separator:a3898807006fd29cd5c4fc2e1a9cf5536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1acd0787ea4caa9725577e0aa2fdc9b7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalQuantities.html#ga1acd0787ea4caa9725577e0aa2fdc9b7">Torque</a> = <a class="el" href="namespaceplayrho_1_1detail.html#af3257d2b875169550aa6628cbd523356">detail::torque</a></td></tr>
<tr class="memdesc:ga1acd0787ea4caa9725577e0aa2fdc9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Torque quantity.  <a href="group__PhysicalQuantities.html#ga1acd0787ea4caa9725577e0aa2fdc9b7">More...</a><br /></td></tr>
<tr class="separator:ga1acd0787ea4caa9725577e0aa2fdc9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a5a66199e77439cdac1b5a16831484e"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4a5a66199e77439cdac1b5a16831484e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga4a5a66199e77439cdac1b5a16831484e">UnitInterval</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1UnitIntervalChecker.html">detail::UnitIntervalChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga4a5a66199e77439cdac1b5a16831484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit interval constrained value type. <br /></td></tr>
<tr class="separator:ga4a5a66199e77439cdac1b5a16831484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga309960da94ba655d5101c19da5c55c1b"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga309960da94ba655d5101c19da5c55c1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga309960da94ba655d5101c19da5c55c1b">UnitIntervalFF</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1UnitIntervalChecker.html">detail::UnitIntervalChecker</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="memdesc:ga309960da94ba655d5101c19da5c55c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing unit interval constrained value type. <br /></td></tr>
<tr class="separator:ga309960da94ba655d5101c19da5c55c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93c0cd83df090aba6593ffac4b628ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> = <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:ad93c0cd83df090aba6593ffac4b628ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2 Real elements.  <a href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">More...</a><br /></td></tr>
<tr class="separator:ad93c0cd83df090aba6593ffac4b628ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f6dcdf3763052ea25099973c7c00ad"><td class="memItemLeft" align="right" valign="top"><a id="a63f6dcdf3763052ea25099973c7c00ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a63f6dcdf3763052ea25099973c7c00ad">Vec3</a> = <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;</td></tr>
<tr class="memdesc:a63f6dcdf3763052ea25099973c7c00ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3-dimensional column vector with 3 elements. <br /></td></tr>
<tr class="separator:a63f6dcdf3763052ea25099973c7c00ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97243f194a9406d0fdcf5f6f833851ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97243f194a9406d0fdcf5f6f833851ab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 2 &gt;</td></tr>
<tr class="memdesc:a97243f194a9406d0fdcf5f6f833851ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2-elements.  <a href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">More...</a><br /></td></tr>
<tr class="separator:a97243f194a9406d0fdcf5f6f833851ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a> = <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 3 &gt;</td></tr>
<tr class="memdesc:ad07b44f811ac4c7551067fb1d3554ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 3-elements.  <a href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">More...</a><br /></td></tr>
<tr class="separator:ad07b44f811ac4c7551067fb1d3554ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4505f6a4017695c48bd81225eaf9c28a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a> = std::remove_const_t&lt; decltype(<a class="el" href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">MaxShapeVertices</a>)&gt;</td></tr>
<tr class="memdesc:a4505f6a4017695c48bd81225eaf9c28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex count type.  <a href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">More...</a><br /></td></tr>
<tr class="separator:a4505f6a4017695c48bd81225eaf9c28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="memItemLeft" align="right" valign="top"><a id="ae2ea03f9c65d074dfd1aa21b6352f293"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae2ea03f9c65d074dfd1aa21b6352f293">VertexCounter2</a> = <a class="el" href="namespaceplayrho.html#a0a8c8047429035c030e233c9503cbec9">VertexCounterArray</a>&lt; 2 &gt;</td></tr>
<tr class="memdesc:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-element vertex counter array. <br /></td></tr>
<tr class="separator:ae2ea03f9c65d074dfd1aa21b6352f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8c8047429035c030e233c9503cbec9"><td class="memTemplParams" colspan="2"><a id="a0a8c8047429035c030e233c9503cbec9"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a0a8c8047429035c030e233c9503cbec9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0a8c8047429035c030e233c9503cbec9">VertexCounterArray</a> = std::array&lt; <a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a>, N &gt;</td></tr>
<tr class="memdesc:a0a8c8047429035c030e233c9503cbec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex counter array template alias. <br /></td></tr>
<tr class="separator:a0a8c8047429035c030e233c9503cbec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d090b6b86609a8e93cb933b2b223e63"><td class="memTemplParams" colspan="2"><a id="a0d090b6b86609a8e93cb933b2b223e63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d090b6b86609a8e93cb933b2b223e63"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0d090b6b86609a8e93cb933b2b223e63">WiderType</a> = typename <a class="el" href="structplayrho_1_1detail_1_1Wider.html">detail::Wider</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a0d090b6b86609a8e93cb933b2b223e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wider type helper. <br /></td></tr>
<tr class="separator:a0d090b6b86609a8e93cb933b2b223e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d33fe002089badc48d22d99ec924ee4"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6d33fe002089badc48d22d99ec924ee4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga6d33fe002089badc48d22d99ec924ee4">ZeroToUnderOne</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1ZeroToUnderOneChecker.html">detail::ZeroToUnderOneChecker</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga6d33fe002089badc48d22d99ec924ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit interval constrained value type. <br /></td></tr>
<tr class="separator:ga6d33fe002089badc48d22d99ec924ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f43e0e8a9fa443bc746a5f865effef"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga82f43e0e8a9fa443bc746a5f865effef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CheckedTypes.html#ga82f43e0e8a9fa443bc746a5f865effef">ZeroToUnderOneFF</a> = <a class="el" href="classplayrho_1_1detail_1_1Checked.html">detail::Checked</a>&lt; T, <a class="el" href="structplayrho_1_1detail_1_1ZeroToUnderOneChecker.html">detail::ZeroToUnderOneChecker</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="memdesc:ga82f43e0e8a9fa443bc746a5f865effef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast failing unit interval constrained value type. <br /></td></tr>
<tr class="separator:ga82f43e0e8a9fa443bc746a5f865effef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a098b0ef528e3b728af8e3e17873963f7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a> { <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a84a8921b25f505d0d2077aeb5db4bc16">Static</a> = 0
, <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a40c78b58b86002ee38fad2d3c9dd787e">Kinematic</a>
, <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7a971fd8cc345d8bd9f92e9f7d88fdf20c">Dynamic</a>
 }</td></tr>
<tr class="memdesc:a098b0ef528e3b728af8e3e17873963f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of body.  <a href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">More...</a><br /></td></tr>
<tr class="separator:a098b0ef528e3b728af8e3e17873963f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854ac3ed65c77740c30c5d097b11435c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435c">LimitState</a> { <a class="el" href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435ca1f7b8a0fe66401e83219c7a6b7271e77">e_inactiveLimit</a>
, <a class="el" href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435cab5be4dc895bc396de7129733217d2d1d">e_atLowerLimit</a>
, <a class="el" href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435ca719db30ca9dc11b4ef7229efab6efb59">e_atUpperLimit</a>
, <a class="el" href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435ca4737f7baf9c11f81fc69998ca490edab">e_equalLimits</a>
 }</td></tr>
<tr class="memdesc:a854ac3ed65c77740c30c5d097b11435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit state.  <a href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435c">More...</a><br /></td></tr>
<tr class="separator:a854ac3ed65c77740c30c5d097b11435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f67e158a928ef59e4263facac8fb0b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">PointState</a> { <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0babbb93ef26e3c101ff11cdd21cab08a94">Null</a>
, <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0baec211f7c20af43e742bf2570c3cb84f9">Add</a>
, <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba5a7dacb6e9b5ba37e22f825429355174">Persist</a>
, <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0ba1063e38cb53d94d386f21227fcd84717">Remove</a>
 }</td></tr>
<tr class="memdesc:a06f67e158a928ef59e4263facac8fb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point state enumeration.  <a href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">More...</a><br /></td></tr>
<tr class="separator:a06f67e158a928ef59e4263facac8fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66189f1fe36ac717e284ab1099171106"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">RayCastOpcode</a> { <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a056fa3d840f48b7bfbbd68c19a4797b3">Terminate</a>
, <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106aaf8767ee039cdc51717435bb815da593">IgnoreFixture</a>
, <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a8dcfe18b6245b17c9cd69d5af7ef1847">ClipRay</a>
, <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106a4592f28dc9d11de3ce507bebafd9de16">ResetRay</a>
 }</td></tr>
<tr class="memdesc:a66189f1fe36ac717e284ab1099171106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ray cast opcode enumeration.  <a href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">More...</a><br /></td></tr>
<tr class="separator:a66189f1fe36ac717e284ab1099171106"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac862a8609b82126d0683ecb38a498087"><td class="memItemLeft" align="right" valign="top"><a id="ac862a8609b82126d0683ecb38a498087"></a>
<a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac862a8609b82126d0683ecb38a498087">abs</a> (const <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a> &amp;v) noexcept</td></tr>
<tr class="memdesc:ac862a8609b82126d0683ecb38a498087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the absolute value of the given value. <br /></td></tr>
<tr class="separator:ac862a8609b82126d0683ecb38a498087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594091c0fcb9865f2d102f3b8ee973b3"><td class="memTemplParams" colspan="2"><a id="a594091c0fcb9865f2d102f3b8ee973b3"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a594091c0fcb9865f2d102f3b8ee973b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a594091c0fcb9865f2d102f3b8ee973b3">abs</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept -&gt; decltype(abs(T{}), <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;{})</td></tr>
<tr class="memdesc:a594091c0fcb9865f2d102f3b8ee973b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value function for vectors. <br /></td></tr>
<tr class="separator:a594091c0fcb9865f2d102f3b8ee973b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516a3bbb73371cdc53f348b67f43bb1f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f">Alloc</a> (std::size_t <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a>)</td></tr>
<tr class="memdesc:a516a3bbb73371cdc53f348b67f43bb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory.  <a href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f">More...</a><br /></td></tr>
<tr class="separator:a516a3bbb73371cdc53f348b67f43bb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2943dd9a79b7fc1fa196af1208b00388"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2943dd9a79b7fc1fa196af1208b00388"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">AllocArray</a> (std::size_t <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a>)</td></tr>
<tr class="memdesc:a2943dd9a79b7fc1fa196af1208b00388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for an array.  <a href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">More...</a><br /></td></tr>
<tr class="separator:a2943dd9a79b7fc1fa196af1208b00388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b872c5026531f33636758bb11b167e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8b872c5026531f33636758bb11b167e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga8b872c5026531f33636758bb11b167e6">AlmostEqual</a> (T a, T b, int ulp=4) -&gt; std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#aa9c55e27192da826391d895835f02b17">IsArithmeticV</a>&lt; T &gt;, bool &gt;</td></tr>
<tr class="memdesc:ga8b872c5026531f33636758bb11b167e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal".  <a href="group__Math.html#ga8b872c5026531f33636758bb11b167e6">More...</a><br /></td></tr>
<tr class="separator:ga8b872c5026531f33636758bb11b167e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994ed50293b78dff53a5c7bce78602bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga994ed50293b78dff53a5c7bce78602bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga994ed50293b78dff53a5c7bce78602bf">AlmostZero</a> (const T &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#ac862a8609b82126d0683ecb38a498087">abs</a>(value)&lt; std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:ga994ed50293b78dff53a5c7bce78602bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group__Math.html#ga994ed50293b78dff53a5c7bce78602bf">More...</a><br /></td></tr>
<tr class="separator:ga994ed50293b78dff53a5c7bce78602bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">Atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:gab870a9188fcc77c905807fa718a8268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values.  <a href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">More...</a><br /></td></tr>
<tr class="separator:gab870a9188fcc77c905807fa718a8268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga5928e1bb2ea4a8d60673314ff46a83cf">Average</a> (const T &amp;span)</td></tr>
<tr class="memdesc:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of the given values. <br /></td></tr>
<tr class="separator:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429625691c6a45944e55fe50f9a59199"><td class="memTemplParams" colspan="2"><a id="a429625691c6a45944e55fe50f9a59199"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a429625691c6a45944e55fe50f9a59199"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a429625691c6a45944e55fe50f9a59199">begin</a> (<a class="el" href="structplayrho_1_1ReversionWrapper.html">ReversionWrapper</a>&lt; T &gt; w)</td></tr>
<tr class="memdesc:a429625691c6a45944e55fe50f9a59199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin function for getting a reversed order iterator. <br /></td></tr>
<tr class="separator:a429625691c6a45944e55fe50f9a59199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9807960f6f6e39b0449aec22d646669"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad9807960f6f6e39b0449aec22d646669"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gad9807960f6f6e39b0449aec22d646669">Bisect</a> (const T &amp;a1, const T &amp;a2) -&gt; decltype((a1+a2)/2)</td></tr>
<tr class="memdesc:gad9807960f6f6e39b0449aec22d646669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection method.  <a href="group__Math.html#gad9807960f6f6e39b0449aec22d646669">More...</a><br /></td></tr>
<tr class="separator:gad9807960f6f6e39b0449aec22d646669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3f6e8b69eaeee408d3894b59629cffe9">cfloor</a> (T v) noexcept</td></tr>
<tr class="memdesc:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant expression enhanced floor function.  <a href="group__Math.html#ga3f6e8b69eaeee408d3894b59629cffe9">More...</a><br /></td></tr>
<tr class="separator:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21356f425ceb245286afe5a7b3b9b7b"><td class="memItemLeft" align="right" valign="top"><a id="ad21356f425ceb245286afe5a7b3b9b7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad21356f425ceb245286afe5a7b3b9b7b">Clear</a> (<a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island) noexcept</td></tr>
<tr class="memdesc:ad21356f425ceb245286afe5a7b3b9b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the island containers. <br /></td></tr>
<tr class="separator:ad21356f425ceb245286afe5a7b3b9b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2551e46a5f342484d8f0ec42c44e3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5ff2551e46a5f342484d8f0ec42c44e3">compare</a> (const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5ff2551e46a5f342484d8f0ec42c44e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison function.  <a href="namespaceplayrho.html#a5ff2551e46a5f342484d8f0ec42c44e3">More...</a><br /></td></tr>
<tr class="separator:a5ff2551e46a5f342484d8f0ec42c44e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae769785f0540a4b8960b282f6b105c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">ComputeCentroid</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gae769785f0540a4b8960b282f6b105c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a counter-clockwise array of 3 or more vertices.  <a href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">More...</a><br /></td></tr>
<tr class="separator:gae769785f0540a4b8960b282f6b105c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddcd2c8f0eff0c93d899e8ddcc6308a"><td class="memItemLeft" align="right" valign="top"><a id="abddcd2c8f0eff0c93d899e8ddcc6308a"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abddcd2c8f0eff0c93d899e8ddcc6308a">Count</a> (const <a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island, <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> entry)</td></tr>
<tr class="memdesc:abddcd2c8f0eff0c93d899e8ddcc6308a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of occurrences of the given entry in the given island. <br /></td></tr>
<tr class="separator:abddcd2c8f0eff0c93d899e8ddcc6308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898248ef79f7b944f24106f73c3a0fcd"><td class="memItemLeft" align="right" valign="top"><a id="a898248ef79f7b944f24106f73c3a0fcd"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a898248ef79f7b944f24106f73c3a0fcd">Count</a> (const <a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island, <a class="el" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a> entry)</td></tr>
<tr class="memdesc:a898248ef79f7b944f24106f73c3a0fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of occurrences of the given entry in the given island. <br /></td></tr>
<tr class="separator:a898248ef79f7b944f24106f73c3a0fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f9744256467cb8d34121dba6dbe294"><td class="memItemLeft" align="right" valign="top"><a id="a54f9744256467cb8d34121dba6dbe294"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a54f9744256467cb8d34121dba6dbe294">Count</a> (const <a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island, <a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a> entry)</td></tr>
<tr class="memdesc:a54f9744256467cb8d34121dba6dbe294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of occurrences of the given entry in the given island. <br /></td></tr>
<tr class="separator:a54f9744256467cb8d34121dba6dbe294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5164277624274fde39d33fd4f0f5dd5"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size_v&lt; T1 &gt;==2 &amp;&amp;std::tuple_size_v&lt; T2 &gt;==2, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gab5164277624274fde39d33fd4f0f5dd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab5164277624274fde39d33fd4f0f5dd5">Cross</a> (const T1 &amp;a, const T2 &amp;b) noexcept</td></tr>
<tr class="memdesc:gab5164277624274fde39d33fd4f0f5dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-element analog of the cross product of two vectors.  <a href="group__Math.html#gab5164277624274fde39d33fd4f0f5dd5">More...</a><br /></td></tr>
<tr class="separator:gab5164277624274fde39d33fd4f0f5dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0508a648e02202d025b83e46973e45"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaff0508a648e02202d025b83e46973e45"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaff0508a648e02202d025b83e46973e45">ctrunc</a> (T v) noexcept</td></tr>
<tr class="memdesc:gaff0508a648e02202d025b83e46973e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant expression enhanced truncate function.  <a href="group__Math.html#gaff0508a648e02202d025b83e46973e45">More...</a><br /></td></tr>
<tr class="separator:gaff0508a648e02202d025b83e46973e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e3eae87277d85db13cce6b12facf1e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga08e3eae87277d85db13cce6b12facf1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga08e3eae87277d85db13cce6b12facf1e">Dot</a> (const T1 &amp;a, const T2 &amp;b) noexcept</td></tr>
<tr class="memdesc:ga08e3eae87277d85db13cce6b12facf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors (A and B).  <a href="group__Math.html#ga08e3eae87277d85db13cce6b12facf1e">More...</a><br /></td></tr>
<tr class="separator:ga08e3eae87277d85db13cce6b12facf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ab78cb47da6f6d872d617cc66040a6"><td class="memItemLeft" align="right" valign="top"><a id="a98ab78cb47da6f6d872d617cc66040a6"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a98ab78cb47da6f6d872d617cc66040a6">empty</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) noexcept</td></tr>
<tr class="memdesc:a98ab78cb47da6f6d872d617cc66040a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given collection of index pairs is empty. <br /></td></tr>
<tr class="separator:a98ab78cb47da6f6d872d617cc66040a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370e741c22960aad46732cdc0353f428"><td class="memTemplParams" colspan="2"><a id="a370e741c22960aad46732cdc0353f428"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a370e741c22960aad46732cdc0353f428"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a> (<a class="el" href="structplayrho_1_1ReversionWrapper.html">ReversionWrapper</a>&lt; T &gt; w)</td></tr>
<tr class="memdesc:a370e741c22960aad46732cdc0353f428"><td class="mdescLeft">&#160;</td><td class="mdescRight">End function for getting a reversed order iterator. <br /></td></tr>
<tr class="separator:a370e741c22960aad46732cdc0353f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa5b77298f0fc2a2ae88ececbc3fb23d1">EraseAll</a> (T &amp;container, const U &amp;value) -&gt; decltype(distance(container.erase(remove(<a class="el" href="namespaceplayrho.html#a429625691c6a45944e55fe50f9a59199">begin</a>(container), <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container), value), <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container)), <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container)))</td></tr>
<tr class="memdesc:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template function for erasing specified value from container.  <a href="namespaceplayrho.html#aa5b77298f0fc2a2ae88ececbc3fb23d1">More...</a><br /></td></tr>
<tr class="separator:aa5b77298f0fc2a2ae88ececbc3fb23d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad559996a9d085eb07a18b5b88525761f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad559996a9d085eb07a18b5b88525761f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad559996a9d085eb07a18b5b88525761f">EraseFirst</a> (T &amp;container, const U &amp;value) -&gt; decltype(container.erase(find(<a class="el" href="namespaceplayrho.html#a429625691c6a45944e55fe50f9a59199">begin</a>(container), <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container), value)) !=<a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container))</td></tr>
<tr class="memdesc:ad559996a9d085eb07a18b5b88525761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience template function for erasing first found value from container.  <a href="namespaceplayrho.html#ad559996a9d085eb07a18b5b88525761f">More...</a><br /></td></tr>
<tr class="separator:ad559996a9d085eb07a18b5b88525761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1efaeb0c030854ede6606021ba56d30"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac1efaeb0c030854ede6606021ba56d30">FlagForFiltering</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:ac1efaeb0c030854ede6606021ba56d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the contact for filtering.  <a href="namespaceplayrho.html#ac1efaeb0c030854ede6606021ba56d30">More...</a><br /></td></tr>
<tr class="separator:ac1efaeb0c030854ede6606021ba56d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ec70ebc79af5b28899b8d0a1341141"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac1ec70ebc79af5b28899b8d0a1341141">FlagForUpdating</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:ac1ec70ebc79af5b28899b8d0a1341141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the contact for updating.  <a href="namespaceplayrho.html#ac1ec70ebc79af5b28899b8d0a1341141">More...</a><br /></td></tr>
<tr class="separator:ac1ec70ebc79af5b28899b8d0a1341141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43951f69f7ead57450bac66cbb76b0e1"><td class="memItemLeft" align="right" valign="top"><a id="a43951f69f7ead57450bac66cbb76b0e1"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a43951f69f7ead57450bac66cbb76b0e1">Flip</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> val) noexcept</td></tr>
<tr class="memdesc:a43951f69f7ead57450bac66cbb76b0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips contact features information. <br /></td></tr>
<tr class="separator:a43951f69f7ead57450bac66cbb76b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c138018c11ab3c255b410f2dedd7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2">Free</a> (void *mem)</td></tr>
<tr class="memdesc:a62c138018c11ab3c255b410f2dedd7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory.  <a href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2">More...</a><br /></td></tr>
<tr class="separator:a62c138018c11ab3c255b410f2dedd7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a27488878deb0db4face63ec9749b1"><td class="memTemplParams" colspan="2"><a id="a32a27488878deb0db4face63ec9749b1"></a>
template&lt;std::size_t I, std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a32a27488878deb0db4face63ec9749b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a32a27488878deb0db4face63ec9749b1">get</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a32a27488878deb0db4face63ec9749b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified element of the given collection. <br /></td></tr>
<tr class="separator:a32a27488878deb0db4face63ec9749b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10d9373a7aa5e3492fee0877900f738"><td class="memTemplParams" colspan="2"><a id="aa10d9373a7aa5e3492fee0877900f738"></a>
template&lt;std::size_t I, std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:aa10d9373a7aa5e3492fee0877900f738"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:aa10d9373a7aa5e3492fee0877900f738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified element of the given collection. <br /></td></tr>
<tr class="separator:aa10d9373a7aa5e3492fee0877900f738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941d2e26e203e19b567a018570417be3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga941d2e26e203e19b567a018570417be3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga941d2e26e203e19b567a018570417be3">GetAngle</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:ga941d2e26e203e19b567a018570417be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle.  <a href="group__Math.html#ga941d2e26e203e19b567a018570417be3">More...</a><br /></td></tr>
<tr class="separator:ga941d2e26e203e19b567a018570417be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007d43d0fd5ce900118dd41e3197d887"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga007d43d0fd5ce900118dd41e3197d887">GetAreaOfCircle</a> (<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a> radius)</td></tr>
<tr class="memdesc:ga007d43d0fd5ce900118dd41e3197d887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a circle. <br /></td></tr>
<tr class="separator:ga007d43d0fd5ce900118dd41e3197d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760effc058042418453697e733937b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga760effc058042418453697e733937b2f">GetAreaOfPolygon</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:ga760effc058042418453697e733937b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a polygon.  <a href="group__Math.html#ga760effc058042418453697e733937b2f">More...</a><br /></td></tr>
<tr class="separator:ga760effc058042418453697e733937b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6119f387b09a5ece4a552f3b3aa1565"><td class="memItemLeft" align="right" valign="top"><a id="ab6119f387b09a5ece4a552f3b3aa1565"></a>
constexpr <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab6119f387b09a5ece4a552f3b3aa1565">GetBodyA</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:ab6119f387b09a5ece4a552f3b3aa1565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the body A ID of the given contact. <br /></td></tr>
<tr class="separator:ab6119f387b09a5ece4a552f3b3aa1565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa747a1797c3953dfc068ce03901695ed"><td class="memItemLeft" align="right" valign="top"><a id="aa747a1797c3953dfc068ce03901695ed"></a>
constexpr <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa747a1797c3953dfc068ce03901695ed">GetBodyB</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:aa747a1797c3953dfc068ce03901695ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the body B ID of the given contact. <br /></td></tr>
<tr class="separator:aa747a1797c3953dfc068ce03901695ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc4cbaff2da580cdaa7f8e2e45c4856"><td class="memItemLeft" align="right" valign="top"><a id="adcc4cbaff2da580cdaa7f8e2e45c4856"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adcc4cbaff2da580cdaa7f8e2e45c4856">GetBuildDetails</a> ()</td></tr>
<tr class="memdesc:adcc4cbaff2da580cdaa7f8e2e45c4856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the build details of the library. <br /></td></tr>
<tr class="separator:adcc4cbaff2da580cdaa7f8e2e45c4856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abbe9590460876ec82bf7dd801fb1f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = decltype(Interval&lt;T&gt;{}, ((T{} + T{}) / 2))&gt; </td></tr>
<tr class="memitem:a8abbe9590460876ec82bf7dd801fb1f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8abbe9590460876ec82bf7dd801fb1f0">GetCenter</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;v) noexcept(noexcept((v.GetMin()+v.GetMax())/2))</td></tr>
<tr class="memdesc:a8abbe9590460876ec82bf7dd801fb1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the center of the given interval.  <a href="namespaceplayrho.html#a8abbe9590460876ec82bf7dd801fb1f0">More...</a><br /></td></tr>
<tr class="separator:a8abbe9590460876ec82bf7dd801fb1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e63c4946d742afab47f8a1c00ae2a8a"><td class="memItemLeft" align="right" valign="top"><a id="a2e63c4946d742afab47f8a1c00ae2a8a"></a>
constexpr <a class="el" href="namespaceplayrho.html#a0e937a573db2db27b95156590ef5dd12">ChildCounter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2e63c4946d742afab47f8a1c00ae2a8a">GetChildIndexA</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a2e63c4946d742afab47f8a1c00ae2a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the child index A of the given contact. <br /></td></tr>
<tr class="separator:a2e63c4946d742afab47f8a1c00ae2a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676e6537b55110a4aa43e3e0a113f8b9"><td class="memItemLeft" align="right" valign="top"><a id="a676e6537b55110a4aa43e3e0a113f8b9"></a>
constexpr <a class="el" href="namespaceplayrho.html#a0e937a573db2db27b95156590ef5dd12">ChildCounter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a676e6537b55110a4aa43e3e0a113f8b9">GetChildIndexB</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a676e6537b55110a4aa43e3e0a113f8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the child index B of the given contact. <br /></td></tr>
<tr class="separator:a676e6537b55110a4aa43e3e0a113f8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338c586cf1a29f27ee334d061fa59b5d"><td class="memItemLeft" align="right" valign="top">
std::vector&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga338c586cf1a29f27ee334d061fa59b5d">GetCircleVertices</a> (<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a> radius, std::size_t slices, <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> start=0_deg, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> turns=<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1))</td></tr>
<tr class="memdesc:ga338c586cf1a29f27ee334d061fa59b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertices for a circle described by the given parameters. <br /></td></tr>
<tr class="separator:ga338c586cf1a29f27ee334d061fa59b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d367e915b012ac8ebfdbfd2817a40ae"><td class="memTemplParams" colspan="2"><a id="a9d367e915b012ac8ebfdbfd2817a40ae"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9d367e915b012ac8ebfdbfd2817a40ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, 1 &gt;, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9d367e915b012ac8ebfdbfd2817a40ae">GetColumnMatrix</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; arg)</td></tr>
<tr class="memdesc:a9d367e915b012ac8ebfdbfd2817a40ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified column of the given matrix as a column matrix. <br /></td></tr>
<tr class="separator:a9d367e915b012ac8ebfdbfd2817a40ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081dbfc95d4d3139eb2817a1f11a5af3"><td class="memItemLeft" align="right" valign="top"><a id="a081dbfc95d4d3139eb2817a1f11a5af3"></a>
constexpr <a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a081dbfc95d4d3139eb2817a1f11a5af3">GetDefaultPositionSolverConf</a> () noexcept</td></tr>
<tr class="memdesc:a081dbfc95d4d3139eb2817a1f11a5af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default position solver configuration. <br /></td></tr>
<tr class="separator:a081dbfc95d4d3139eb2817a1f11a5af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd2e3047d7ac0836f8921a496e8d432"><td class="memItemLeft" align="right" valign="top"><a id="a4dd2e3047d7ac0836f8921a496e8d432"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4dd2e3047d7ac0836f8921a496e8d432">GetDefaultToiConf</a> ()</td></tr>
<tr class="memdesc:a4dd2e3047d7ac0836f8921a496e8d432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default time of impact configuration. <br /></td></tr>
<tr class="separator:a4dd2e3047d7ac0836f8921a496e8d432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b5137ea90045d15dfb2279d5773b46"><td class="memItemLeft" align="right" valign="top"><a id="a56b5137ea90045d15dfb2279d5773b46"></a>
constexpr <a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a56b5137ea90045d15dfb2279d5773b46">GetDefaultToiPositionSolverConf</a> () noexcept</td></tr>
<tr class="memdesc:a56b5137ea90045d15dfb2279d5773b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default TOI position solver configuration. <br /></td></tr>
<tr class="separator:a56b5137ea90045d15dfb2279d5773b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64fefdeb5b40b3ee00c30dc263397b9"><td class="memItemLeft" align="right" valign="top"><a id="aa64fefdeb5b40b3ee00c30dc263397b9"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa64fefdeb5b40b3ee00c30dc263397b9">GetFaceFaceContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:aa64fefdeb5b40b3ee00c30dc263397b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the face face contact feature for the given indices. <br /></td></tr>
<tr class="separator:aa64fefdeb5b40b3ee00c30dc263397b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874b42008ce4794858edc982ba13534a"><td class="memItemLeft" align="right" valign="top"><a id="a874b42008ce4794858edc982ba13534a"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a874b42008ce4794858edc982ba13534a">GetFaceVertexContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:a874b42008ce4794858edc982ba13534a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the face vertex contact feature for the given indices. <br /></td></tr>
<tr class="separator:a874b42008ce4794858edc982ba13534a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memTemplParams" colspan="2"><a id="a24de24fa4d8c10dea7826ce11c81ff36"></a>
template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a24de24fa4d8c10dea7826ce11c81ff36">GetFirstShapeVertexIdx</a> (const <a class="el" href="structplayrho_1_1detail_1_1SeparationInfo.html">detail::SeparationInfo</a>&lt; N &gt; &amp;info) noexcept</td></tr>
<tr class="memdesc:a24de24fa4d8c10dea7826ce11c81ff36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets first shape vertex index. <br /></td></tr>
<tr class="separator:a24de24fa4d8c10dea7826ce11c81ff36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3bad8be42524709861c9e728048ea2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1e3bad8be42524709861c9e728048ea2">GetFriction</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a1e3bad8be42524709861c9e728048ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the coefficient of friction.  <a href="namespaceplayrho.html#a1e3bad8be42524709861c9e728048ea2">More...</a><br /></td></tr>
<tr class="separator:a1e3bad8be42524709861c9e728048ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25080522fd228616931476a49b5295d3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a25080522fd228616931476a49b5295d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a25080522fd228616931476a49b5295d3">GetFwdPerpendicular</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;vector) noexcept -&gt; <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a25080522fd228616931476a49b5295d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.  <a href="namespaceplayrho.html#a25080522fd228616931476a49b5295d3">More...</a><br /></td></tr>
<tr class="separator:a25080522fd228616931476a49b5295d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d41854b91fcfb6b8ea05e7b8c92e304"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga5d41854b91fcfb6b8ea05e7b8c92e304">GetFwdRotationalAngle</a> (const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a1, const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a2) noexcept</td></tr>
<tr class="memdesc:ga5d41854b91fcfb6b8ea05e7b8c92e304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the forward/clockwise rotational angle to go from angle 1 to angle 2.  <a href="group__Math.html#ga5d41854b91fcfb6b8ea05e7b8c92e304">More...</a><br /></td></tr>
<tr class="separator:ga5d41854b91fcfb6b8ea05e7b8c92e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2ccc0dc9ac07175382084cee633e49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff2ccc0dc9ac07175382084cee633e49"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a14b74d27a9f43c1f37aca5ee84aa6f97">IsSquareMatrixV</a>&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aff2ccc0dc9ac07175382084cee633e49">GetIdentity</a> ()</td></tr>
<tr class="memdesc:aff2ccc0dc9ac07175382084cee633e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the identity matrix of the template type and size as given by the argument.  <a href="namespaceplayrho.html#aff2ccc0dc9ac07175382084cee633e49">More...</a><br /></td></tr>
<tr class="separator:aff2ccc0dc9ac07175382084cee633e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b372974bcf478fe0254a0a29a2dd14"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a40b372974bcf478fe0254a0a29a2dd14"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T &gt;, <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, N, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a40b372974bcf478fe0254a0a29a2dd14">GetIdentityMatrix</a> ()</td></tr>
<tr class="memdesc:a40b372974bcf478fe0254a0a29a2dd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the identity matrix of the template type and size.  <a href="namespaceplayrho.html#a40b372974bcf478fe0254a0a29a2dd14">More...</a><br /></td></tr>
<tr class="separator:a40b372974bcf478fe0254a0a29a2dd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="memTemplParams" colspan="2"><a id="a4baf1dd76711ae5151d0ee07a8b345d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4baf1dd76711ae5151d0ee07a8b345d0">GetIntersection</a> (<a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the intersecting interval of two given ranges. <br /></td></tr>
<tr class="separator:a4baf1dd76711ae5151d0ee07a8b345d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9354b34edeb8433cd3062aecb78143"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0a9354b34edeb8433cd3062aecb78143">GetInverse22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept -&gt; <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a></td></tr>
<tr class="memdesc:ga0a9354b34edeb8433cd3062aecb78143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the inverse of the given matrix as a 2-by-2.  <a href="group__Math.html#ga0a9354b34edeb8433cd3062aecb78143">More...</a><br /></td></tr>
<tr class="separator:ga0a9354b34edeb8433cd3062aecb78143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gafe323c1c5ab88d30d18413a3c1f10abb">GetMagnitude</a> (const T &amp;value) noexcept(noexcept(sqrt(<a class="el" href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">GetMagnitudeSquared</a>(value)))) -&gt; decltype(sqrt(<a class="el" href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">GetMagnitudeSquared</a>(value)))</td></tr>
<tr class="memdesc:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the magnitude of the given value.  <a href="group__Math.html#gafe323c1c5ab88d30d18413a3c1f10abb">More...</a><br /></td></tr>
<tr class="separator:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36866f7061dfa4d056405aa5da0daf84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36866f7061dfa4d056405aa5da0daf84"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">GetMagnitudeSquared</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:ga36866f7061dfa4d056405aa5da0daf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the magnitude of the given iterable value.  <a href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">More...</a><br /></td></tr>
<tr class="separator:ga36866f7061dfa4d056405aa5da0daf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f543b42eadf60ef9e730edc77912c"><td class="memItemLeft" align="right" valign="top"><a id="a396f543b42eadf60ef9e730edc77912c"></a>
<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a396f543b42eadf60ef9e730edc77912c">GetMaxRegLinearCorrection</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a396f543b42eadf60ef9e730edc77912c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum regular linear correction from the given value. <br /></td></tr>
<tr class="separator:a396f543b42eadf60ef9e730edc77912c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga81dbf936e69c8d2ecc9ca3600c6be3a1">GetModuloNext</a> (T value, const T count) noexcept -&gt; decltype(++value,(value&lt; count)? value:static_cast&lt; T &gt;(0), T())</td></tr>
<tr class="memdesc:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo next value.  <a href="group__Math.html#ga81dbf936e69c8d2ecc9ca3600c6be3a1">More...</a><br /></td></tr>
<tr class="separator:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga6434759234bd5e94759bf10cc4eb5ac5">GetModuloPrev</a> (const T value, const T count) noexcept -&gt; decltype((value ? value :count) - static_cast&lt; T &gt;(1), T())</td></tr>
<tr class="memdesc:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo previous value.  <a href="group__Math.html#ga6434759234bd5e94759bf10cc4eb5ac5">More...</a><br /></td></tr>
<tr class="separator:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43351fde9d622f4762a47e6618daf2f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a43351fde9d622f4762a47e6618daf2f7">GetMovementConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a43351fde9d622f4762a47e6618daf2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the movement configuration from the given value.  <a href="namespaceplayrho.html#a43351fde9d622f4762a47e6618daf2f7">More...</a><br /></td></tr>
<tr class="separator:a43351fde9d622f4762a47e6618daf2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ed2f85beec0b69745b971ce3d028ac"><td class="memItemLeft" align="right" valign="top"><a id="a64ed2f85beec0b69745b971ce3d028ac"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a64ed2f85beec0b69745b971ce3d028ac">GetName</a> (const <a class="el" href="classplayrho_1_1TypeID.html">TypeID</a> &amp;id) noexcept</td></tr>
<tr class="memdesc:a64ed2f85beec0b69745b971ce3d028ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name associated with the given type ID. <br /></td></tr>
<tr class="separator:a64ed2f85beec0b69745b971ce3d028ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6b450f2f1fb0bad7e9cd47269e33c6"><td class="memItemLeft" align="right" valign="top"><a id="a4f6b450f2f1fb0bad7e9cd47269e33c6"></a>
constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4f6b450f2f1fb0bad7e9cd47269e33c6">GetName</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#afd2b1a5d28a16fc49261c39d8cebabc0">ContactFeature::Type</a> type) noexcept</td></tr>
<tr class="memdesc:a4f6b450f2f1fb0bad7e9cd47269e33c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the human readable name for the given contact feature type. <br /></td></tr>
<tr class="separator:a4f6b450f2f1fb0bad7e9cd47269e33c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04315ff1bed5ea49e5a0990893e7976"><td class="memItemLeft" align="right" valign="top"><a id="ad04315ff1bed5ea49e5a0990893e7976"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad04315ff1bed5ea49e5a0990893e7976">GetName</a> (<a class="el" href="structplayrho_1_1ToiOutput.html#a61ba03d1326b88ed12049500df7ca76f">ToiOutput::State</a> state) noexcept</td></tr>
<tr class="memdesc:ad04315ff1bed5ea49e5a0990893e7976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a human readable name for the given output state. <br /></td></tr>
<tr class="separator:ad04315ff1bed5ea49e5a0990893e7976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156a2abff11f978a8df25efbf0c10147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">GetNormalized</a> (<a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> value) noexcept</td></tr>
<tr class="memdesc:ga156a2abff11f978a8df25efbf0c10147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" value of the given angle.  <a href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">More...</a><br /></td></tr>
<tr class="separator:ga156a2abff11f978a8df25efbf0c10147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad136f8db9fd6c0c583c1890b8a3cc504"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) noexcept</td></tr>
<tr class="memdesc:ad136f8db9fd6c0c583c1890b8a3cc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of valid indices in the given collection of index pairs.  <a href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">More...</a><br /></td></tr>
<tr class="separator:ad136f8db9fd6c0c583c1890b8a3cc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ddd62df538578a056ac976e42d9739"><td class="memItemLeft" align="right" valign="top"><a id="ae8ddd62df538578a056ac976e42d9739"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae8ddd62df538578a056ac976e42d9739">GetOtherBody</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;c, <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> bodyID) noexcept</td></tr>
<tr class="memdesc:ae8ddd62df538578a056ac976e42d9739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the other body ID for the contact than the one given. <br /></td></tr>
<tr class="separator:ae8ddd62df538578a056ac976e42d9739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee743e28b24b01d9101b8a2e7bd72284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#ga687546b31c191aeeacf223bdbebe6747">SecondMomentOfArea</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaee743e28b24b01d9101b8a2e7bd72284">GetPolarMoment</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gaee743e28b24b01d9101b8a2e7bd72284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the polar moment of the area enclosed by the given vertices.  <a href="group__Math.html#gaee743e28b24b01d9101b8a2e7bd72284">More...</a><br /></td></tr>
<tr class="separator:gaee743e28b24b01d9101b8a2e7bd72284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf6573afe5f3fb0803faa353dc9c65"><td class="memItemLeft" align="right" valign="top"><a id="aacaf6573afe5f3fb0803faa353dc9c65"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aacaf6573afe5f3fb0803faa353dc9c65">GetRegConstraintSolverConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:aacaf6573afe5f3fb0803faa353dc9c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the regular phase constraint solver configuration for the given step configuration. <br /></td></tr>
<tr class="separator:aacaf6573afe5f3fb0803faa353dc9c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8623a4509113eb33f84ea8aba436396e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8623a4509113eb33f84ea8aba436396e">GetRestitution</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a8623a4509113eb33f84ea8aba436396e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the coefficient of restitution.  <a href="namespaceplayrho.html#a8623a4509113eb33f84ea8aba436396e">More...</a><br /></td></tr>
<tr class="separator:a8623a4509113eb33f84ea8aba436396e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6526ea72d722d9cccd28199e6e917fb3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6526ea72d722d9cccd28199e6e917fb3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6526ea72d722d9cccd28199e6e917fb3">GetRevPerpendicular</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;vector) noexcept -&gt; <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a6526ea72d722d9cccd28199e6e917fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.  <a href="namespaceplayrho.html#a6526ea72d722d9cccd28199e6e917fb3">More...</a><br /></td></tr>
<tr class="separator:a6526ea72d722d9cccd28199e6e917fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1413e02cc41bf9943071baa2ae242c27"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1413e02cc41bf9943071baa2ae242c27">GetRevRotationalAngle</a> (const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a1, const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a2) noexcept</td></tr>
<tr class="memdesc:ga1413e02cc41bf9943071baa2ae242c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2.  <a href="group__Math.html#ga1413e02cc41bf9943071baa2ae242c27">More...</a><br /></td></tr>
<tr class="separator:ga1413e02cc41bf9943071baa2ae242c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38be88271d1aa1c71ad994a9d5e1df77"><td class="memTemplParams" colspan="2"><a id="a38be88271d1aa1c71ad994a9d5e1df77"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a38be88271d1aa1c71ad994a9d5e1df77"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt;, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a38be88271d1aa1c71ad994a9d5e1df77">GetRowMatrix</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; arg)</td></tr>
<tr class="memdesc:a38be88271d1aa1c71ad994a9d5e1df77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified row of the given matrix as a row matrix. <br /></td></tr>
<tr class="separator:a38be88271d1aa1c71ad994a9d5e1df77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memTemplParams" colspan="2"><a id="a435b2e5c84e285bf7f0ac9486c2512d3"></a>
template&lt;VertexCounter M, std::size_t N&gt; </td></tr>
<tr class="memitem:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a435b2e5c84e285bf7f0ac9486c2512d3">GetSecondShapeVertexIdx</a> (const <a class="el" href="structplayrho_1_1detail_1_1SeparationInfo.html">detail::SeparationInfo</a>&lt; N &gt; &amp;info) noexcept</td></tr>
<tr class="memdesc:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets second shape vertex indices. <br /></td></tr>
<tr class="separator:a435b2e5c84e285bf7f0ac9486c2512d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3905c9d50e61b110388dcf71176cd1fe"><td class="memItemLeft" align="right" valign="top"><a id="a3905c9d50e61b110388dcf71176cd1fe"></a>
constexpr <a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3905c9d50e61b110388dcf71176cd1fe">GetShapeA</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a3905c9d50e61b110388dcf71176cd1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shape A associated with the given contact. <br /></td></tr>
<tr class="separator:a3905c9d50e61b110388dcf71176cd1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bff0722b0746e1ba9d6cf2015e4bc95"><td class="memItemLeft" align="right" valign="top"><a id="a1bff0722b0746e1ba9d6cf2015e4bc95"></a>
constexpr <a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1bff0722b0746e1ba9d6cf2015e4bc95">GetShapeB</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a1bff0722b0746e1ba9d6cf2015e4bc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shape B associated with the given contact. <br /></td></tr>
<tr class="separator:a1bff0722b0746e1ba9d6cf2015e4bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b72aa4a587e552a586a42494d614c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gac9b72aa4a587e552a586a42494d614c1">GetShortestDelta</a> (<a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> a0, <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> a1) noexcept</td></tr>
<tr class="memdesc:gac9b72aa4a587e552a586a42494d614c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest angular distance to go from angle 0 to angle 1.  <a href="group__Math.html#gac9b72aa4a587e552a586a42494d614c1">More...</a><br /></td></tr>
<tr class="separator:gac9b72aa4a587e552a586a42494d614c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b898ee30ff659e61f3bfdcc78cc233"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = decltype(Interval&lt;T&gt;{}, (T{} - T{}))&gt; </td></tr>
<tr class="memitem:a64b898ee30ff659e61f3bfdcc78cc233"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a64b898ee30ff659e61f3bfdcc78cc233">GetSize</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;v) noexcept(noexcept(v.GetMax() - v.GetMin()))</td></tr>
<tr class="memdesc:a64b898ee30ff659e61f3bfdcc78cc233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the given interval.  <a href="namespaceplayrho.html#a64b898ee30ff659e61f3bfdcc78cc233">More...</a><br /></td></tr>
<tr class="separator:a64b898ee30ff659e61f3bfdcc78cc233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39333b6fc4de2a8f365b74194e42ceef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga39333b6fc4de2a8f365b74194e42ceef">GetSymInverse33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept -&gt; <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a></td></tr>
<tr class="memdesc:ga39333b6fc4de2a8f365b74194e42ceef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the symmetric inverse of this matrix as a 3-by-3.  <a href="group__Math.html#ga39333b6fc4de2a8f365b74194e42ceef">More...</a><br /></td></tr>
<tr class="separator:ga39333b6fc4de2a8f365b74194e42ceef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568a3fc3585eb44878213a919420f847"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a568a3fc3585eb44878213a919420f847">GetTangentSpeed</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a568a3fc3585eb44878213a919420f847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the desired tangent speed.  <a href="namespaceplayrho.html#a568a3fc3585eb44878213a919420f847">More...</a><br /></td></tr>
<tr class="separator:a568a3fc3585eb44878213a919420f847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd05d6b92912a6430c09ad8a74bcbc73"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acd05d6b92912a6430c09ad8a74bcbc73">GetToi</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:acd05d6b92912a6430c09ad8a74bcbc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time of impact (TOI) as a fraction.  <a href="namespaceplayrho.html#acd05d6b92912a6430c09ad8a74bcbc73">More...</a><br /></td></tr>
<tr class="separator:acd05d6b92912a6430c09ad8a74bcbc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9864179cb9a35cb6665d429656ad0e9b"><td class="memItemLeft" align="right" valign="top"><a id="a9864179cb9a35cb6665d429656ad0e9b"></a>
<a class="el" href="structplayrho_1_1ToiConf.html">ToiConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9864179cb9a35cb6665d429656ad0e9b">GetToiConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:a9864179cb9a35cb6665d429656ad0e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time of impact configuration for the given step configuration. <br /></td></tr>
<tr class="separator:a9864179cb9a35cb6665d429656ad0e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8daa84d36ac948934ee05eb4cb242"><td class="memItemLeft" align="right" valign="top"><a id="afdb8daa84d36ac948934ee05eb4cb242"></a>
<a class="el" href="structplayrho_1_1ConstraintSolverConf.html">ConstraintSolverConf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#afdb8daa84d36ac948934ee05eb4cb242">GetToiConstraintSolverConf</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:afdb8daa84d36ac948934ee05eb4cb242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the TOI phase constraint solver configuration for the given step configuration. <br /></td></tr>
<tr class="separator:afdb8daa84d36ac948934ee05eb4cb242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce1723933df3c7d4054975daa7ac724"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abce1723933df3c7d4054975daa7ac724">GetToiCount</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:abce1723933df3c7d4054975daa7ac724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time of impact count.  <a href="namespaceplayrho.html#abce1723933df3c7d4054975daa7ac724">More...</a><br /></td></tr>
<tr class="separator:abce1723933df3c7d4054975daa7ac724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d832d9a5d4ee71d8ab03b1f07d46c5"><td class="memTemplParams" colspan="2"><a id="a23d832d9a5d4ee71d8ab03b1f07d46c5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23d832d9a5d4ee71d8ab03b1f07d46c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1TypeID.html">TypeID</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a23d832d9a5d4ee71d8ab03b1f07d46c5">GetTypeID</a> () noexcept</td></tr>
<tr class="memdesc:a23d832d9a5d4ee71d8ab03b1f07d46c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type ID for the function's template parameter type with its name demangled. <br /></td></tr>
<tr class="separator:a23d832d9a5d4ee71d8ab03b1f07d46c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87b4d8c11b416f868a72b7c43463adb"><td class="memTemplParams" colspan="2"><a id="ac87b4d8c11b416f868a72b7c43463adb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac87b4d8c11b416f868a72b7c43463adb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1TypeID.html">TypeID</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac87b4d8c11b416f868a72b7c43463adb">GetTypeID</a> (const T &amp;) noexcept</td></tr>
<tr class="memdesc:ac87b4d8c11b416f868a72b7c43463adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type ID for the function parameter type with its name demangled. <br /></td></tr>
<tr class="separator:ac87b4d8c11b416f868a72b7c43463adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267edfe760bf1c787ca0487b93e0c719"><td class="memTemplParams" colspan="2"><a id="a267edfe760bf1c787ca0487b93e0c719"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a267edfe760bf1c787ca0487b93e0c719"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a267edfe760bf1c787ca0487b93e0c719">GetTypeName</a> () noexcept</td></tr>
<tr class="memdesc:a267edfe760bf1c787ca0487b93e0c719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name associated with the given template parameter type. <br /></td></tr>
<tr class="separator:a267edfe760bf1c787ca0487b93e0c719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60cf2dee0c139d2d97580c0620819ab"><td class="memItemLeft" align="right" valign="top"><a id="ae60cf2dee0c139d2d97580c0620819ab"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae60cf2dee0c139d2d97580c0620819ab">GetVec2</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt; &amp;value) -&gt; <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a></td></tr>
<tr class="memdesc:ae60cf2dee0c139d2d97580c0620819ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the given value as a 2-element vector of reals (<code>Vec2</code>). <br /></td></tr>
<tr class="separator:ae60cf2dee0c139d2d97580c0620819ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e07128f6626a7f9dbe5e973a9fba19"><td class="memTemplParams" colspan="2"><a id="a54e07128f6626a7f9dbe5e973a9fba19"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a54e07128f6626a7f9dbe5e973a9fba19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a54e07128f6626a7f9dbe5e973a9fba19">GetVec2</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>{static_cast&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 0 &gt;(value).value()), static_cast&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 1 &gt;(value).value())})</td></tr>
<tr class="memdesc:a54e07128f6626a7f9dbe5e973a9fba19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets value as 2-element vector of reals for any type having <code>value()</code> member function. <br /></td></tr>
<tr class="separator:a54e07128f6626a7f9dbe5e973a9fba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ad5413c876b34dcf8430c045986cc"><td class="memItemLeft" align="right" valign="top"><a id="af43ad5413c876b34dcf8430c045986cc"></a>
<a class="el" href="structplayrho_1_1Version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af43ad5413c876b34dcf8430c045986cc">GetVersion</a> () noexcept</td></tr>
<tr class="memdesc:af43ad5413c876b34dcf8430c045986cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the version information of the library. <br /></td></tr>
<tr class="separator:af43ad5413c876b34dcf8430c045986cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525adfccea1a81ce8311751fc90d0614"><td class="memItemLeft" align="right" valign="top"><a id="a525adfccea1a81ce8311751fc90d0614"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a525adfccea1a81ce8311751fc90d0614">GetVertexFaceContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:a525adfccea1a81ce8311751fc90d0614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex face contact feature for the given indices. <br /></td></tr>
<tr class="separator:a525adfccea1a81ce8311751fc90d0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c8c86c92d71e89dd707af00b1de6a8"><td class="memItemLeft" align="right" valign="top"><a id="ad0c8c86c92d71e89dd707af00b1de6a8"></a>
constexpr <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad0c8c86c92d71e89dd707af00b1de6a8">GetVertexVertexContactFeature</a> (<a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> a, <a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041">ContactFeature::Index</a> b) noexcept</td></tr>
<tr class="memdesc:ad0c8c86c92d71e89dd707af00b1de6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertex vertex contact feature for the given indices. <br /></td></tr>
<tr class="separator:ad0c8c86c92d71e89dd707af00b1de6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97da0937ffb65980d65b6ce06e839f3f"><td class="memTemplParams" colspan="2"><a id="a97da0937ffb65980d65b6ce06e839f3f"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a97da0937ffb65980d65b6ce06e839f3f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a97da0937ffb65980d65b6ce06e839f3f">GetX</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 0 &gt;(value))</td></tr>
<tr class="memdesc:a97da0937ffb65980d65b6ce06e839f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "X" element of the given value - i.e. the first element. <br /></td></tr>
<tr class="separator:a97da0937ffb65980d65b6ce06e839f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa756520228b8263fe552931f66882d39"><td class="memTemplParams" colspan="2"><a id="aa756520228b8263fe552931f66882d39"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa756520228b8263fe552931f66882d39"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa756520228b8263fe552931f66882d39">GetX</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 0 &gt;(value))</td></tr>
<tr class="memdesc:aa756520228b8263fe552931f66882d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "X" element of the given value - i.e. the first element. <br /></td></tr>
<tr class="separator:aa756520228b8263fe552931f66882d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048efa57c5e7a10eec78126f8d0f3ab4"><td class="memTemplParams" colspan="2"><a id="a048efa57c5e7a10eec78126f8d0f3ab4"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a048efa57c5e7a10eec78126f8d0f3ab4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a048efa57c5e7a10eec78126f8d0f3ab4">GetY</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 1 &gt;(value))</td></tr>
<tr class="memdesc:a048efa57c5e7a10eec78126f8d0f3ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Y" element of the given value - i.e. the second element. <br /></td></tr>
<tr class="separator:a048efa57c5e7a10eec78126f8d0f3ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653020af6186410ade265e09b6196ca5"><td class="memTemplParams" colspan="2"><a id="a653020af6186410ade265e09b6196ca5"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a653020af6186410ade265e09b6196ca5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a653020af6186410ade265e09b6196ca5">GetY</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 1 &gt;(value))</td></tr>
<tr class="memdesc:a653020af6186410ade265e09b6196ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Y" element of the given value - i.e. the second element. <br /></td></tr>
<tr class="separator:a653020af6186410ade265e09b6196ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca6251fe41049230563ab530a9e7f81"><td class="memTemplParams" colspan="2"><a id="a3ca6251fe41049230563ab530a9e7f81"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a3ca6251fe41049230563ab530a9e7f81"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3ca6251fe41049230563ab530a9e7f81">GetZ</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 2 &gt;(value))</td></tr>
<tr class="memdesc:a3ca6251fe41049230563ab530a9e7f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Z" element of the given value - i.e. the third element. <br /></td></tr>
<tr class="separator:a3ca6251fe41049230563ab530a9e7f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58db5b079020b9fbf4fbb674a7eb01d"><td class="memTemplParams" colspan="2"><a id="ab58db5b079020b9fbf4fbb674a7eb01d"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab58db5b079020b9fbf4fbb674a7eb01d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab58db5b079020b9fbf4fbb674a7eb01d">GetZ</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#aa10d9373a7aa5e3492fee0877900f738">get</a>&lt; 2 &gt;(value))</td></tr>
<tr class="memdesc:ab58db5b079020b9fbf4fbb674a7eb01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "Z" element of the given value - i.e. the third element. <br /></td></tr>
<tr class="separator:ab58db5b079020b9fbf4fbb674a7eb01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e830664360ead07ab616d934ff2550"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a77e830664360ead07ab616d934ff2550">HasValidToi</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a77e830664360ead07ab616d934ff2550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a TOI is set.  <a href="namespaceplayrho.html#a77e830664360ead07ab616d934ff2550">More...</a><br /></td></tr>
<tr class="separator:a77e830664360ead07ab616d934ff2550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c69326c22bafb811d6e00b9e6966cc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga68c69326c22bafb811d6e00b9e6966cc">InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="separator:ga68c69326c22bafb811d6e00b9e6966cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01639d99c5401d526aeb5c6df075e153"><td class="memTemplParams" colspan="2">
template&lt;class IN_TYPE &gt; </td></tr>
<tr class="memitem:ga01639d99c5401d526aeb5c6df075e153"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga01639d99c5401d526aeb5c6df075e153">Invert</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; IN_TYPE &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga01639d99c5401d526aeb5c6df075e153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the given value. <br /></td></tr>
<tr class="separator:ga01639d99c5401d526aeb5c6df075e153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6514752c0838613cfaf76ea7e03581cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd">IsAccelerable</a> (<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a> type)</td></tr>
<tr class="memdesc:a6514752c0838613cfaf76ea7e03581cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is "accelerable".  <a href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd">More...</a><br /></td></tr>
<tr class="separator:a6514752c0838613cfaf76ea7e03581cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae659e1f443f30d7813853f6763f1f22f"><td class="memItemLeft" align="right" valign="top"><a id="ae659e1f443f30d7813853f6763f1f22f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae659e1f443f30d7813853f6763f1f22f">IsActive</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:ae659e1f443f30d7813853f6763f1f22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given contact is "active". <br /></td></tr>
<tr class="separator:ae659e1f443f30d7813853f6763f1f22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2071b64988e62193b4a2567bdde292"><td class="memItemLeft" align="right" valign="top"><a id="acf2071b64988e62193b4a2567bdde292"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acf2071b64988e62193b4a2567bdde292">IsEnabled</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:acf2071b64988e62193b4a2567bdde292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given contact is enabled or not. <br /></td></tr>
<tr class="separator:acf2071b64988e62193b4a2567bdde292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6f0d8de107567baafd2ff6770ded72"><td class="memTemplParams" colspan="2"><a id="abc6f0d8de107567baafd2ff6770ded72"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc6f0d8de107567baafd2ff6770ded72"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abc6f0d8de107567baafd2ff6770ded72">IsEntirelyAfter</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:abc6f0d8de107567baafd2ff6770ded72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range is entirely after the second range. <br /></td></tr>
<tr class="separator:abc6f0d8de107567baafd2ff6770ded72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537b76dc4bd198e60d148282e032533c"><td class="memTemplParams" colspan="2"><a id="a537b76dc4bd198e60d148282e032533c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a537b76dc4bd198e60d148282e032533c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a537b76dc4bd198e60d148282e032533c">IsEntirelyBefore</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a537b76dc4bd198e60d148282e032533c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range is entirely before the second range. <br /></td></tr>
<tr class="separator:a537b76dc4bd198e60d148282e032533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133337daeb0dd2b8b5a78f42a8a526"><td class="memTemplParams" colspan="2"><a id="a32133337daeb0dd2b8b5a78f42a8a526"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32133337daeb0dd2b8b5a78f42a8a526"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a32133337daeb0dd2b8b5a78f42a8a526">IsEntirelyEnclosing</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a32133337daeb0dd2b8b5a78f42a8a526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the first range entirely encloses the second. <br /></td></tr>
<tr class="separator:a32133337daeb0dd2b8b5a78f42a8a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f91c8a02e1886e4e9f90d0926e075a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa8f91c8a02e1886e4e9f90d0926e075a">IsFor</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;c, <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> bodyID, <a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a> shapeID) noexcept</td></tr>
<tr class="memdesc:aa8f91c8a02e1886e4e9f90d0926e075a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-for convenience function.  <a href="namespaceplayrho.html#aa8f91c8a02e1886e4e9f90d0926e075a">More...</a><br /></td></tr>
<tr class="separator:aa8f91c8a02e1886e4e9f90d0926e075a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283c9f04ceb148910537dc1cd3f37c00"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a283c9f04ceb148910537dc1cd3f37c00">IsFor</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;c, <a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a> shapeID) noexcept</td></tr>
<tr class="memdesc:a283c9f04ceb148910537dc1cd3f37c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-for convenience function.  <a href="namespaceplayrho.html#a283c9f04ceb148910537dc1cd3f37c00">More...</a><br /></td></tr>
<tr class="separator:a283c9f04ceb148910537dc1cd3f37c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078999e2c900ac9ee1b081be6934d5b7"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a078999e2c900ac9ee1b081be6934d5b7">IsFor</a> (const <a class="el" href="structplayrho_1_1Contactable.html">Contactable</a> &amp;c, <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> bodyID, <a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a> shapeID) noexcept</td></tr>
<tr class="memdesc:a078999e2c900ac9ee1b081be6934d5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-for convenience function.  <a href="namespaceplayrho.html#a078999e2c900ac9ee1b081be6934d5b7">More...</a><br /></td></tr>
<tr class="separator:a078999e2c900ac9ee1b081be6934d5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81cfb61a8aae11d28836a542584dd7f"><td class="memItemLeft" align="right" valign="top"><a id="ad81cfb61a8aae11d28836a542584dd7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad81cfb61a8aae11d28836a542584dd7f">IsFullOfBodies</a> (const <a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island)</td></tr>
<tr class="memdesc:ad81cfb61a8aae11d28836a542584dd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given island is full of bodies. <br /></td></tr>
<tr class="separator:ad81cfb61a8aae11d28836a542584dd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0613fe306ae99ce5ca98798c757a3dc2"><td class="memItemLeft" align="right" valign="top"><a id="a0613fe306ae99ce5ca98798c757a3dc2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0613fe306ae99ce5ca98798c757a3dc2">IsFullOfContacts</a> (const <a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island)</td></tr>
<tr class="memdesc:a0613fe306ae99ce5ca98798c757a3dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given island is full of contacts. <br /></td></tr>
<tr class="separator:a0613fe306ae99ce5ca98798c757a3dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885fded7567b0972b4af486e5df9afea"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a885fded7567b0972b4af486e5df9afea">IsImpenetrable</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a885fded7567b0972b4af486e5df9afea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the given contact is "impenetrable".  <a href="namespaceplayrho.html#a885fded7567b0972b4af486e5df9afea">More...</a><br /></td></tr>
<tr class="separator:a885fded7567b0972b4af486e5df9afea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dc0da0330f8a1c23b44b919f02fed7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = decltype(Interval&lt;T&gt;{}, T{} &lt; T{}, T{} &gt;= T{})&gt; </td></tr>
<tr class="memitem:ab9dc0da0330f8a1c23b44b919f02fed7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab9dc0da0330f8a1c23b44b919f02fed7">IsIntersecting</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept(noexcept(T{}&lt; T{}) &amp;&amp;noexcept(T{} &gt;=T{}))</td></tr>
<tr class="memdesc:ab9dc0da0330f8a1c23b44b919f02fed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two value ranges have any intersection/overlap at all.  <a href="namespaceplayrho.html#ab9dc0da0330f8a1c23b44b919f02fed7">More...</a><br /></td></tr>
<tr class="separator:ab9dc0da0330f8a1c23b44b919f02fed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aadd87d13ef022c24b3c4feed422d3"><td class="memItemLeft" align="right" valign="top"><a id="aa0aadd87d13ef022c24b3c4feed422d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa0aadd87d13ef022c24b3c4feed422d3">IsMaxTranslationWithinTolerance</a> (const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;conf) noexcept</td></tr>
<tr class="memdesc:aa0aadd87d13ef022c24b3c4feed422d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the maximum translation is within tolerance. <br /></td></tr>
<tr class="separator:aa0aadd87d13ef022c24b3c4feed422d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fac7df522251c1cc54aeafbfe3b737"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga96fac7df522251c1cc54aeafbfe3b737"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga96fac7df522251c1cc54aeafbfe3b737">IsOdd</a> (const T &amp;val) -&gt; decltype((val % 2) !=T{})</td></tr>
<tr class="memdesc:ga96fac7df522251c1cc54aeafbfe3b737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-odd.  <a href="group__Math.html#ga96fac7df522251c1cc54aeafbfe3b737">More...</a><br /></td></tr>
<tr class="separator:ga96fac7df522251c1cc54aeafbfe3b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga08b9672d78dbe1aa5275a9c514b422f5">IsPowerOfTwo</a> (const T &amp;n) -&gt; decltype(n &amp;&amp;!(n &amp;(n - 1)))</td></tr>
<tr class="memdesc:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the given value is a power of two. <br /></td></tr>
<tr class="separator:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8801b7203d1ab9a06ca349a9d304f3c"><td class="memItemLeft" align="right" valign="top"><a id="ab8801b7203d1ab9a06ca349a9d304f3c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab8801b7203d1ab9a06ca349a9d304f3c">IsSensor</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:ab8801b7203d1ab9a06ca349a9d304f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given contact is for sensors or not. <br /></td></tr>
<tr class="separator:ab8801b7203d1ab9a06ca349a9d304f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2dcc5aeb221351e51ad965e9de893"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893">IsSpeedable</a> (<a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a> type)</td></tr>
<tr class="memdesc:a76e2dcc5aeb221351e51ad965e9de893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is "speedable".  <a href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893">More...</a><br /></td></tr>
<tr class="separator:a76e2dcc5aeb221351e51ad965e9de893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbf667797116ec6c5e84d896f05daa6"><td class="memItemLeft" align="right" valign="top"><a id="aecbf667797116ec6c5e84d896f05daa6"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aecbf667797116ec6c5e84d896f05daa6">IsTouching</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:aecbf667797116ec6c5e84d896f05daa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given contact is touching or not. <br /></td></tr>
<tr class="separator:aecbf667797116ec6c5e84d896f05daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7404128f6225cf6915219bb784c7843"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab7404128f6225cf6915219bb784c7843"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab7404128f6225cf6915219bb784c7843">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ab7404128f6225cf6915219bb784c7843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="namespaceplayrho.html#ab7404128f6225cf6915219bb784c7843">More...</a><br /></td></tr>
<tr class="separator:ab7404128f6225cf6915219bb784c7843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42b14180314ff41872c38c5596970c"><td class="memItemLeft" align="right" valign="top"><a id="adc42b14180314ff41872c38c5596970c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc42b14180314ff41872c38c5596970c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adc42b14180314ff41872c38c5596970c">IsValid</a> (const <a class="el" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:adc42b14180314ff41872c38c5596970c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:adc42b14180314ff41872c38c5596970c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299c547b3a13504426688a0c968e2891"><td class="memItemLeft" align="right" valign="top"><a id="a299c547b3a13504426688a0c968e2891"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a299c547b3a13504426688a0c968e2891"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a299c547b3a13504426688a0c968e2891">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Acceleration.html">d2::Acceleration</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a299c547b3a13504426688a0c968e2891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a299c547b3a13504426688a0c968e2891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab903c93dd80fcff6148a66dbc7c89687"><td class="memItemLeft" align="right" valign="top"><a id="ab903c93dd80fcff6148a66dbc7c89687"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab903c93dd80fcff6148a66dbc7c89687"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab903c93dd80fcff6148a66dbc7c89687">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1Manifold.html">d2::Manifold</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:ab903c93dd80fcff6148a66dbc7c89687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the given manifold is valid. <br /></td></tr>
<tr class="separator:ab903c93dd80fcff6148a66dbc7c89687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4eafabdd97553a750feb39943d629da"><td class="memItemLeft" align="right" valign="top"><a id="aa4eafabdd97553a750feb39943d629da"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa4eafabdd97553a750feb39943d629da"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa4eafabdd97553a750feb39943d629da">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Position.html">d2::Position</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:aa4eafabdd97553a750feb39943d629da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:aa4eafabdd97553a750feb39943d629da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eebf111910b8b036f4caca5e01fcab3"><td class="memItemLeft" align="right" valign="top"><a id="a4eebf111910b8b036f4caca5e01fcab3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4eebf111910b8b036f4caca5e01fcab3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4eebf111910b8b036f4caca5e01fcab3">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Sweep.html">d2::Sweep</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a4eebf111910b8b036f4caca5e01fcab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a4eebf111910b8b036f4caca5e01fcab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdecea4e39775053f705ca921b5080fe"><td class="memItemLeft" align="right" valign="top"><a id="abdecea4e39775053f705ca921b5080fe"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abdecea4e39775053f705ca921b5080fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abdecea4e39775053f705ca921b5080fe">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Transformation.html">d2::Transformation</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:abdecea4e39775053f705ca921b5080fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:abdecea4e39775053f705ca921b5080fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5351f2762c5c98b723679795e0a79287"><td class="memItemLeft" align="right" valign="top"><a id="a5351f2762c5c98b723679795e0a79287"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5351f2762c5c98b723679795e0a79287"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5351f2762c5c98b723679795e0a79287">IsValid</a> (const <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html">d2::UnitVec</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a5351f2762c5c98b723679795e0a79287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a5351f2762c5c98b723679795e0a79287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904477c2aa4c83f49b1c55f393bd79d2"><td class="memItemLeft" align="right" valign="top"><a id="a904477c2aa4c83f49b1c55f393bd79d2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a904477c2aa4c83f49b1c55f393bd79d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a904477c2aa4c83f49b1c55f393bd79d2">IsValid</a> (const <a class="el" href="structplayrho_1_1d2_1_1Velocity.html">d2::Velocity</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a904477c2aa4c83f49b1c55f393bd79d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a904477c2aa4c83f49b1c55f393bd79d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7144be2e84f00033cbbadfae783092ed"><td class="memItemLeft" align="right" valign="top"><a id="a7144be2e84f00033cbbadfae783092ed"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7144be2e84f00033cbbadfae783092ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7144be2e84f00033cbbadfae783092ed">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a7144be2e84f00033cbbadfae783092ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a7144be2e84f00033cbbadfae783092ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0fa02e6b0d55e9363ad4afb89a755fc1">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid.  <a href="namespaceplayrho.html#a0fa02e6b0d55e9363ad4afb89a755fc1">More...</a><br /></td></tr>
<tr class="separator:a0fa02e6b0d55e9363ad4afb89a755fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaa90580702a0b52b67e21d863eaf83"><td class="memItemLeft" align="right" valign="top"><a id="abcaa90580702a0b52b67e21d863eaf83"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abcaa90580702a0b52b67e21d863eaf83"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abcaa90580702a0b52b67e21d863eaf83">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a> &amp;value) noexcept</td></tr>
<tr class="memdesc:abcaa90580702a0b52b67e21d863eaf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:abcaa90580702a0b52b67e21d863eaf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048e0ad2c0fac1472430520c115466eb"><td class="memItemLeft" align="right" valign="top"><a id="a048e0ad2c0fac1472430520c115466eb"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a048e0ad2c0fac1472430520c115466eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a048e0ad2c0fac1472430520c115466eb">IsValid</a> (const std::size_t &amp;value) noexcept</td></tr>
<tr class="memdesc:a048e0ad2c0fac1472430520c115466eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a048e0ad2c0fac1472430520c115466eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="memTemplParams" colspan="2"><a id="a7dde95b5e9b50eb6552368d0c57cfc88"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7dde95b5e9b50eb6552368d0c57cfc88">IsValid</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given value is valid. <br /></td></tr>
<tr class="separator:a7dde95b5e9b50eb6552368d0c57cfc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="memTemplParams" colspan="2"><a id="ab698eb521c2d14d3d88ee3ac4cacd7c6"></a>
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab698eb521c2d14d3d88ee3ac4cacd7c6">IsValid</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; TYPE &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given vector contains finite coordinates. <br /></td></tr>
<tr class="separator:ab698eb521c2d14d3d88ee3ac4cacd7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee56c4a29a6dd23450e8be8027929f6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee56c4a29a6dd23450e8be8027929f6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aee56c4a29a6dd23450e8be8027929f6c">MakeUnsigned</a> (const T &amp;arg) noexcept -&gt; std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, std::make_unsigned_t&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:aee56c4a29a6dd23450e8be8027929f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the given <b>value</b> into an <b>unsigned value</b>.  <a href="namespaceplayrho.html#aee56c4a29a6dd23450e8be8027929f6c">More...</a><br /></td></tr>
<tr class="separator:aee56c4a29a6dd23450e8be8027929f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32367e964a575ebee3ed45c8ddb0afe"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac32367e964a575ebee3ed45c8ddb0afe">max_size</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) -&gt; decltype(pairs.max_size())</td></tr>
<tr class="memdesc:ac32367e964a575ebee3ed45c8ddb0afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum size of the given container of index pairs.  <a href="namespaceplayrho.html#ac32367e964a575ebee3ed45c8ddb0afe">More...</a><br /></td></tr>
<tr class="separator:ac32367e964a575ebee3ed45c8ddb0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fce5cef2c9f11a5e880c1f6b54bb80f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2fce5cef2c9f11a5e880c1f6b54bb80f">MixFriction</a> (<a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt; friction1, <a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt; friction2)</td></tr>
<tr class="memdesc:a2fce5cef2c9f11a5e880c1f6b54bb80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes friction.  <a href="namespaceplayrho.html#a2fce5cef2c9f11a5e880c1f6b54bb80f">More...</a><br /></td></tr>
<tr class="separator:a2fce5cef2c9f11a5e880c1f6b54bb80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99b1684f31a12e9151c9abeafdc74fe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af99b1684f31a12e9151c9abeafdc74fe">MixRestitution</a> (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> restitution1, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> restitution2) noexcept</td></tr>
<tr class="memdesc:af99b1684f31a12e9151c9abeafdc74fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mixes restitution.  <a href="namespaceplayrho.html#af99b1684f31a12e9151c9abeafdc74fe">More...</a><br /></td></tr>
<tr class="separator:af99b1684f31a12e9151c9abeafdc74fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab53c16bcb68dd36d3b18027a2ac6b1b2">ModuloViaFmod</a> (T dividend, T divisor)</td></tr>
<tr class="memdesc:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::fmod</code>.  <a href="group__Math.html#gab53c16bcb68dd36d3b18027a2ac6b1b2">More...</a><br /></td></tr>
<tr class="separator:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">ModuloViaTrunc</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::trunc</code>.  <a href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">More...</a><br /></td></tr>
<tr class="separator:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471bae6413067374ab8d8262533e402"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gab471bae6413067374ab8d8262533e402">MulT</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gab471bae6413067374ab8d8262533e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A^T * B. <br /></td></tr>
<tr class="separator:gab471bae6413067374ab8d8262533e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b68ee2dcf7f21577269938c5267f5f"><td class="memItemLeft" align="right" valign="top"><a id="a92b68ee2dcf7f21577269938c5267f5f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a92b68ee2dcf7f21577269938c5267f5f">NeedsFiltering</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a92b68ee2dcf7f21577269938c5267f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the contact needs filtering. <br /></td></tr>
<tr class="separator:a92b68ee2dcf7f21577269938c5267f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00846636a226626c5dd4151893f397f7"><td class="memItemLeft" align="right" valign="top"><a id="a00846636a226626c5dd4151893f397f7"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a00846636a226626c5dd4151893f397f7">NeedsUpdating</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a00846636a226626c5dd4151893f397f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the contact needs updating. <br /></td></tr>
<tr class="separator:a00846636a226626c5dd4151893f397f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c45595993e763f220e4018c3780058"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac9c45595993e763f220e4018c3780058"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gac9c45595993e763f220e4018c3780058">NextPowerOfTwo</a> (T x) -&gt; decltype((x|(x &gt;&gt; 1u)), T(++x))</td></tr>
<tr class="memdesc:gac9c45595993e763f220e4018c3780058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next largest power of 2.  <a href="group__Math.html#gac9c45595993e763f220e4018c3780058">More...</a><br /></td></tr>
<tr class="separator:gac9c45595993e763f220e4018c3780058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">Normalize</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given vector into a unit vector and returns its original length. <br /></td></tr>
<tr class="separator:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425d26025dffe3901caa095b9fa19682"><td class="memItemLeft" align="right" valign="top"><a id="a425d26025dffe3901caa095b9fa19682"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a425d26025dffe3901caa095b9fa19682">operator!=</a> (const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;a, const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;b)</td></tr>
<tr class="memdesc:a425d26025dffe3901caa095b9fa19682"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a></code> inequality operator. <br /></td></tr>
<tr class="separator:a425d26025dffe3901caa095b9fa19682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253588f96c2b53aec235c79675776988"><td class="memItemLeft" align="right" valign="top"><a id="a253588f96c2b53aec235c79675776988"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a253588f96c2b53aec235c79675776988">operator!=</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;lhs, const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a253588f96c2b53aec235c79675776988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator not-equals. <br /></td></tr>
<tr class="separator:a253588f96c2b53aec235c79675776988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c43d9f4a2db2922f8816f960ece8ec"><td class="memItemLeft" align="right" valign="top"><a id="a64c43d9f4a2db2922f8816f960ece8ec"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a64c43d9f4a2db2922f8816f960ece8ec">operator!=</a> (const <a class="el" href="structplayrho_1_1Contactable.html">Contactable</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Contactable.html">Contactable</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a64c43d9f4a2db2922f8816f960ece8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a64c43d9f4a2db2922f8816f960ece8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae970f7a9e7fa198ddadce868c1116325"><td class="memItemLeft" align="right" valign="top"><a id="ae970f7a9e7fa198ddadce868c1116325"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae970f7a9e7fa198ddadce868c1116325">operator!=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:ae970f7a9e7fa198ddadce868c1116325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ae970f7a9e7fa198ddadce868c1116325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71806508440416ef208f51580a6c50c"><td class="memItemLeft" align="right" valign="top"><a id="ab71806508440416ef208f51580a6c50c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab71806508440416ef208f51580a6c50c">operator!=</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> lhs, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> rhs) noexcept</td></tr>
<tr class="memdesc:ab71806508440416ef208f51580a6c50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ab71806508440416ef208f51580a6c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861fb100d29d58d6f26f3767017886b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a861fb100d29d58d6f26f3767017886b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a861fb100d29d58d6f26f3767017886b3">operator!=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a861fb100d29d58d6f26f3767017886b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="namespaceplayrho.html#a861fb100d29d58d6f26f3767017886b3">More...</a><br /></td></tr>
<tr class="separator:a861fb100d29d58d6f26f3767017886b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16f08723028c63f043c1ad42891b11"><td class="memTemplParams" colspan="2"><a id="a0e16f08723028c63f043c1ad42891b11"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0e16f08723028c63f043c1ad42891b11"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0e16f08723028c63f043c1ad42891b11">operator!=</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0e16f08723028c63f043c1ad42891b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a0e16f08723028c63f043c1ad42891b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b902ac6a7cd1b01dc4a4981889d2820"><td class="memItemLeft" align="right" valign="top"><a id="a1b902ac6a7cd1b01dc4a4981889d2820"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1b902ac6a7cd1b01dc4a4981889d2820">operator!=</a> (const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1b902ac6a7cd1b01dc4a4981889d2820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:a1b902ac6a7cd1b01dc4a4981889d2820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcf95269c48c96b8af0854d24894e3d"><td class="memItemLeft" align="right" valign="top"><a id="a9bcf95269c48c96b8af0854d24894e3d"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9bcf95269c48c96b8af0854d24894e3d">operator!=</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> lhs, <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9bcf95269c48c96b8af0854d24894e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given two contact features are not equal. <br /></td></tr>
<tr class="separator:a9bcf95269c48c96b8af0854d24894e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8265c747e9b00e05f54f0aee1a4fdbf7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga8265c747e9b00e05f54f0aee1a4fdbf7">operator&quot;&quot;_cm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga8265c747e9b00e05f54f0aee1a4fdbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a centimeter of Length.  <a href="group__Unitsymbols.html#ga8265c747e9b00e05f54f0aee1a4fdbf7">More...</a><br /></td></tr>
<tr class="separator:ga8265c747e9b00e05f54f0aee1a4fdbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1d9f65f4ef9fdc77b5393cced60d0e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga9a1d9f65f4ef9fdc77b5393cced60d0e">operator&quot;&quot;_cm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga9a1d9f65f4ef9fdc77b5393cced60d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a centimeter of Length.  <a href="group__Unitsymbols.html#ga9a1d9f65f4ef9fdc77b5393cced60d0e">More...</a><br /></td></tr>
<tr class="separator:ga9a1d9f65f4ef9fdc77b5393cced60d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4699929ce883b631701b929a3a4a1511"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga4699929ce883b631701b929a3a4a1511">operator&quot;&quot;_d</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga4699929ce883b631701b929a3a4a1511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for a day unit of Time.  <a href="group__Unitsymbols.html#ga4699929ce883b631701b929a3a4a1511">More...</a><br /></td></tr>
<tr class="separator:ga4699929ce883b631701b929a3a4a1511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1124541f25e0b4e9024f3da77b60ce29"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga1124541f25e0b4e9024f3da77b60ce29">operator&quot;&quot;_d</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga1124541f25e0b4e9024f3da77b60ce29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for a day unit of Time.  <a href="group__Unitsymbols.html#ga1124541f25e0b4e9024f3da77b60ce29">More...</a><br /></td></tr>
<tr class="separator:ga1124541f25e0b4e9024f3da77b60ce29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad590043c44d46c43cf3e38bbb231ec8d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad590043c44d46c43cf3e38bbb231ec8d">operator&quot;&quot;_deg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gad590043c44d46c43cf3e38bbb231ec8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for a degree unit of Angle.  <a href="group__Unitsymbols.html#gad590043c44d46c43cf3e38bbb231ec8d">More...</a><br /></td></tr>
<tr class="separator:gad590043c44d46c43cf3e38bbb231ec8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a68411c9bee133e430474fecd57df06"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga1a68411c9bee133e430474fecd57df06">operator&quot;&quot;_deg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga1a68411c9bee133e430474fecd57df06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for a degree unit of Angle.  <a href="group__Unitsymbols.html#ga1a68411c9bee133e430474fecd57df06">More...</a><br /></td></tr>
<tr class="separator:ga1a68411c9bee133e430474fecd57df06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b222eced4c7ed60fd64bb6c3ba48e9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga58b222eced4c7ed60fd64bb6c3ba48e9">operator&quot;&quot;_dm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga58b222eced4c7ed60fd64bb6c3ba48e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a decimeter of Length.  <a href="group__Unitsymbols.html#ga58b222eced4c7ed60fd64bb6c3ba48e9">More...</a><br /></td></tr>
<tr class="separator:ga58b222eced4c7ed60fd64bb6c3ba48e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9beacde5d50cff177d145f33530e0ced"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga9beacde5d50cff177d145f33530e0ced">operator&quot;&quot;_dm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga9beacde5d50cff177d145f33530e0ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a decimeter of Length.  <a href="group__Unitsymbols.html#ga9beacde5d50cff177d145f33530e0ced">More...</a><br /></td></tr>
<tr class="separator:ga9beacde5d50cff177d145f33530e0ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac348f2b6f845962edbc4fc12b326abbc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gac348f2b6f845962edbc4fc12b326abbc">operator&quot;&quot;_g</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gac348f2b6f845962edbc4fc12b326abbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gram unit of Mass.  <a href="group__Unitsymbols.html#gac348f2b6f845962edbc4fc12b326abbc">More...</a><br /></td></tr>
<tr class="separator:gac348f2b6f845962edbc4fc12b326abbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c7f5697708c39baa2004b88bd4040c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga41c7f5697708c39baa2004b88bd4040c">operator&quot;&quot;_g</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga41c7f5697708c39baa2004b88bd4040c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gram unit of Mass.  <a href="group__Unitsymbols.html#ga41c7f5697708c39baa2004b88bd4040c">More...</a><br /></td></tr>
<tr class="separator:ga41c7f5697708c39baa2004b88bd4040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a94286306b5fc6540f06c33c4c6f5b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad6a94286306b5fc6540f06c33c4c6f5b">operator&quot;&quot;_Gm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gad6a94286306b5fc6540f06c33c4c6f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gigameter unit of Length.  <a href="group__Unitsymbols.html#gad6a94286306b5fc6540f06c33c4c6f5b">More...</a><br /></td></tr>
<tr class="separator:gad6a94286306b5fc6540f06c33c4c6f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ef5a19b234b013f397d727a647898a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga05ef5a19b234b013f397d727a647898a">operator&quot;&quot;_Gm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga05ef5a19b234b013f397d727a647898a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a gigameter unit of Length.  <a href="group__Unitsymbols.html#ga05ef5a19b234b013f397d727a647898a">More...</a><br /></td></tr>
<tr class="separator:ga05ef5a19b234b013f397d727a647898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4ecfc991b77fa7038f6d26ae391f10"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga0f4ecfc991b77fa7038f6d26ae391f10">operator&quot;&quot;_h</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga0f4ecfc991b77fa7038f6d26ae391f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for an hour unit of Time.  <a href="group__Unitsymbols.html#ga0f4ecfc991b77fa7038f6d26ae391f10">More...</a><br /></td></tr>
<tr class="separator:ga0f4ecfc991b77fa7038f6d26ae391f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c986f4d0ec946de664094ab57d467f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga70c986f4d0ec946de664094ab57d467f">operator&quot;&quot;_h</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga70c986f4d0ec946de664094ab57d467f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol for an hour unit of Time.  <a href="group__Unitsymbols.html#ga70c986f4d0ec946de664094ab57d467f">More...</a><br /></td></tr>
<tr class="separator:ga70c986f4d0ec946de664094ab57d467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada3861ed51714dec5584f5ac2eccb351"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga526d114a9d34d7237ed3e41829ab3eff">Frequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gada3861ed51714dec5584f5ac2eccb351">operator&quot;&quot;_Hz</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gada3861ed51714dec5584f5ac2eccb351"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a hertz unit of Frequency.  <a href="group__Unitsymbols.html#gada3861ed51714dec5584f5ac2eccb351">More...</a><br /></td></tr>
<tr class="separator:gada3861ed51714dec5584f5ac2eccb351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc754da89d9edea817c08ec30248f51e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga526d114a9d34d7237ed3e41829ab3eff">Frequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gabc754da89d9edea817c08ec30248f51e">operator&quot;&quot;_Hz</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gabc754da89d9edea817c08ec30248f51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a hertz unit of Frequency.  <a href="group__Unitsymbols.html#gabc754da89d9edea817c08ec30248f51e">More...</a><br /></td></tr>
<tr class="separator:gabc754da89d9edea817c08ec30248f51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37a1df675967bc0408835763b38eb9b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab37a1df675967bc0408835763b38eb9b">operator&quot;&quot;_kg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab37a1df675967bc0408835763b38eb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a kilogram unit of Mass.  <a href="group__Unitsymbols.html#gab37a1df675967bc0408835763b38eb9b">More...</a><br /></td></tr>
<tr class="separator:gab37a1df675967bc0408835763b38eb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec30bdee6208ced65e61642dc51a57a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga1ec30bdee6208ced65e61642dc51a57a">operator&quot;&quot;_kg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga1ec30bdee6208ced65e61642dc51a57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a kilogram unit of Mass.  <a href="group__Unitsymbols.html#ga1ec30bdee6208ced65e61642dc51a57a">More...</a><br /></td></tr>
<tr class="separator:ga1ec30bdee6208ced65e61642dc51a57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35d81e0c97d9e681cde91485230c0b11"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__PhysicalQuantities.html#ga6bcf1d1de9ef60a9833c222efe7ffd57">AreaDensity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga35d81e0c97d9e681cde91485230c0b11">operator&quot;&quot;_kgpm2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga35d81e0c97d9e681cde91485230c0b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilogram per square meter. <br /></td></tr>
<tr class="separator:ga35d81e0c97d9e681cde91485230c0b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3102ca198b5559fcd97d9a847ddafdf9"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="group__PhysicalQuantities.html#ga6bcf1d1de9ef60a9833c222efe7ffd57">AreaDensity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga3102ca198b5559fcd97d9a847ddafdf9">operator&quot;&quot;_kgpm2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga3102ca198b5559fcd97d9a847ddafdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilogram per square meter. <br /></td></tr>
<tr class="separator:ga3102ca198b5559fcd97d9a847ddafdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d611695e995c22b52ba406e3d938af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gae0d611695e995c22b52ba406e3d938af">operator&quot;&quot;_km</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gae0d611695e995c22b52ba406e3d938af"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a kilometer unit of Length.  <a href="group__Unitsymbols.html#gae0d611695e995c22b52ba406e3d938af">More...</a><br /></td></tr>
<tr class="separator:gae0d611695e995c22b52ba406e3d938af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafeb3f293ac0ab46917302e403bd41be8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gafeb3f293ac0ab46917302e403bd41be8">operator&quot;&quot;_km</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gafeb3f293ac0ab46917302e403bd41be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a kilometer unit of Length.  <a href="group__Unitsymbols.html#gafeb3f293ac0ab46917302e403bd41be8">More...</a><br /></td></tr>
<tr class="separator:gafeb3f293ac0ab46917302e403bd41be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f62968533e8cd267de90c1afa366d29"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga0f62968533e8cd267de90c1afa366d29">operator&quot;&quot;_kps</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga0f62968533e8cd267de90c1afa366d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilometer per second.  <a href="group__Unitsymbols.html#ga0f62968533e8cd267de90c1afa366d29">More...</a><br /></td></tr>
<tr class="separator:ga0f62968533e8cd267de90c1afa366d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a535f5043fab4f1d085061b85c2a8c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gae2a535f5043fab4f1d085061b85c2a8c">operator&quot;&quot;_kps</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gae2a535f5043fab4f1d085061b85c2a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for kilometer per second.  <a href="group__Unitsymbols.html#gae2a535f5043fab4f1d085061b85c2a8c">More...</a><br /></td></tr>
<tr class="separator:gae2a535f5043fab4f1d085061b85c2a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab1d37a1ac19ffdb90d209251c9be0af"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaab1d37a1ac19ffdb90d209251c9be0af">operator&quot;&quot;_m</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaab1d37a1ac19ffdb90d209251c9be0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a meter of Length.  <a href="group__Unitsymbols.html#gaab1d37a1ac19ffdb90d209251c9be0af">More...</a><br /></td></tr>
<tr class="separator:gaab1d37a1ac19ffdb90d209251c9be0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a14e71e7bcc58c55976face61eed135"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga8a14e71e7bcc58c55976face61eed135">operator&quot;&quot;_m</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga8a14e71e7bcc58c55976face61eed135"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a meter of Length.  <a href="group__Unitsymbols.html#ga8a14e71e7bcc58c55976face61eed135">More...</a><br /></td></tr>
<tr class="separator:ga8a14e71e7bcc58c55976face61eed135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61eb3c1eb2284bb30dcb127c0ca730db"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga61eb3c1eb2284bb30dcb127c0ca730db">operator&quot;&quot;_m2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga61eb3c1eb2284bb30dcb127c0ca730db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter squared unit of Area.  <a href="group__Unitsymbols.html#ga61eb3c1eb2284bb30dcb127c0ca730db">More...</a><br /></td></tr>
<tr class="separator:ga61eb3c1eb2284bb30dcb127c0ca730db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a403f71b8175cfb90bc4d970909301"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga20a403f71b8175cfb90bc4d970909301">operator&quot;&quot;_m2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga20a403f71b8175cfb90bc4d970909301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter squared unit of Area.  <a href="group__Unitsymbols.html#ga20a403f71b8175cfb90bc4d970909301">More...</a><br /></td></tr>
<tr class="separator:ga20a403f71b8175cfb90bc4d970909301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b1a7f4abf19d284ab6db1da9b47de8b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga0b1a7f4abf19d284ab6db1da9b47de8b">operator&quot;&quot;_min</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga0b1a7f4abf19d284ab6db1da9b47de8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a minute unit of Time.  <a href="group__Unitsymbols.html#ga0b1a7f4abf19d284ab6db1da9b47de8b">More...</a><br /></td></tr>
<tr class="separator:ga0b1a7f4abf19d284ab6db1da9b47de8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212e5deefc8ccc59e0d81d1b1a76f01d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga212e5deefc8ccc59e0d81d1b1a76f01d">operator&quot;&quot;_min</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga212e5deefc8ccc59e0d81d1b1a76f01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a minute unit of Time.  <a href="group__Unitsymbols.html#ga212e5deefc8ccc59e0d81d1b1a76f01d">More...</a><br /></td></tr>
<tr class="separator:ga212e5deefc8ccc59e0d81d1b1a76f01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb01dc5edc19a0616bae6f98bcd4b25"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gafdb01dc5edc19a0616bae6f98bcd4b25">operator&quot;&quot;_Mm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gafdb01dc5edc19a0616bae6f98bcd4b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a megameter unit of Length.  <a href="group__Unitsymbols.html#gafdb01dc5edc19a0616bae6f98bcd4b25">More...</a><br /></td></tr>
<tr class="separator:gafdb01dc5edc19a0616bae6f98bcd4b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade5160c838dead45f9d2f43297642923"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gade5160c838dead45f9d2f43297642923">operator&quot;&quot;_Mm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gade5160c838dead45f9d2f43297642923"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a megameter unit of Length.  <a href="group__Unitsymbols.html#gade5160c838dead45f9d2f43297642923">More...</a><br /></td></tr>
<tr class="separator:gade5160c838dead45f9d2f43297642923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff79dc3f94f4e1ee0f38eaf65b7e475"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gafff79dc3f94f4e1ee0f38eaf65b7e475">operator&quot;&quot;_mps</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gafff79dc3f94f4e1ee0f38eaf65b7e475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second.  <a href="group__Unitsymbols.html#gafff79dc3f94f4e1ee0f38eaf65b7e475">More...</a><br /></td></tr>
<tr class="separator:gafff79dc3f94f4e1ee0f38eaf65b7e475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c9f5a17cc4033b8fd3e9486eec80e6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga29c9f5a17cc4033b8fd3e9486eec80e6">operator&quot;&quot;_mps</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga29c9f5a17cc4033b8fd3e9486eec80e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second.  <a href="group__Unitsymbols.html#ga29c9f5a17cc4033b8fd3e9486eec80e6">More...</a><br /></td></tr>
<tr class="separator:ga29c9f5a17cc4033b8fd3e9486eec80e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1433e48714ffae291e3122d6ae60686"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaea2069744ddc1c5068705b00f957451a">LinearAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gad1433e48714ffae291e3122d6ae60686">operator&quot;&quot;_mps2</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gad1433e48714ffae291e3122d6ae60686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second squared.  <a href="group__Unitsymbols.html#gad1433e48714ffae291e3122d6ae60686">More...</a><br /></td></tr>
<tr class="separator:gad1433e48714ffae291e3122d6ae60686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93977e9c554959304f2d4212d373a3c6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaea2069744ddc1c5068705b00f957451a">LinearAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga93977e9c554959304f2d4212d373a3c6">operator&quot;&quot;_mps2</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga93977e9c554959304f2d4212d373a3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for meter per second squared.  <a href="group__Unitsymbols.html#ga93977e9c554959304f2d4212d373a3c6">More...</a><br /></td></tr>
<tr class="separator:ga93977e9c554959304f2d4212d373a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c745951bdfb935ce193ce74add4f7f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gad51dd88ec6a5b3bf384dc89a63019d9d">Force</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gab0c745951bdfb935ce193ce74add4f7f">operator&quot;&quot;_N</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gab0c745951bdfb935ce193ce74add4f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton unit of Force.  <a href="group__Unitsymbols.html#gab0c745951bdfb935ce193ce74add4f7f">More...</a><br /></td></tr>
<tr class="separator:gab0c745951bdfb935ce193ce74add4f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e6a3c896dea20d70bfd5d7664e2830"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gad51dd88ec6a5b3bf384dc89a63019d9d">Force</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga50e6a3c896dea20d70bfd5d7664e2830">operator&quot;&quot;_N</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga50e6a3c896dea20d70bfd5d7664e2830"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton unit of Force.  <a href="group__Unitsymbols.html#ga50e6a3c896dea20d70bfd5d7664e2830">More...</a><br /></td></tr>
<tr class="separator:ga50e6a3c896dea20d70bfd5d7664e2830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b52e6dd8edf9b4342075e88be348ed"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga1acd0787ea4caa9725577e0aa2fdc9b7">Torque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaf9b52e6dd8edf9b4342075e88be348ed">operator&quot;&quot;_Nm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaf9b52e6dd8edf9b4342075e88be348ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for newton-meter unit of torque.  <a href="group__Unitsymbols.html#gaf9b52e6dd8edf9b4342075e88be348ed">More...</a><br /></td></tr>
<tr class="separator:gaf9b52e6dd8edf9b4342075e88be348ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5c1a86e9698626ca29c2ea17f3eee1d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga1acd0787ea4caa9725577e0aa2fdc9b7">Torque</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaf5c1a86e9698626ca29c2ea17f3eee1d">operator&quot;&quot;_Nm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gaf5c1a86e9698626ca29c2ea17f3eee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for newton-meter unit of torque.  <a href="group__Unitsymbols.html#gaf5c1a86e9698626ca29c2ea17f3eee1d">More...</a><br /></td></tr>
<tr class="separator:gaf5c1a86e9698626ca29c2ea17f3eee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf456e41b17a6b04735df20d018dfe914"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">Momentum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gaf456e41b17a6b04735df20d018dfe914">operator&quot;&quot;_Ns</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gaf456e41b17a6b04735df20d018dfe914"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton second of impulse.  <a href="group__Unitsymbols.html#gaf456e41b17a6b04735df20d018dfe914">More...</a><br /></td></tr>
<tr class="separator:gaf456e41b17a6b04735df20d018dfe914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa460cc2672c862e9b7834bfa49440fc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">Momentum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gafa460cc2672c862e9b7834bfa49440fc">operator&quot;&quot;_Ns</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:gafa460cc2672c862e9b7834bfa49440fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a newton second of impulse.  <a href="group__Unitsymbols.html#gafa460cc2672c862e9b7834bfa49440fc">More...</a><br /></td></tr>
<tr class="separator:gafa460cc2672c862e9b7834bfa49440fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829ed7d59fb256a65f91ff2a38dffe1f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga829ed7d59fb256a65f91ff2a38dffe1f">operator&quot;&quot;_Pg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga829ed7d59fb256a65f91ff2a38dffe1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a petagram unit of Mass.  <a href="group__Unitsymbols.html#ga829ed7d59fb256a65f91ff2a38dffe1f">More...</a><br /></td></tr>
<tr class="separator:ga829ed7d59fb256a65f91ff2a38dffe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8125aed99d289a1b80e057cedd64e13b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga8125aed99d289a1b80e057cedd64e13b">operator&quot;&quot;_Pg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga8125aed99d289a1b80e057cedd64e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a petagram unit of Mass.  <a href="group__Unitsymbols.html#ga8125aed99d289a1b80e057cedd64e13b">More...</a><br /></td></tr>
<tr class="separator:ga8125aed99d289a1b80e057cedd64e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56b7f8881f697bfc5f6c88d268e96543"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga56b7f8881f697bfc5f6c88d268e96543">operator&quot;&quot;_rad</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga56b7f8881f697bfc5f6c88d268e96543"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a radian unit of Angle.  <a href="group__Unitsymbols.html#ga56b7f8881f697bfc5f6c88d268e96543">More...</a><br /></td></tr>
<tr class="separator:ga56b7f8881f697bfc5f6c88d268e96543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7706f4df8f50a57e186d6cc68b02bc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga7f7706f4df8f50a57e186d6cc68b02bc">operator&quot;&quot;_rad</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga7f7706f4df8f50a57e186d6cc68b02bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a radian unit of Angle.  <a href="group__Unitsymbols.html#ga7f7706f4df8f50a57e186d6cc68b02bc">More...</a><br /></td></tr>
<tr class="separator:ga7f7706f4df8f50a57e186d6cc68b02bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9af2088bf38db720f2dca4c8db627b3f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8b4603a98e526262c2e4adfe99510672">AngularVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga9af2088bf38db720f2dca4c8db627b3f">operator&quot;&quot;_rpm</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga9af2088bf38db720f2dca4c8db627b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for revolutions per minute.  <a href="group__Unitsymbols.html#ga9af2088bf38db720f2dca4c8db627b3f">More...</a><br /></td></tr>
<tr class="separator:ga9af2088bf38db720f2dca4c8db627b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga473416136af75cf3600844ad6eb975eb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#ga8b4603a98e526262c2e4adfe99510672">AngularVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga473416136af75cf3600844ad6eb975eb">operator&quot;&quot;_rpm</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga473416136af75cf3600844ad6eb975eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation for revolutions per minute.  <a href="group__Unitsymbols.html#ga473416136af75cf3600844ad6eb975eb">More...</a><br /></td></tr>
<tr class="separator:ga473416136af75cf3600844ad6eb975eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e1888c6386ab9832491aef18039e0c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#gae7e1888c6386ab9832491aef18039e0c">operator&quot;&quot;_s</a> (long double v) noexcept</td></tr>
<tr class="memdesc:gae7e1888c6386ab9832491aef18039e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a second unit of Time.  <a href="group__Unitsymbols.html#gae7e1888c6386ab9832491aef18039e0c">More...</a><br /></td></tr>
<tr class="separator:gae7e1888c6386ab9832491aef18039e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b793a1f4b1c3cce7996c1a55d4e0575"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga5b793a1f4b1c3cce7996c1a55d4e0575">operator&quot;&quot;_s</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga5b793a1f4b1c3cce7996c1a55d4e0575"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI symbol for a second unit of Time.  <a href="group__Unitsymbols.html#ga5b793a1f4b1c3cce7996c1a55d4e0575">More...</a><br /></td></tr>
<tr class="separator:ga5b793a1f4b1c3cce7996c1a55d4e0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9960d0aeddc327fa55019ebb6bb98c4a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga9960d0aeddc327fa55019ebb6bb98c4a">operator&quot;&quot;_Yg</a> (long double v) noexcept</td></tr>
<tr class="memdesc:ga9960d0aeddc327fa55019ebb6bb98c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a yottagram unit of Mass.  <a href="group__Unitsymbols.html#ga9960d0aeddc327fa55019ebb6bb98c4a">More...</a><br /></td></tr>
<tr class="separator:ga9960d0aeddc327fa55019ebb6bb98c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1255eade62dd2acd569300e17da4d578"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Unitsymbols.html#ga1255eade62dd2acd569300e17da4d578">operator&quot;&quot;_Yg</a> (unsigned long long int v) noexcept</td></tr>
<tr class="memdesc:ga1255eade62dd2acd569300e17da4d578"><td class="mdescLeft">&#160;</td><td class="mdescRight">SI unit symbol for a yottagram unit of Mass.  <a href="group__Unitsymbols.html#ga1255eade62dd2acd569300e17da4d578">More...</a><br /></td></tr>
<tr class="separator:ga1255eade62dd2acd569300e17da4d578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2722bc95da32ec0b7f65c9dff9aa0dcc"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a2722bc95da32ec0b7f65c9dff9aa0dcc"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt; &amp;&amp;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T1 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2722bc95da32ec0b7f65c9dff9aa0dcc">operator*</a> (const T1 &amp;s, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, N &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:a2722bc95da32ec0b7f65c9dff9aa0dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for non-vector times vector.  <a href="namespaceplayrho.html#a2722bc95da32ec0b7f65c9dff9aa0dcc">More...</a><br /></td></tr>
<tr class="separator:a2722bc95da32ec0b7f65c9dff9aa0dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225cd9989faf6ae44c6bf24f84c2edf7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a225cd9989faf6ae44c6bf24f84c2edf7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt; &amp;&amp;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T1 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a225cd9989faf6ae44c6bf24f84c2edf7">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, B &gt;, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a225cd9989faf6ae44c6bf24f84c2edf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an A-element vector by a A-by-B vector of vectors.  <a href="namespaceplayrho.html#a225cd9989faf6ae44c6bf24f84c2edf7">More...</a><br /></td></tr>
<tr class="separator:a225cd9989faf6ae44c6bf24f84c2edf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bf68739331457fd06d2ac83a971ce7"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a17bf68739331457fd06d2ac83a971ce7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt; &amp;&amp;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T2 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a17bf68739331457fd06d2ac83a971ce7">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;a, const T2 &amp;s) noexcept</td></tr>
<tr class="memdesc:a17bf68739331457fd06d2ac83a971ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for vector times non-vector.  <a href="namespaceplayrho.html#a17bf68739331457fd06d2ac83a971ce7">More...</a><br /></td></tr>
<tr class="separator:a17bf68739331457fd06d2ac83a971ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32931066a82b41864b61d9c0389d6712"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a32931066a82b41864b61d9c0389d6712"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt; &amp;&amp;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T2 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, B &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a32931066a82b41864b61d9c0389d6712">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt;, B &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a32931066a82b41864b61d9c0389d6712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a B-by-A vector of vectors by an A-element vector.  <a href="namespaceplayrho.html#a32931066a82b41864b61d9c0389d6712">More...</a><br /></td></tr>
<tr class="separator:a32931066a82b41864b61d9c0389d6712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d7a33cd41bce2acd1d6b8292487981"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, std::size_t C, typename OT  = decltype(T1{} * T2{})&gt; </td></tr>
<tr class="memitem:a53d7a33cd41bce2acd1d6b8292487981"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, C &gt;, A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a53d7a33cd41bce2acd1d6b8292487981">operator*</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, B &gt;, A &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, C &gt;, B &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a53d7a33cd41bce2acd1d6b8292487981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the matrix product of the two given vector of vectors (matrices).  <a href="namespaceplayrho.html#a53d7a33cd41bce2acd1d6b8292487981">More...</a><br /></td></tr>
<tr class="separator:a53d7a33cd41bce2acd1d6b8292487981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af081fa6bf4de6ca0c13938151e91dbb6"><td class="memTemplParams" colspan="2"><a id="af081fa6bf4de6ca0c13938151e91dbb6"></a>
template&lt;typename T1 , typename T2 , std::size_t N&gt; </td></tr>
<tr class="memitem:af081fa6bf4de6ca0c13938151e91dbb6"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T1, decltype(T1{} *T2{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af081fa6bf4de6ca0c13938151e91dbb6">operator*=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;lhs, const T2 rhs) noexcept</td></tr>
<tr class="memdesc:af081fa6bf4de6ca0c13938151e91dbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator. <br /></td></tr>
<tr class="separator:af081fa6bf4de6ca0c13938151e91dbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04db47926693f7d605331b5035d4c9c5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t S&gt; </td></tr>
<tr class="memitem:a04db47926693f7d605331b5035d4c9c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a04db47926693f7d605331b5035d4c9c5">operator+</a> (<a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; lhs, const typename <a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;::data_type &amp;rhs)</td></tr>
<tr class="memdesc:a04db47926693f7d605331b5035d4c9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1ArrayList.html" title="Array list.">ArrayList</a></code> add operator.  <a href="namespaceplayrho.html#a04db47926693f7d605331b5035d4c9c5">More...</a><br /></td></tr>
<tr class="separator:a04db47926693f7d605331b5035d4c9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f0c49a750ed51bb02cef10158e8d7f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a41f0c49a750ed51bb02cef10158e8d7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a41f0c49a750ed51bb02cef10158e8d7f">operator+</a> (const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;lhs, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a41f0c49a750ed51bb02cef10158e8d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix addition operator for two same-type, same-sized matrices.  <a href="namespaceplayrho.html#a41f0c49a750ed51bb02cef10158e8d7f">More...</a><br /></td></tr>
<tr class="separator:a41f0c49a750ed51bb02cef10158e8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9320003d829a8e98e1e77bcd28adab4"><td class="memTemplParams" colspan="2"><a id="ad9320003d829a8e98e1e77bcd28adab4"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad9320003d829a8e98e1e77bcd28adab4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T, decltype(T{}+T{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad9320003d829a8e98e1e77bcd28adab4">operator+</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:ad9320003d829a8e98e1e77bcd28adab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two vectors component-wise. <br /></td></tr>
<tr class="separator:ad9320003d829a8e98e1e77bcd28adab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70d6dcc29a595bcc1a08b80d06f6e10"><td class="memTemplParams" colspan="2"><a id="ae70d6dcc29a595bcc1a08b80d06f6e10"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae70d6dcc29a595bcc1a08b80d06f6e10"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T, decltype(+T{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae70d6dcc29a595bcc1a08b80d06f6e10">operator+</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; v) noexcept</td></tr>
<tr class="memdesc:ae70d6dcc29a595bcc1a08b80d06f6e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus operator. <br /></td></tr>
<tr class="separator:ae70d6dcc29a595bcc1a08b80d06f6e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750eac4f3ab1ac6026e37ae41b87058d"><td class="memTemplParams" colspan="2"><a id="a750eac4f3ab1ac6026e37ae41b87058d"></a>
template&lt;typename T , std::size_t S&gt; </td></tr>
<tr class="memitem:a750eac4f3ab1ac6026e37ae41b87058d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a750eac4f3ab1ac6026e37ae41b87058d">operator+=</a> (<a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; &amp;lhs, const typename <a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;::data_type &amp;rhs)</td></tr>
<tr class="memdesc:a750eac4f3ab1ac6026e37ae41b87058d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1ArrayList.html" title="Array list.">ArrayList</a></code> append operator. <br /></td></tr>
<tr class="separator:a750eac4f3ab1ac6026e37ae41b87058d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c9b996615a5d406c9db90f5e4578f"><td class="memTemplParams" colspan="2"><a id="a319c9b996615a5d406c9db90f5e4578f"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a319c9b996615a5d406c9db90f5e4578f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T, decltype(T{}+T{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a319c9b996615a5d406c9db90f5e4578f">operator+=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a319c9b996615a5d406c9db90f5e4578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the left hand side value by the right hand side value. <br /></td></tr>
<tr class="separator:a319c9b996615a5d406c9db90f5e4578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89118d71eeeffa541c76f6d566a8546d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t M, std::size_t N&gt; </td></tr>
<tr class="memitem:a89118d71eeeffa541c76f6d566a8546d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a89118d71eeeffa541c76f6d566a8546d">operator-</a> (const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;lhs, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a89118d71eeeffa541c76f6d566a8546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix subtraction operator for two same-type, same-sized matrices.  <a href="namespaceplayrho.html#a89118d71eeeffa541c76f6d566a8546d">More...</a><br /></td></tr>
<tr class="separator:a89118d71eeeffa541c76f6d566a8546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea7b0293964b22ae57e18fc36518d75"><td class="memTemplParams" colspan="2"><a id="a1ea7b0293964b22ae57e18fc36518d75"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1ea7b0293964b22ae57e18fc36518d75"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T, decltype(T{} - T{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1ea7b0293964b22ae57e18fc36518d75">operator-</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a1ea7b0293964b22ae57e18fc36518d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two vectors component-wise. <br /></td></tr>
<tr class="separator:a1ea7b0293964b22ae57e18fc36518d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c1fd567af542eaca195272f717e6bd"><td class="memTemplParams" colspan="2"><a id="a30c1fd567af542eaca195272f717e6bd"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a30c1fd567af542eaca195272f717e6bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T, decltype(-T{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a30c1fd567af542eaca195272f717e6bd">operator-</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; v) noexcept</td></tr>
<tr class="memdesc:a30c1fd567af542eaca195272f717e6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation operator. <br /></td></tr>
<tr class="separator:a30c1fd567af542eaca195272f717e6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fba1d15bc6902dca10efe3a579d1c0a"><td class="memTemplParams" colspan="2"><a id="a6fba1d15bc6902dca10efe3a579d1c0a"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6fba1d15bc6902dca10efe3a579d1c0a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T, decltype(T{} - T{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6fba1d15bc6902dca10efe3a579d1c0a">operator-=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; rhs) noexcept</td></tr>
<tr class="memdesc:a6fba1d15bc6902dca10efe3a579d1c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the left hand side value by the right hand side value. <br /></td></tr>
<tr class="separator:a6fba1d15bc6902dca10efe3a579d1c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da12fe999b8b56930c6cbd9dd4cd920"><td class="memTemplParams" colspan="2"><a id="a6da12fe999b8b56930c6cbd9dd4cd920"></a>
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} / T2{})&gt; </td></tr>
<tr class="memitem:a6da12fe999b8b56930c6cbd9dd4cd920"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#abdcd4932a27b9347d3afbae550fa57d2">IsDivisableV</a>&lt; T1, T2 &gt; &amp;&amp;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T2 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6da12fe999b8b56930c6cbd9dd4cd920">operator/</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;a, const T2 &amp;s) noexcept</td></tr>
<tr class="memdesc:a6da12fe999b8b56930c6cbd9dd4cd920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator. <br /></td></tr>
<tr class="separator:a6da12fe999b8b56930c6cbd9dd4cd920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af63c98286091483bcd8bc55a8072d1"><td class="memTemplParams" colspan="2"><a id="a8af63c98286091483bcd8bc55a8072d1"></a>
template&lt;typename T1 , typename T2 , std::size_t N&gt; </td></tr>
<tr class="memitem:a8af63c98286091483bcd8bc55a8072d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t&lt; std::is_same_v&lt; T1, decltype(T1{}/T2{})&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a8af63c98286091483bcd8bc55a8072d1">operator/=</a> (<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;lhs, const T2 rhs) noexcept</td></tr>
<tr class="memdesc:a8af63c98286091483bcd8bc55a8072d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator. <br /></td></tr>
<tr class="separator:a8af63c98286091483bcd8bc55a8072d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80c31195a04b4af5891934d0ed1ed3c"><td class="memItemLeft" align="right" valign="top"><a id="af80c31195a04b4af5891934d0ed1ed3c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af80c31195a04b4af5891934d0ed1ed3c">operator&lt;</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:af80c31195a04b4af5891934d0ed1ed3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:af80c31195a04b4af5891934d0ed1ed3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815e65e38974a8bb60ef0a096bea0241"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a815e65e38974a8bb60ef0a096bea0241"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a815e65e38974a8bb60ef0a096bea0241">operator&lt;</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a815e65e38974a8bb60ef0a096bea0241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator.  <a href="namespaceplayrho.html#a815e65e38974a8bb60ef0a096bea0241">More...</a><br /></td></tr>
<tr class="separator:a815e65e38974a8bb60ef0a096bea0241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eaedfa824fd2df1b6450a875b144ed0"><td class="memTemplParams" colspan="2">template&lt;std::size_t N0, class T0 , std::size_t N1, class T1 &gt; </td></tr>
<tr class="memitem:a4eaedfa824fd2df1b6450a875b144ed0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4eaedfa824fd2df1b6450a875b144ed0">operator&lt;</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T0, N0 &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N1 &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a4eaedfa824fd2df1b6450a875b144ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator.  <a href="namespaceplayrho.html#a4eaedfa824fd2df1b6450a875b144ed0">More...</a><br /></td></tr>
<tr class="separator:a4eaedfa824fd2df1b6450a875b144ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9664edec057808e7df69e801e1f9012f"><td class="memItemLeft" align="right" valign="top"><a id="a9664edec057808e7df69e801e1f9012f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9664edec057808e7df69e801e1f9012f">operator&lt;</a> (const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9664edec057808e7df69e801e1f9012f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator. <br /></td></tr>
<tr class="separator:a9664edec057808e7df69e801e1f9012f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="memItemLeft" align="right" valign="top"><a id="ad3ec58bed15fb00ea00af6a52e5a7e3e"></a>
inline ::std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad3ec58bed15fb00ea00af6a52e5a7e3e">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> &amp;value)</td></tr>
<tr class="memdesc:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream output operator. <br /></td></tr>
<tr class="separator:ad3ec58bed15fb00ea00af6a52e5a7e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5053c1cb8807f6296852e4a8c657d2"><td class="memTemplParams" colspan="2"><a id="acd5053c1cb8807f6296852e4a8c657d2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd5053c1cb8807f6296852e4a8c657d2"><td class="memTemplItemLeft" align="right" valign="top">::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acd5053c1cb8807f6296852e4a8c657d2">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:acd5053c1cb8807f6296852e4a8c657d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator. <br /></td></tr>
<tr class="separator:acd5053c1cb8807f6296852e4a8c657d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bda91572806860fa512fff0f01a001b"><td class="memTemplParams" colspan="2"><a id="a6bda91572806860fa512fff0f01a001b"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6bda91572806860fa512fff0f01a001b"><td class="memTemplItemLeft" align="right" valign="top">::std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6bda91572806860fa512fff0f01a001b">operator&lt;&lt;</a> (::std::ostream &amp;os, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;value)</td></tr>
<tr class="memdesc:a6bda91572806860fa512fff0f01a001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator. <br /></td></tr>
<tr class="separator:a6bda91572806860fa512fff0f01a001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225f691c1b9ee3969221ae49170ba178"><td class="memItemLeft" align="right" valign="top"><a id="a225f691c1b9ee3969221ae49170ba178"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a225f691c1b9ee3969221ae49170ba178">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a225f691c1b9ee3969221ae49170ba178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:a225f691c1b9ee3969221ae49170ba178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf50e7e086182f69dc09e011aef6345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbf50e7e086182f69dc09e011aef6345"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adbf50e7e086182f69dc09e011aef6345">operator&lt;=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:adbf50e7e086182f69dc09e011aef6345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator.  <a href="namespaceplayrho.html#adbf50e7e086182f69dc09e011aef6345">More...</a><br /></td></tr>
<tr class="separator:adbf50e7e086182f69dc09e011aef6345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdb22d94f848eebd4aff498f3fba0c4"><td class="memItemLeft" align="right" valign="top"><a id="aafdb22d94f848eebd4aff498f3fba0c4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aafdb22d94f848eebd4aff498f3fba0c4">operator&lt;=</a> (const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aafdb22d94f848eebd4aff498f3fba0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than or equal-to operator. <br /></td></tr>
<tr class="separator:aafdb22d94f848eebd4aff498f3fba0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5692e54289c87c156bd7455763082a9"><td class="memItemLeft" align="right" valign="top"><a id="ab5692e54289c87c156bd7455763082a9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab5692e54289c87c156bd7455763082a9">operator==</a> (const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;a, const <a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a> &amp;b)</td></tr>
<tr class="memdesc:ab5692e54289c87c156bd7455763082a9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classplayrho_1_1BlockAllocator.html">BlockAllocator</a></code> equality operator. <br /></td></tr>
<tr class="separator:ab5692e54289c87c156bd7455763082a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b92007cb872b11ba4ab93f5095e2e48"><td class="memItemLeft" align="right" valign="top"><a id="a5b92007cb872b11ba4ab93f5095e2e48"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5b92007cb872b11ba4ab93f5095e2e48">operator==</a> (const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;lhs, const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5b92007cb872b11ba4ab93f5095e2e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator equals. <br /></td></tr>
<tr class="separator:a5b92007cb872b11ba4ab93f5095e2e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268967eee0d7a53d51224a8a1259d06f"><td class="memItemLeft" align="right" valign="top"><a id="a268967eee0d7a53d51224a8a1259d06f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a268967eee0d7a53d51224a8a1259d06f">operator==</a> (const <a class="el" href="structplayrho_1_1Contactable.html">Contactable</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Contactable.html">Contactable</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a268967eee0d7a53d51224a8a1259d06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a268967eee0d7a53d51224a8a1259d06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0addcd9e78acfcc5f23418814f2a8f57"><td class="memItemLeft" align="right" valign="top"><a id="a0addcd9e78acfcc5f23418814f2a8f57"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0addcd9e78acfcc5f23418814f2a8f57">operator==</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a0addcd9e78acfcc5f23418814f2a8f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a0addcd9e78acfcc5f23418814f2a8f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecc5b25e8e89a47a552caf672bd69c"><td class="memItemLeft" align="right" valign="top"><a id="a9cecc5b25e8e89a47a552caf672bd69c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9cecc5b25e8e89a47a552caf672bd69c">operator==</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> lhs, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> rhs) noexcept</td></tr>
<tr class="memdesc:a9cecc5b25e8e89a47a552caf672bd69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a9cecc5b25e8e89a47a552caf672bd69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b97d7e2f5894048236948061068fb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac1b97d7e2f5894048236948061068fb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac1b97d7e2f5894048236948061068fb5">operator==</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;a, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ac1b97d7e2f5894048236948061068fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="namespaceplayrho.html#ac1b97d7e2f5894048236948061068fb5">More...</a><br /></td></tr>
<tr class="separator:ac1b97d7e2f5894048236948061068fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d92fceef8d7757ae713bd166391c21"><td class="memTemplParams" colspan="2"><a id="ab0d92fceef8d7757ae713bd166391c21"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab0d92fceef8d7757ae713bd166391c21"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab0d92fceef8d7757ae713bd166391c21">operator==</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab0d92fceef8d7757ae713bd166391c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:ab0d92fceef8d7757ae713bd166391c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26000facbed802f63693ad132ea5e4"><td class="memItemLeft" align="right" valign="top"><a id="a1a26000facbed802f63693ad132ea5e4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1a26000facbed802f63693ad132ea5e4">operator==</a> (const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1a26000facbed802f63693ad132ea5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a1a26000facbed802f63693ad132ea5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19a825ed22691eab1981a616b6bf539"><td class="memItemLeft" align="right" valign="top"><a id="ac19a825ed22691eab1981a616b6bf539"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac19a825ed22691eab1981a616b6bf539">operator==</a> (<a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> lhs, <a class="el" href="structplayrho_1_1ContactFeature.html">ContactFeature</a> rhs) noexcept</td></tr>
<tr class="memdesc:ac19a825ed22691eab1981a616b6bf539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given two contact features are equal. <br /></td></tr>
<tr class="separator:ac19a825ed22691eab1981a616b6bf539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef072ea2c5a69df2050c1a1557206ef"><td class="memItemLeft" align="right" valign="top"><a id="a7ef072ea2c5a69df2050c1a1557206ef"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7ef072ea2c5a69df2050c1a1557206ef">operator&gt;</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:a7ef072ea2c5a69df2050c1a1557206ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:a7ef072ea2c5a69df2050c1a1557206ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acc58a55aab3f8bdd7ea411a6b2a4ddfb">operator&gt;</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator.  <a href="namespaceplayrho.html#acc58a55aab3f8bdd7ea411a6b2a4ddfb">More...</a><br /></td></tr>
<tr class="separator:acc58a55aab3f8bdd7ea411a6b2a4ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab826df98026c84dcfa3cf694d6f8e63e"><td class="memItemLeft" align="right" valign="top"><a id="ab826df98026c84dcfa3cf694d6f8e63e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab826df98026c84dcfa3cf694d6f8e63e">operator&gt;</a> (const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab826df98026c84dcfa3cf694d6f8e63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than operator. <br /></td></tr>
<tr class="separator:ab826df98026c84dcfa3cf694d6f8e63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f2a5fe81c028b473be52b47b7c7e9"><td class="memItemLeft" align="right" valign="top"><a id="ae75f2a5fe81c028b473be52b47b7c7e9"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae75f2a5fe81c028b473be52b47b7c7e9">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> lhs, const <a class="el" href="classplayrho_1_1ContactKey.html">ContactKey</a> rhs) noexcept</td></tr>
<tr class="memdesc:ae75f2a5fe81c028b473be52b47b7c7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:ae75f2a5fe81c028b473be52b47b7c7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca7f35c089808652f6c5d6c06a85ae7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acca7f35c089808652f6c5d6c06a85ae7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acca7f35c089808652f6c5d6c06a85ae7">operator&gt;=</a> (const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:acca7f35c089808652f6c5d6c06a85ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator.  <a href="namespaceplayrho.html#acca7f35c089808652f6c5d6c06a85ae7">More...</a><br /></td></tr>
<tr class="separator:acca7f35c089808652f6c5d6c06a85ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30424693f3f723867383b08f1735bdd3"><td class="memItemLeft" align="right" valign="top"><a id="a30424693f3f723867383b08f1735bdd3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a30424693f3f723867383b08f1735bdd3">operator&gt;=</a> (const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;lhs, const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a30424693f3f723867383b08f1735bdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-than or equal-to operator. <br /></td></tr>
<tr class="separator:a30424693f3f723867383b08f1735bdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb651f620aefb4ee65ec0cc8c10b27b0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">Realloc</a> (void *ptr, std::size_t <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a>)</td></tr>
<tr class="memdesc:adb651f620aefb4ee65ec0cc8c10b27b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory.  <a href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">More...</a><br /></td></tr>
<tr class="separator:adb651f620aefb4ee65ec0cc8c10b27b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197482cbffdd702c8926a00f42a76e62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a197482cbffdd702c8926a00f42a76e62"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62">ReallocArray</a> (T *ptr, std::size_t count)</td></tr>
<tr class="memdesc:a197482cbffdd702c8926a00f42a76e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocates memory for an array.  <a href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62">More...</a><br /></td></tr>
<tr class="separator:a197482cbffdd702c8926a00f42a76e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d8dfd5b476a5ec95500dbb121f27c7"><td class="memItemLeft" align="right" valign="top"><a id="a64d8dfd5b476a5ec95500dbb121f27c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a64d8dfd5b476a5ec95500dbb121f27c7">Reserve</a> (<a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island, <a class="el" href="namespaceplayrho.html#a261b3039a098762462a17164898bb647">BodyCounter</a> bodies, <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a> contacts, <a class="el" href="namespaceplayrho.html#a3fff859979ed48e0d223d1584eb985c3">JointCounter</a> joints)</td></tr>
<tr class="memdesc:a64d8dfd5b476a5ec95500dbb121f27c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves space ahead of time. <br /></td></tr>
<tr class="separator:a64d8dfd5b476a5ec95500dbb121f27c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de374e7d6af7b68b654b657d756468a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1de374e7d6af7b68b654b657d756468a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#adaec996c65bbbcac537113d83ee753c5">IsReverseIterableV</a>&lt; T &gt;, <a class="el" href="structplayrho_1_1ReversionWrapper.html">ReversionWrapper</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1de374e7d6af7b68b654b657d756468a">Reverse</a> (T &amp;&amp;iterable)</td></tr>
<tr class="memdesc:a1de374e7d6af7b68b654b657d756468a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a reversed order iterated wrapper.  <a href="namespaceplayrho.html#a1de374e7d6af7b68b654b657d756468a">More...</a><br /></td></tr>
<tr class="separator:a1de374e7d6af7b68b654b657d756468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1502fbf5063c1f5dbedafe215895ad29"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1502fbf5063c1f5dbedafe215895ad29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1502fbf5063c1f5dbedafe215895ad29">RoundOff</a> (const T &amp;value, unsigned precision=<a class="el" href="group__Math.html#ga2e94545b5052523414ec03d0e95e2297">DefaultRoundOffPrecission</a>) -&gt; decltype(round(value *static_cast&lt; T &gt;(precision))/static_cast&lt; T &gt;(precision))</td></tr>
<tr class="memdesc:ga1502fbf5063c1f5dbedafe215895ad29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga1502fbf5063c1f5dbedafe215895ad29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ceb2daa8b41c4834408662c43e5abda"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1ceb2daa8b41c4834408662c43e5abda">RoundOff</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;value, std::uint32_t precision=<a class="el" href="group__Math.html#ga2e94545b5052523414ec03d0e95e2297">DefaultRoundOffPrecission</a>) -&gt; <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a></td></tr>
<tr class="memdesc:ga1ceb2daa8b41c4834408662c43e5abda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value.  <a href="group__Math.html#ga1ceb2daa8b41c4834408662c43e5abda">More...</a><br /></td></tr>
<tr class="separator:ga1ceb2daa8b41c4834408662c43e5abda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30837f12d652c4e51406db0f1cd11a3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga30837f12d652c4e51406db0f1cd11a3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga30837f12d652c4e51406db0f1cd11a3a">Secant</a> (const T &amp;target, const U &amp;a1, const T &amp;s1, const U &amp;a2, const T &amp;s2) -&gt; decltype(a1+(target - s1) *(a2 - a1)/(s2 - s1))</td></tr>
<tr class="memdesc:ga30837f12d652c4e51406db0f1cd11a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secant method.  <a href="group__Math.html#ga30837f12d652c4e51406db0f1cd11a3a">More...</a><br /></td></tr>
<tr class="separator:ga30837f12d652c4e51406db0f1cd11a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ce44af5f5ba3deb7e1eafe1acf5198"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a23ce44af5f5ba3deb7e1eafe1acf5198">SetEnabled</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a23ce44af5f5ba3deb7e1eafe1acf5198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the contact.  <a href="namespaceplayrho.html#a23ce44af5f5ba3deb7e1eafe1acf5198">More...</a><br /></td></tr>
<tr class="separator:a23ce44af5f5ba3deb7e1eafe1acf5198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf284b9eea3b4ad78ba5b673e67b00b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#acaf284b9eea3b4ad78ba5b673e67b00b">SetFriction</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact, <a class="el" href="group__CheckedTypes.html#ga7ab2310a74db36363887ad368d5c3118">NonNegative</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt; value) noexcept</td></tr>
<tr class="memdesc:acaf284b9eea3b4ad78ba5b673e67b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the friction value for the identified contact.  <a href="namespaceplayrho.html#acaf284b9eea3b4ad78ba5b673e67b00b">More...</a><br /></td></tr>
<tr class="separator:acaf284b9eea3b4ad78ba5b673e67b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146755eafb1ed7d0ea52af68ea4874cd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a146755eafb1ed7d0ea52af68ea4874cd">SetImpenetrable</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a146755eafb1ed7d0ea52af68ea4874cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the impenetrability of the given contact.  <a href="namespaceplayrho.html#a146755eafb1ed7d0ea52af68ea4874cd">More...</a><br /></td></tr>
<tr class="separator:a146755eafb1ed7d0ea52af68ea4874cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc7dc1c568e7e1cbe70afe67c51b14a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6dc7dc1c568e7e1cbe70afe67c51b14a">SetIsActive</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a6dc7dc1c568e7e1cbe70afe67c51b14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the active state of the given contact.  <a href="namespaceplayrho.html#a6dc7dc1c568e7e1cbe70afe67c51b14a">More...</a><br /></td></tr>
<tr class="separator:a6dc7dc1c568e7e1cbe70afe67c51b14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72b11c11801f8189dbd1d61dd917f77"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae72b11c11801f8189dbd1d61dd917f77">SetRestitution</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> value)</td></tr>
<tr class="memdesc:ae72b11c11801f8189dbd1d61dd917f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the restitution value for the identified contact.  <a href="namespaceplayrho.html#ae72b11c11801f8189dbd1d61dd917f77">More...</a><br /></td></tr>
<tr class="separator:ae72b11c11801f8189dbd1d61dd917f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8595ac215de486ea15aaa0c9c608b3e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af8595ac215de486ea15aaa0c9c608b3e">SetSensor</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:af8595ac215de486ea15aaa0c9c608b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the sensor state of the given contact.  <a href="namespaceplayrho.html#af8595ac215de486ea15aaa0c9c608b3e">More...</a><br /></td></tr>
<tr class="separator:af8595ac215de486ea15aaa0c9c608b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16493a4bdae1683c07b4b116516716f0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a16493a4bdae1683c07b4b116516716f0">SetTangentSpeed</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact, <a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a> value) noexcept</td></tr>
<tr class="memdesc:a16493a4bdae1683c07b4b116516716f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the desired tangent speed for a conveyor belt behavior.  <a href="namespaceplayrho.html#a16493a4bdae1683c07b4b116516716f0">More...</a><br /></td></tr>
<tr class="separator:a16493a4bdae1683c07b4b116516716f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93e3743c48882f44ef7936cbad68ae1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af93e3743c48882f44ef7936cbad68ae1">SetToi</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact, const std::optional&lt; <a class="el" href="group__CheckedTypes.html#ga309960da94ba655d5101c19da5c55c1b">UnitIntervalFF</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;&gt; &amp;toi) noexcept</td></tr>
<tr class="memdesc:af93e3743c48882f44ef7936cbad68ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time of impact (TOI).  <a href="namespaceplayrho.html#af93e3743c48882f44ef7936cbad68ae1">More...</a><br /></td></tr>
<tr class="separator:af93e3743c48882f44ef7936cbad68ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf79c789863cc4aea6b9e6bc976267c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aabf79c789863cc4aea6b9e6bc976267c">SetToiCount</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact, <a class="el" href="classplayrho_1_1Contact.html#a302944c607d7a872a6a30c653c9f690d">Contact::substep_type</a> value) noexcept</td></tr>
<tr class="memdesc:aabf79c789863cc4aea6b9e6bc976267c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the TOI count to the given value.  <a href="namespaceplayrho.html#aabf79c789863cc4aea6b9e6bc976267c">More...</a><br /></td></tr>
<tr class="separator:aabf79c789863cc4aea6b9e6bc976267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223329721a8138f316898ed9a4877250"><td class="memItemLeft" align="right" valign="top"><a id="a223329721a8138f316898ed9a4877250"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a223329721a8138f316898ed9a4877250">ShouldCollide</a> (const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> filterA, const <a class="el" href="structplayrho_1_1Filter.html">Filter</a> filterB) noexcept</td></tr>
<tr class="memdesc:a223329721a8138f316898ed9a4877250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether collision processing should be performed. <br /></td></tr>
<tr class="separator:a223329721a8138f316898ed9a4877250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33cf35b33c93168aedcbf5a986a3472"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size</a> (<a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a> pairs) -&gt; decltype(<a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices</a>(pairs))</td></tr>
<tr class="memdesc:af33cf35b33c93168aedcbf5a986a3472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the dynamic size of the given collection of index pairs.  <a href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">More...</a><br /></td></tr>
<tr class="separator:af33cf35b33c93168aedcbf5a986a3472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dfb22979400417701de8582bb6d76ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga1dfb22979400417701de8582bb6d76ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1dfb22979400417701de8582bb6d76ad">Solve</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt; &amp;mat, const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga1dfb22979400417701de8582bb6d76ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga1dfb22979400417701de8582bb6d76ad">More...</a><br /></td></tr>
<tr class="separator:ga1dfb22979400417701de8582bb6d76ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844e39448ab76470e60db668b1815ee0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga844e39448ab76470e60db668b1815ee0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga844e39448ab76470e60db668b1815ee0">Solve22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;b) noexcept -&gt; <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga844e39448ab76470e60db668b1815ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga844e39448ab76470e60db668b1815ee0">More...</a><br /></td></tr>
<tr class="separator:ga844e39448ab76470e60db668b1815ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab5eb451a3aff0db8ef5bcbb3d67a18df">Solve33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; T &gt; &amp;b) noexcept -&gt; <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#gab5eb451a3aff0db8ef5bcbb3d67a18df">More...</a><br /></td></tr>
<tr class="separator:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae889e4744cedfd0684d20ef3b7f48652"><td class="memItemLeft" align="right" valign="top"><a id="ae889e4744cedfd0684d20ef3b7f48652"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae889e4744cedfd0684d20ef3b7f48652">Sort</a> (<a class="el" href="structplayrho_1_1Island.html">Island</a> &amp;island) noexcept</td></tr>
<tr class="memdesc:ae889e4744cedfd0684d20ef3b7f48652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the island containers. <br /></td></tr>
<tr class="separator:ae889e4744cedfd0684d20ef3b7f48652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4000cee8b1fc5a9ab6a5cfe29eb645b6"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4000cee8b1fc5a9ab6a5cfe29eb645b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga4000cee8b1fc5a9ab6a5cfe29eb645b6">Square</a> (T t) noexcept(noexcept(t *t)) -&gt; decltype(t *t)</td></tr>
<tr class="memdesc:ga4000cee8b1fc5a9ab6a5cfe29eb645b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the given value. <br /></td></tr>
<tr class="separator:ga4000cee8b1fc5a9ab6a5cfe29eb645b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48e50a80b0fd16dfd70ee70307ad296"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab48e50a80b0fd16dfd70ee70307ad296"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab48e50a80b0fd16dfd70ee70307ad296">StripUnit</a> (const T &amp;value) -&gt; std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#aa9c55e27192da826391d895835f02b17">IsArithmeticV</a>&lt; T &gt; &amp;&amp;!<a class="el" href="namespaceplayrho_1_1detail.html#af266549017154893e0ba701cfe4af898">detail::is_detected_v</a>&lt; <a class="el" href="namespaceplayrho_1_1detail.html#a03090ab2b73fa40dbf842caf9cf4f19f">detail::get_member_type</a>, T &gt;, T &gt;</td></tr>
<tr class="memdesc:ab48e50a80b0fd16dfd70ee70307ad296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the units off of the given value.  <a href="namespaceplayrho.html#ab48e50a80b0fd16dfd70ee70307ad296">More...</a><br /></td></tr>
<tr class="separator:ab48e50a80b0fd16dfd70ee70307ad296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaf30d44caa739e24d21d763b90030c"><td class="memTemplParams" colspan="2"><a id="abbaf30d44caa739e24d21d763b90030c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abbaf30d44caa739e24d21d763b90030c"><td class="memTemplItemLeft" align="right" valign="top">PROPAGATE_CONST_CONSTEXPR void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abbaf30d44caa739e24d21d763b90030c">swap</a> (<a class="el" href="classplayrho_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;pt, <a class="el" href="classplayrho_1_1propagate__const.html">propagate_const</a>&lt; T &gt; &amp;pu) noexcept(noexcept(swap(std::declval&lt; T &amp; &gt;(), std::declval&lt; T &amp; &gt;())))</td></tr>
<tr class="memdesc:abbaf30d44caa739e24d21d763b90030c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for swap operation. <br /></td></tr>
<tr class="separator:abbaf30d44caa739e24d21d763b90030c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3ffaf4d26f2f410c72befd4f9b0ec6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b3ffaf4d26f2f410c72befd4f9b0ec6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4b3ffaf4d26f2f410c72befd4f9b0ec6">to_underlying</a> (T value) noexcept -&gt; <a class="el" href="namespaceplayrho_1_1detail.html#a2ddc4b148d5e38a5a59954a1f503e901">detail::underlying_type_t</a>&lt; T &gt;</td></tr>
<tr class="separator:a4b3ffaf4d26f2f410c72befd4f9b0ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="memTemplParams" colspan="2">
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3410f58d0023e2a0d6ae6ad85da9508c">ToSigned</a> (const T &amp;value) -&gt; decltype(static_cast&lt; std::make_signed_t&lt; T &gt;&gt;(value))</td></tr>
<tr class="memdesc:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given value to its closest signed equivalent. <br /></td></tr>
<tr class="separator:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cc0c131aa223cdb66e6eab1511d410"><td class="memItemLeft" align="right" valign="top"><a id="ae1cc0c131aa223cdb66e6eab1511d410"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae1cc0c131aa223cdb66e6eab1511d410">ToString</a> (<a class="el" href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435c">LimitState</a> val) noexcept</td></tr>
<tr class="memdesc:ae1cc0c131aa223cdb66e6eab1511d410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a human readable C-style string uniquely identifying the given limit state. <br /></td></tr>
<tr class="separator:ae1cc0c131aa223cdb66e6eab1511d410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8489f7d571594e36194a437ea93898a"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaa8489f7d571594e36194a437ea93898a">Transform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;v, const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:gaa8489f7d571594e36194a437ea93898a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by a matrix. <br /></td></tr>
<tr class="separator:gaa8489f7d571594e36194a437ea93898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fa159bf4195bff228c3fda9252a5b1"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, typename T1 , std::size_t N, typename T2 &gt; </td></tr>
<tr class="memitem:ga17fa159bf4195bff228c3fda9252a5b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga17fa159bf4195bff228c3fda9252a5b1">Transform</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, M &gt; &amp;v, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T2, M, N &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga17fa159bf4195bff228c3fda9252a5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an M-element vector by an M-by-N matrix.  <a href="group__Math.html#ga17fa159bf4195bff228c3fda9252a5b1">More...</a><br /></td></tr>
<tr class="separator:ga17fa159bf4195bff228c3fda9252a5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf49104158a7aea199f9531f9ab5b7d0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aaf49104158a7aea199f9531f9ab5b7d0">UnflagForFiltering</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:aaf49104158a7aea199f9531f9ab5b7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unflags this contact for filtering.  <a href="namespaceplayrho.html#aaf49104158a7aea199f9531f9ab5b7d0">More...</a><br /></td></tr>
<tr class="separator:aaf49104158a7aea199f9531f9ab5b7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be851da5e90da82388aaddaa1d8f6d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad0be851da5e90da82388aaddaa1d8f6d">UnflagForUpdating</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:ad0be851da5e90da82388aaddaa1d8f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unflags this contact for updating.  <a href="namespaceplayrho.html#ad0be851da5e90da82388aaddaa1d8f6d">More...</a><br /></td></tr>
<tr class="separator:ad0be851da5e90da82388aaddaa1d8f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e555a7d486dd3e1c1f7788c7d5edc0f"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4e555a7d486dd3e1c1f7788c7d5edc0f">UnsetEnabled</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a4e555a7d486dd3e1c1f7788c7d5edc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the identified contact.  <a href="namespaceplayrho.html#a4e555a7d486dd3e1c1f7788c7d5edc0f">More...</a><br /></td></tr>
<tr class="separator:a4e555a7d486dd3e1c1f7788c7d5edc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205494b248da96a02b57be9d9ad9a27b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a205494b248da96a02b57be9d9ad9a27b">UnsetImpenetrable</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a205494b248da96a02b57be9d9ad9a27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the impenetrability of the given contact.  <a href="namespaceplayrho.html#a205494b248da96a02b57be9d9ad9a27b">More...</a><br /></td></tr>
<tr class="separator:a205494b248da96a02b57be9d9ad9a27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae66cec17d17f003982ee50908d0d25"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1ae66cec17d17f003982ee50908d0d25">UnsetIsActive</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:a1ae66cec17d17f003982ee50908d0d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the active state of this contact.  <a href="namespaceplayrho.html#a1ae66cec17d17f003982ee50908d0d25">More...</a><br /></td></tr>
<tr class="separator:a1ae66cec17d17f003982ee50908d0d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad488916b3a4198e323011d0a3f417c90"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad488916b3a4198e323011d0a3f417c90">UnsetIsSensor</a> (<a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;contact) noexcept</td></tr>
<tr class="memdesc:ad488916b3a4198e323011d0a3f417c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsets the sensor state of the given contact.  <a href="namespaceplayrho.html#ad488916b3a4198e323011d0a3f417c90">More...</a><br /></td></tr>
<tr class="separator:ad488916b3a4198e323011d0a3f417c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b942aee8449be45b89aea3b870ad76b"><td class="memItemLeft" align="right" valign="top"><a id="a9b942aee8449be45b89aea3b870ad76b"></a>
<a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a9b942aee8449be45b89aea3b870ad76b">Update</a> (<a class="el" href="structplayrho_1_1RegStepStats.html">RegStepStats</a> &amp;lhs, const <a class="el" href="structplayrho_1_1IslandStats.html">IslandStats</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a9b942aee8449be45b89aea3b870ad76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates regular-phase per-step statistics with island statistics. <br /></td></tr>
<tr class="separator:a9b942aee8449be45b89aea3b870ad76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ce59a4d103ae2a050ea60a2f767d1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70ce59a4d103ae2a050ea60a2f767d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classplayrho_1_1ObjectPool.html">ObjectPool</a>&lt; T &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a70ce59a4d103ae2a050ea60a2f767d1c">used</a> (const <a class="el" href="classplayrho_1_1ObjectPool.html">ObjectPool</a>&lt; T &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:a70ce59a4d103ae2a050ea60a2f767d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements that are used in the specified structure.  <a href="namespaceplayrho.html#a70ce59a4d103ae2a050ea60a2f767d1c">More...</a><br /></td></tr>
<tr class="separator:a70ce59a4d103ae2a050ea60a2f767d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga4435a07d3cb65258172c132b134c02fb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UnitConstants.html#ga4435a07d3cb65258172c132b134c02fb">BigG</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;(6.67408e-11f) * <a class="el" href="group__PhysicalUnits.html#ga0107011ec7329a9ac267119f7ff941bb">CubicMeter</a> / (<a class="el" href="group__PhysicalUnits.html#gad4ca745853415c1b3df906848978df9d">Kilogram</a> * <a class="el" href="group__PhysicalUnits.html#ga64467fca61de8c359a4e019f977ff320">SquareSecond</a>)</td></tr>
<tr class="memdesc:ga4435a07d3cb65258172c132b134c02fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Big "G".  <a href="group__UnitConstants.html#ga4435a07d3cb65258172c132b134c02fb">More...</a><br /></td></tr>
<tr class="separator:ga4435a07d3cb65258172c132b134c02fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0367ca8edd23b32c868e3fe5f79082ef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga0367ca8edd23b32c868e3fe5f79082ef">Centi</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e-2)</td></tr>
<tr class="memdesc:ga0367ca8edd23b32c868e3fe5f79082ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centi- (1 x 10^-2).  <a href="group__DecimalUnitPrefices.html#ga0367ca8edd23b32c868e3fe5f79082ef">More...</a><br /></td></tr>
<tr class="separator:ga0367ca8edd23b32c868e3fe5f79082ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0107011ec7329a9ac267119f7ff941bb"><td class="memItemLeft" align="right" valign="top">
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga0107011ec7329a9ac267119f7ff941bb">CubicMeter</a> = <a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a> * <a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a> * <a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a></td></tr>
<tr class="memdesc:ga0107011ec7329a9ac267119f7ff941bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic meter unit of volume. <br /></td></tr>
<tr class="separator:ga0107011ec7329a9ac267119f7ff941bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a49a7e54c1b478f5b1cc882aa55f2d3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga5a49a7e54c1b478f5b1cc882aa55f2d3">Deci</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e-1)</td></tr>
<tr class="memdesc:ga5a49a7e54c1b478f5b1cc882aa55f2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deci- (1 x 10^-1).  <a href="group__DecimalUnitPrefices.html#ga5a49a7e54c1b478f5b1cc882aa55f2d3">More...</a><br /></td></tr>
<tr class="separator:ga5a49a7e54c1b478f5b1cc882aa55f2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd06178e859667c8f65b26c4e91972e"><td class="memItemLeft" align="right" valign="top"><a id="a3dd06178e859667c8f65b26c4e91972e"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3dd06178e859667c8f65b26c4e91972e">DefaultAabbExtension</a> = <a class="el" href="namespaceplayrho.html#ad91e53ba44755653e34147d39695a0a1">DefaultLinearSlop</a> * <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(20)</td></tr>
<tr class="memdesc:a3dd06178e859667c8f65b26c4e91972e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default AABB extension amount. <br /></td></tr>
<tr class="separator:a3dd06178e859667c8f65b26c4e91972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31907e80be5889667f03ef86ee3bbf0a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a31907e80be5889667f03ef86ee3bbf0a">DefaultAngularSleepTolerance</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>((<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2) / 180) * <a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a></td></tr>
<tr class="separator:a31907e80be5889667f03ef86ee3bbf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfccbc3cd8cc0bb78701f62e041acdba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adfccbc3cd8cc0bb78701f62e041acdba">DefaultAngularSlop</a> = (<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2_rad) / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(180)</td></tr>
<tr class="memdesc:adfccbc3cd8cc0bb78701f62e041acdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default angular slop.  <a href="namespaceplayrho.html#adfccbc3cd8cc0bb78701f62e041acdba">More...</a><br /></td></tr>
<tr class="separator:adfccbc3cd8cc0bb78701f62e041acdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12a28e4c1a2b9138c79d895d3ccb3aa"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac12a28e4c1a2b9138c79d895d3ccb3aa">DefaultCirclesRatio</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(10)</td></tr>
<tr class="separator:ac12a28e4c1a2b9138c79d895d3ccb3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2898b34e4bf5fe5af48939ec34e48f6"><td class="memItemLeft" align="right" valign="top"><a id="ab2898b34e4bf5fe5af48939ec34e48f6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab2898b34e4bf5fe5af48939ec34e48f6">DefaultDistanceMultiplier</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(2)</td></tr>
<tr class="memdesc:ab2898b34e4bf5fe5af48939ec34e48f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default distance multiplier. <br /></td></tr>
<tr class="separator:ab2898b34e4bf5fe5af48939ec34e48f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490b0d336b7a74ae18cf57632eeb7aa9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a490b0d336b7a74ae18cf57632eeb7aa9">DefaultLinearSleepTolerance</a> = 0.01_mps</td></tr>
<tr class="separator:a490b0d336b7a74ae18cf57632eeb7aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91e53ba44755653e34147d39695a0a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad91e53ba44755653e34147d39695a0a1">DefaultLinearSlop</a> = 0.005_m</td></tr>
<tr class="memdesc:ad91e53ba44755653e34147d39695a0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default linear slop.  <a href="namespaceplayrho.html#ad91e53ba44755653e34147d39695a0a1">More...</a><br /></td></tr>
<tr class="separator:ad91e53ba44755653e34147d39695a0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fea4a93f741aa800e943957fd23656"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ac8fea4a93f741aa800e943957fd23656">DefaultMaxAngularCorrection</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(8.0f / 180.0f) * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 1_rad</td></tr>
<tr class="memdesc:ac8fea4a93f741aa800e943957fd23656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum angular correction.  <a href="namespaceplayrho.html#ac8fea4a93f741aa800e943957fd23656">More...</a><br /></td></tr>
<tr class="separator:ac8fea4a93f741aa800e943957fd23656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea893c840466088049edc292dcc9dcb"><td class="memItemLeft" align="right" valign="top"><a id="adea893c840466088049edc292dcc9dcb"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adea893c840466088049edc292dcc9dcb">DefaultMaxDistanceIters</a> = std::uint8_t{20}</td></tr>
<tr class="memdesc:adea893c840466088049edc292dcc9dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default max number of distance iterations. <br /></td></tr>
<tr class="separator:adea893c840466088049edc292dcc9dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d2cfbedb9200e2ed973eb18cc3b23b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa7d2cfbedb9200e2ed973eb18cc3b23b">DefaultMaxLinearCorrection</a> = 0.2_m</td></tr>
<tr class="memdesc:aa7d2cfbedb9200e2ed973eb18cc3b23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum linear correction.  <a href="namespaceplayrho.html#aa7d2cfbedb9200e2ed973eb18cc3b23b">More...</a><br /></td></tr>
<tr class="separator:aa7d2cfbedb9200e2ed973eb18cc3b23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c3a1adc34421b07e930a06ce905db1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a36c3a1adc34421b07e930a06ce905db1">DefaultMaxRotation</a> = <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>{179_deg}</td></tr>
<tr class="memdesc:a36c3a1adc34421b07e930a06ce905db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum rotation per world step.  <a href="namespaceplayrho.html#a36c3a1adc34421b07e930a06ce905db1">More...</a><br /></td></tr>
<tr class="separator:a36c3a1adc34421b07e930a06ce905db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa678e38c906502e06a90f31e2acc952a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa678e38c906502e06a90f31e2acc952a">DefaultMaxSubSteps</a> = std::uint8_t{8}</td></tr>
<tr class="separator:aa678e38c906502e06a90f31e2acc952a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c87be197db81dde7d9f64ddd888bae"><td class="memItemLeft" align="right" valign="top"><a id="ab6c87be197db81dde7d9f64ddd888bae"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab6c87be197db81dde7d9f64ddd888bae">DefaultMaxToiIters</a> = std::uint8_t{20}</td></tr>
<tr class="memdesc:ab6c87be197db81dde7d9f64ddd888bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum time of impact iterations. <br /></td></tr>
<tr class="separator:ab6c87be197db81dde7d9f64ddd888bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad369e106022da8a461ed8a515014ee17"><td class="memItemLeft" align="right" valign="top"><a id="ad369e106022da8a461ed8a515014ee17"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ad369e106022da8a461ed8a515014ee17">DefaultMaxToiRootIters</a> = std::uint8_t{30}</td></tr>
<tr class="memdesc:ad369e106022da8a461ed8a515014ee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum time of impact root iterator count. <br /></td></tr>
<tr class="separator:ad369e106022da8a461ed8a515014ee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71ffce08877ce941d29616eb907114"><td class="memItemLeft" align="right" valign="top"><a id="a6b71ffce08877ce941d29616eb907114"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6b71ffce08877ce941d29616eb907114">DefaultMaxTranslation</a> = 2_m</td></tr>
<tr class="memdesc:a6b71ffce08877ce941d29616eb907114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum translation amount. <br /></td></tr>
<tr class="separator:a6b71ffce08877ce941d29616eb907114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beadf6067bdf66f48ee9b94c337d252"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7beadf6067bdf66f48ee9b94c337d252">DefaultMaxVertexRadius</a> = 255_m</td></tr>
<tr class="memdesc:a7beadf6067bdf66f48ee9b94c337d252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default maximum vertex radius.  <a href="namespaceplayrho.html#a7beadf6067bdf66f48ee9b94c337d252">More...</a><br /></td></tr>
<tr class="separator:a7beadf6067bdf66f48ee9b94c337d252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e76508577c61a5bc9cc3107d60f3c1b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0e76508577c61a5bc9cc3107d60f3c1b">DefaultMinStillTimeToSleep</a> = <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>{1_s / 2}</td></tr>
<tr class="separator:a0e76508577c61a5bc9cc3107d60f3c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174cfa632eb92c15bc2e48e7d09d216a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a174cfa632eb92c15bc2e48e7d09d216a">DefaultMinVertexRadius</a> = 0.01_m</td></tr>
<tr class="memdesc:a174cfa632eb92c15bc2e48e7d09d216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default minimum vertex radius.  <a href="namespaceplayrho.html#a174cfa632eb92c15bc2e48e7d09d216a">More...</a><br /></td></tr>
<tr class="separator:a174cfa632eb92c15bc2e48e7d09d216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8eb622479d2ffb28ce1a4e88e8a211f"><td class="memItemLeft" align="right" valign="top"><a id="ab8eb622479d2ffb28ce1a4e88e8a211f"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ab8eb622479d2ffb28ce1a4e88e8a211f">DefaultRegMinMomentum</a> = <a class="el" href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">Momentum</a>{0_Ns / 100}</td></tr>
<tr class="memdesc:ab8eb622479d2ffb28ce1a4e88e8a211f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default regular-phase minimum momentum. <br /></td></tr>
<tr class="separator:ab8eb622479d2ffb28ce1a4e88e8a211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e94545b5052523414ec03d0e95e2297"><td class="memItemLeft" align="right" valign="top">
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga2e94545b5052523414ec03d0e95e2297">DefaultRoundOffPrecission</a> = unsigned{100000}</td></tr>
<tr class="memdesc:ga2e94545b5052523414ec03d0e95e2297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default round-off precision. <br /></td></tr>
<tr class="separator:ga2e94545b5052523414ec03d0e95e2297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65202bedf970d0db4ad0d3e22ab3a0dd"><td class="memItemLeft" align="right" valign="top"><a id="a65202bedf970d0db4ad0d3e22ab3a0dd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a65202bedf970d0db4ad0d3e22ab3a0dd">DefaultStepFrequency</a> = 60_Hz</td></tr>
<tr class="memdesc:a65202bedf970d0db4ad0d3e22ab3a0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step frequency. <br /></td></tr>
<tr class="separator:a65202bedf970d0db4ad0d3e22ab3a0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e5b3bf0a53f853c75244a15b08caee"><td class="memItemLeft" align="right" valign="top"><a id="a51e5b3bf0a53f853c75244a15b08caee"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a51e5b3bf0a53f853c75244a15b08caee">DefaultStepTime</a> = <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>{1_s / 60}</td></tr>
<tr class="memdesc:a51e5b3bf0a53f853c75244a15b08caee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default step time. <br /></td></tr>
<tr class="separator:a51e5b3bf0a53f853c75244a15b08caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e51d5b5ce397624e803df05ff1c013"><td class="memItemLeft" align="right" valign="top"><a id="a88e51d5b5ce397624e803df05ff1c013"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a88e51d5b5ce397624e803df05ff1c013">DefaultToiMinMomentum</a> = <a class="el" href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">Momentum</a>{0_Ns / 100}</td></tr>
<tr class="memdesc:a88e51d5b5ce397624e803df05ff1c013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TOI-phase minimum momentum. <br /></td></tr>
<tr class="separator:a88e51d5b5ce397624e803df05ff1c013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6497dbff92f4140c03fb29f7dc80093d"><td class="memItemLeft" align="right" valign="top"><a id="a6497dbff92f4140c03fb29f7dc80093d"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6497dbff92f4140c03fb29f7dc80093d">DefaultVelocityThreshold</a> = 1_mps</td></tr>
<tr class="memdesc:a6497dbff92f4140c03fb29f7dc80093d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default velocity threshold. <br /></td></tr>
<tr class="separator:a6497dbff92f4140c03fb29f7dc80093d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0840a4c6fcfa4ed0f1e25820fea0ca3"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">Degree</a> = <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>{<a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{180}}</td></tr>
<tr class="memdesc:gaf0840a4c6fcfa4ed0f1e25820fea0ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree unit of angle quantity.  <a href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">More...</a><br /></td></tr>
<tr class="separator:gaf0840a4c6fcfa4ed0f1e25820fea0ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987ba57899c87b7d6734d046d1c854b8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga987ba57899c87b7d6734d046d1c854b8">DegreePerSecond</a> = <a class="el" href="group__PhysicalQuantities.html#ga8b4603a98e526262c2e4adfe99510672">AngularVelocity</a>{<a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a> * <a class="el" href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">Degree</a> / <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a>}</td></tr>
<tr class="memdesc:ga987ba57899c87b7d6734d046d1c854b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree per second unit of angular velocity.  <a href="group__PhysicalUnits.html#ga987ba57899c87b7d6734d046d1c854b8">More...</a><br /></td></tr>
<tr class="separator:ga987ba57899c87b7d6734d046d1c854b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7cdea552b0f98a011b3287850433a2"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga7a7cdea552b0f98a011b3287850433a2">DegreePerSquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#gaf0840a4c6fcfa4ed0f1e25820fea0ca3">Degree</a> / (<a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a>)</td></tr>
<tr class="memdesc:ga7a7cdea552b0f98a011b3287850433a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Degree per square second unit of angular acceleration.  <a href="group__PhysicalUnits.html#ga7a7cdea552b0f98a011b3287850433a2">More...</a><br /></td></tr>
<tr class="separator:ga7a7cdea552b0f98a011b3287850433a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770e7e3c14510e96d5115b36988e5dde"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UnitConstants.html#ga770e7e3c14510e96d5115b36988e5dde">EarthlyLinearAcceleration</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;(-9.8f) * <a class="el" href="group__PhysicalUnits.html#ga0bc87db1f0fbc1b5f1ae9b44c66b6e82">MeterPerSquareSecond</a></td></tr>
<tr class="memdesc:ga770e7e3c14510e96d5115b36988e5dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Earthly gravity.  <a href="group__UnitConstants.html#ga770e7e3c14510e96d5115b36988e5dde">More...</a><br /></td></tr>
<tr class="separator:ga770e7e3c14510e96d5115b36988e5dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ca2124fd143e2433bb2f409dc83f92"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga66ca2124fd143e2433bb2f409dc83f92">Giga</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e9)</td></tr>
<tr class="memdesc:ga66ca2124fd143e2433bb2f409dc83f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Giga- (1 x 10^9).  <a href="group__DecimalUnitPrefices.html#ga66ca2124fd143e2433bb2f409dc83f92">More...</a><br /></td></tr>
<tr class="separator:ga66ca2124fd143e2433bb2f409dc83f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef54036b9480e0cf730100688e20570"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gadef54036b9480e0cf730100688e20570">Hertz</a> = <a class="el" href="group__PhysicalQuantities.html#ga526d114a9d34d7237ed3e41829ab3eff">Frequency</a>(<a class="el" href="namespaceplayrho_1_1detail.html#af1e0c512dc16bc8796eaffc38727193d">detail::hertz</a>)</td></tr>
<tr class="memdesc:gadef54036b9480e0cf730100688e20570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hertz unit of Frequency.  <a href="group__PhysicalUnits.html#gadef54036b9480e0cf730100688e20570">More...</a><br /></td></tr>
<tr class="separator:gadef54036b9480e0cf730100688e20570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c4c9f92abc8bb90f494053a8e04375"><td class="memTemplParams" colspan="2">template&lt;class T , std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::has_signaling_NaN||std::numeric_limits&lt; T &gt;::has_quiet_NaN, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae4c4c9f92abc8bb90f494053a8e04375"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae4c4c9f92abc8bb90f494053a8e04375">Invalid</a></td></tr>
<tr class="memdesc:ae4c4c9f92abc8bb90f494053a8e04375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid value of the template's instantiated numeric type.  <a href="namespaceplayrho.html#ae4c4c9f92abc8bb90f494053a8e04375">More...</a><br /></td></tr>
<tr class="separator:ae4c4c9f92abc8bb90f494053a8e04375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fa6c4a45ec8fd218dc962396685c3f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a38fa6c4a45ec8fd218dc962396685c3f">InvalidBodyID</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a>&gt;(static_cast&lt;<a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html#a2ed01bf69779b0880b5092c6bbad560b">BodyID::underlying_type</a>&gt;(-1))</td></tr>
<tr class="memdesc:a38fa6c4a45ec8fd218dc962396685c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid body ID value.  <a href="namespaceplayrho.html#a38fa6c4a45ec8fd218dc962396685c3f">More...</a><br /></td></tr>
<tr class="separator:a38fa6c4a45ec8fd218dc962396685c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7a2c4f0ce447813c94060e1ea4c0f9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a1a7a2c4f0ce447813c94060e1ea4c0f9">InvalidContactID</a></td></tr>
<tr class="memdesc:a1a7a2c4f0ce447813c94060e1ea4c0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid contact ID value.  <a href="namespaceplayrho.html#a1a7a2c4f0ce447813c94060e1ea4c0f9">More...</a><br /></td></tr>
<tr class="separator:a1a7a2c4f0ce447813c94060e1ea4c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecc8cc059a2a3fa056888a1d405e4bc"><td class="memItemLeft" align="right" valign="top"><a id="a4ecc8cc059a2a3fa056888a1d405e4bc"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a4ecc8cc059a2a3fa056888a1d405e4bc">InvalidContactIndex</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>&gt;(-1)</td></tr>
<tr class="memdesc:a4ecc8cc059a2a3fa056888a1d405e4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid contact index. <br /></td></tr>
<tr class="separator:a4ecc8cc059a2a3fa056888a1d405e4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb9d11a6fadb62b0e68aee9797059ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">InvalidIndexPair</a></td></tr>
<tr class="memdesc:a6fb9d11a6fadb62b0e68aee9797059ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid index-pair value.  <a href="namespaceplayrho.html#a6fb9d11a6fadb62b0e68aee9797059ad">More...</a><br /></td></tr>
<tr class="separator:a6fb9d11a6fadb62b0e68aee9797059ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d10419efd6effdd41617992a76cbcd"><td class="memItemLeft" align="right" valign="top"><a id="a67d10419efd6effdd41617992a76cbcd"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a67d10419efd6effdd41617992a76cbcd">InvalidJointID</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a8e3114be8fb50493389d7991db4f2b3d">JointID</a>&gt;(static_cast&lt;<a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html#a2ed01bf69779b0880b5092c6bbad560b">JointID::underlying_type</a>&gt;(-1))</td></tr>
<tr class="memdesc:a67d10419efd6effdd41617992a76cbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid joint ID value. <br /></td></tr>
<tr class="separator:a67d10419efd6effdd41617992a76cbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2525da093ca5647aa7493b07eed63520"><td class="memItemLeft" align="right" valign="top"><a id="a2525da093ca5647aa7493b07eed63520"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2525da093ca5647aa7493b07eed63520">InvalidLength2</a> = <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>{<a class="el" href="namespaceplayrho.html#ae4c4c9f92abc8bb90f494053a8e04375">Invalid</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&gt;, <a class="el" href="namespaceplayrho.html#ae4c4c9f92abc8bb90f494053a8e04375">Invalid</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&gt;}</td></tr>
<tr class="memdesc:a2525da093ca5647aa7493b07eed63520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid <code>Length2</code> constant. <br /></td></tr>
<tr class="separator:a2525da093ca5647aa7493b07eed63520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf47dd833aad177ac33142cfc5e6bc3"><td class="memItemLeft" align="right" valign="top"><a id="a7cf47dd833aad177ac33142cfc5e6bc3"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7cf47dd833aad177ac33142cfc5e6bc3">InvalidShapeID</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a>&gt;(static_cast&lt;<a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html#a2ed01bf69779b0880b5092c6bbad560b">ShapeID::underlying_type</a>&gt;(-1))</td></tr>
<tr class="memdesc:a7cf47dd833aad177ac33142cfc5e6bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid fixture ID value. <br /></td></tr>
<tr class="separator:a7cf47dd833aad177ac33142cfc5e6bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c511e18a6b72260126cf763c1cd8df"><td class="memItemLeft" align="right" valign="top"><a id="a49c511e18a6b72260126cf763c1cd8df"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">InvalidVertex</a> = static_cast&lt;<a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a>&gt;(-1)</td></tr>
<tr class="memdesc:a49c511e18a6b72260126cf763c1cd8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid vertex index. <br /></td></tr>
<tr class="separator:a49c511e18a6b72260126cf763c1cd8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ba382902aedb57e9c98fc250ec2bf5"><td class="memTemplParams" colspan="2"><a id="a41ba382902aedb57e9c98fc250ec2bf5"></a>
template&lt;class T1 , class T2  = T1&gt; </td></tr>
<tr class="memitem:a41ba382902aedb57e9c98fc250ec2bf5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a41ba382902aedb57e9c98fc250ec2bf5">IsAddableV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsAddable.html">detail::IsAddable</a>&lt;T1, T2&gt;::value</td></tr>
<tr class="memdesc:a41ba382902aedb57e9c98fc250ec2bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is an addable type. <br /></td></tr>
<tr class="separator:a41ba382902aedb57e9c98fc250ec2bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c55e27192da826391d895835f02b17"><td class="memTemplParams" colspan="2"><a id="aa9c55e27192da826391d895835f02b17"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa9c55e27192da826391d895835f02b17"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aa9c55e27192da826391d895835f02b17">IsArithmeticV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsArithmetic.html">detail::IsArithmetic</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aa9c55e27192da826391d895835f02b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is an arithmetic type. <br /></td></tr>
<tr class="separator:aa9c55e27192da826391d895835f02b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcd4932a27b9347d3afbae550fa57d2"><td class="memTemplParams" colspan="2"><a id="abdcd4932a27b9347d3afbae550fa57d2"></a>
template&lt;class T1 , class T2  = T1&gt; </td></tr>
<tr class="memitem:abdcd4932a27b9347d3afbae550fa57d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#abdcd4932a27b9347d3afbae550fa57d2">IsDivisableV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsDivisable.html">detail::IsDivisable</a>&lt;T1, T2&gt;::value</td></tr>
<tr class="memdesc:abdcd4932a27b9347d3afbae550fa57d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a divisible type. <br /></td></tr>
<tr class="separator:abdcd4932a27b9347d3afbae550fa57d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66a2bc90bba3e9b065c20da1f5d468"><td class="memTemplParams" colspan="2"><a id="a7e66a2bc90bba3e9b065c20da1f5d468"></a>
template&lt;class T1 , class T2  = T1&gt; </td></tr>
<tr class="memitem:a7e66a2bc90bba3e9b065c20da1f5d468"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7e66a2bc90bba3e9b065c20da1f5d468">IsEqualityComparableV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsEqualityComparable.html">detail::IsEqualityComparable</a>&lt;T1, T2&gt;::value</td></tr>
<tr class="memdesc:a7e66a2bc90bba3e9b065c20da1f5d468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given types are equality comparable. <br /></td></tr>
<tr class="separator:a7e66a2bc90bba3e9b065c20da1f5d468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137a2dd0c34c1efb94ea6f5b89dba530"><td class="memTemplParams" colspan="2"><a id="a137a2dd0c34c1efb94ea6f5b89dba530"></a>
template&lt;class T1 , class T2  = T1&gt; </td></tr>
<tr class="memitem:a137a2dd0c34c1efb94ea6f5b89dba530"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a137a2dd0c34c1efb94ea6f5b89dba530">IsInequalityComparableV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsInequalityComparable.html">detail::IsInequalityComparable</a>&lt;T1, T2&gt;::value</td></tr>
<tr class="memdesc:a137a2dd0c34c1efb94ea6f5b89dba530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given types are inequality comparable. <br /></td></tr>
<tr class="separator:a137a2dd0c34c1efb94ea6f5b89dba530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f251f126cac1015f8636e99ac0f4db"><td class="memTemplParams" colspan="2"><a id="ae2f251f126cac1015f8636e99ac0f4db"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2f251f126cac1015f8636e99ac0f4db"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#ae2f251f126cac1015f8636e99ac0f4db">IsIterableV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsIterable.html">detail::IsIterable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ae2f251f126cac1015f8636e99ac0f4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is an iterable type. <br /></td></tr>
<tr class="separator:ae2f251f126cac1015f8636e99ac0f4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83567b7faf3c7de0399b0b88fe1cc9f5"><td class="memTemplParams" colspan="2"><a id="a83567b7faf3c7de0399b0b88fe1cc9f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a83567b7faf3c7de0399b0b88fe1cc9f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a83567b7faf3c7de0399b0b88fe1cc9f5">IsMatrixV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsMatrix.html">detail::IsMatrix</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a83567b7faf3c7de0399b0b88fe1cc9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a <code>Matrix</code> type. <br /></td></tr>
<tr class="separator:a83567b7faf3c7de0399b0b88fe1cc9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2c0d8136a2aabd56742fbedf6c00ad"><td class="memTemplParams" colspan="2"><a id="a3c2c0d8136a2aabd56742fbedf6c00ad"></a>
template&lt;class T1 , class T2  = T1&gt; </td></tr>
<tr class="memitem:a3c2c0d8136a2aabd56742fbedf6c00ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsMultipliable.html">detail::IsMultipliable</a>&lt;T1, T2&gt;::value</td></tr>
<tr class="memdesc:a3c2c0d8136a2aabd56742fbedf6c00ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a multipliable type. <br /></td></tr>
<tr class="separator:a3c2c0d8136a2aabd56742fbedf6c00ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaec996c65bbbcac537113d83ee753c5"><td class="memTemplParams" colspan="2"><a id="adaec996c65bbbcac537113d83ee753c5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adaec996c65bbbcac537113d83ee753c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#adaec996c65bbbcac537113d83ee753c5">IsReverseIterableV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsReverseIterable.html">detail::IsReverseIterable</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:adaec996c65bbbcac537113d83ee753c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a reverse iterable type. <br /></td></tr>
<tr class="separator:adaec996c65bbbcac537113d83ee753c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b74d27a9f43c1f37aca5ee84aa6f97"><td class="memTemplParams" colspan="2"><a id="a14b74d27a9f43c1f37aca5ee84aa6f97"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a14b74d27a9f43c1f37aca5ee84aa6f97"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a14b74d27a9f43c1f37aca5ee84aa6f97">IsSquareMatrixV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsSquareMatrix.html">detail::IsSquareMatrix</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a14b74d27a9f43c1f37aca5ee84aa6f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a <b>square</b> <code>Matrix</code> type. <br /></td></tr>
<tr class="separator:a14b74d27a9f43c1f37aca5ee84aa6f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168449a74e78ad00c9d22f1017de05f7"><td class="memTemplParams" colspan="2"><a id="a168449a74e78ad00c9d22f1017de05f7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a168449a74e78ad00c9d22f1017de05f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a> = <a class="el" href="structplayrho_1_1detail_1_1IsVector.html">detail::IsVector</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a168449a74e78ad00c9d22f1017de05f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given type is a <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a></code> type. <br /></td></tr>
<tr class="separator:a168449a74e78ad00c9d22f1017de05f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae537180a6f4ceb3a3192ee623fc2c8bc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#gae537180a6f4ceb3a3192ee623fc2c8bc">Kilo</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e3)</td></tr>
<tr class="memdesc:gae537180a6f4ceb3a3192ee623fc2c8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilo- (1 x 10^3).  <a href="group__DecimalUnitPrefices.html#gae537180a6f4ceb3a3192ee623fc2c8bc">More...</a><br /></td></tr>
<tr class="separator:gae537180a6f4ceb3a3192ee623fc2c8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ca745853415c1b3df906848978df9d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gad4ca745853415c1b3df906848978df9d">Kilogram</a> = <a class="el" href="group__PhysicalQuantities.html#gaaf74540633aeb472114381118842149e">Mass</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a90daaeb1a99f74ec5f8c859c293e798d">detail::kilogram</a>)</td></tr>
<tr class="memdesc:gad4ca745853415c1b3df906848978df9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilogram unit of mass.  <a href="group__PhysicalUnits.html#gad4ca745853415c1b3df906848978df9d">More...</a><br /></td></tr>
<tr class="separator:gad4ca745853415c1b3df906848978df9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64416f646855741c31802eb689760ba8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga64416f646855741c31802eb689760ba8">KilogramPerSquareMeter</a> = <a class="el" href="group__PhysicalQuantities.html#ga6bcf1d1de9ef60a9833c222efe7ffd57">AreaDensity</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a0496d072cedb43873f5558c5e5a4c0e3">detail::kilogram_per_square_meter</a>)</td></tr>
<tr class="memdesc:ga64416f646855741c31802eb689760ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kilogram per square meter unit of area density.  <a href="group__PhysicalUnits.html#ga64416f646855741c31802eb689760ba8">More...</a><br /></td></tr>
<tr class="separator:ga64416f646855741c31802eb689760ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b821c4b23566defba0fd2917d95f0ba"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a></td></tr>
<tr class="memdesc:a7b821c4b23566defba0fd2917d95f0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of bodies in a world.  <a href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">More...</a><br /></td></tr>
<tr class="separator:a7b821c4b23566defba0fd2917d95f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33623a59b7c701aead6d06e88dc2cc6"><td class="memItemLeft" align="right" valign="top"><a id="af33623a59b7c701aead6d06e88dc2cc6"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#af33623a59b7c701aead6d06e88dc2cc6">MaxChildCount</a> = std::numeric_limits&lt;std::uint32_t&gt;::max() &gt;&gt; 6</td></tr>
<tr class="memdesc:af33623a59b7c701aead6d06e88dc2cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max child count. <br /></td></tr>
<tr class="separator:af33623a59b7c701aead6d06e88dc2cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac18ab5fe22782c56d7ab92b397468e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a5ac18ab5fe22782c56d7ab92b397468e">MaxContacts</a> = <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>} * <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a> - 1} / <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>{2}</td></tr>
<tr class="memdesc:a5ac18ab5fe22782c56d7ab92b397468e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of contacts in a world (2147319811).  <a href="namespaceplayrho.html#a5ac18ab5fe22782c56d7ab92b397468e">More...</a><br /></td></tr>
<tr class="separator:a5ac18ab5fe22782c56d7ab92b397468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527c4658d275e6c04ba4b4c9f28d688b"><td class="memItemLeft" align="right" valign="top"><a id="a527c4658d275e6c04ba4b4c9f28d688b"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a527c4658d275e6c04ba4b4c9f28d688b">MaxFloat</a> = std::numeric_limits&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;::max()</td></tr>
<tr class="memdesc:a527c4658d275e6c04ba4b4c9f28d688b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum float value. <br /></td></tr>
<tr class="separator:a527c4658d275e6c04ba4b4c9f28d688b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cde8c9e938d138a9a4ae8355501684"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">MaxJoints</a></td></tr>
<tr class="memdesc:a69cde8c9e938d138a9a4ae8355501684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of joints in a world.  <a href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">More...</a><br /></td></tr>
<tr class="separator:a69cde8c9e938d138a9a4ae8355501684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae670387c8f37f8812082b1838e18863"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aae670387c8f37f8812082b1838e18863">MaxManifoldPoints</a> = std::uint8_t{2}</td></tr>
<tr class="separator:aae670387c8f37f8812082b1838e18863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e673e5e335bf14ece1382b582f2163b"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a2e673e5e335bf14ece1382b582f2163b">MaxShapes</a></td></tr>
<tr class="memdesc:a2e673e5e335bf14ece1382b582f2163b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of shapes in a world.  <a href="namespaceplayrho.html#a2e673e5e335bf14ece1382b582f2163b">More...</a><br /></td></tr>
<tr class="separator:a2e673e5e335bf14ece1382b582f2163b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0774f630ff2e5b9ed9e5f322700d44e4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">MaxShapeVertices</a> = std::uint8_t{254}</td></tr>
<tr class="memdesc:a0774f630ff2e5b9ed9e5f322700d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of vertices for any shape type.  <a href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">More...</a><br /></td></tr>
<tr class="separator:a0774f630ff2e5b9ed9e5f322700d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95591102a273a4d301f3f795d463b9ba"><td class="memItemLeft" align="right" valign="top"><a id="a95591102a273a4d301f3f795d463b9ba"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a95591102a273a4d301f3f795d463b9ba">MaxSimplexEdges</a> = std::uint8_t{3}</td></tr>
<tr class="memdesc:a95591102a273a4d301f3f795d463b9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of supportable edges in a simplex. <br /></td></tr>
<tr class="separator:a95591102a273a4d301f3f795d463b9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b2132b6101f0d7f6b3658147025168"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#gad7b2132b6101f0d7f6b3658147025168">Mega</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e6)</td></tr>
<tr class="memdesc:gad7b2132b6101f0d7f6b3658147025168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mega- (1 x 10^6).  <a href="group__DecimalUnitPrefices.html#gad7b2132b6101f0d7f6b3658147025168">More...</a><br /></td></tr>
<tr class="separator:gad7b2132b6101f0d7f6b3658147025168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5d1d9c70d11cff5fb552e939de39b9c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">Meter</a> = <a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a573a42126bffa5d938fac528d015eaa6">detail::meter</a>)</td></tr>
<tr class="memdesc:gab5d1d9c70d11cff5fb552e939de39b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter unit of Length.  <a href="group__PhysicalUnits.html#gab5d1d9c70d11cff5fb552e939de39b9c">More...</a><br /></td></tr>
<tr class="separator:gab5d1d9c70d11cff5fb552e939de39b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d80fc94ec9d5990d2fa6b9e4b67267d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga9d80fc94ec9d5990d2fa6b9e4b67267d">MeterPerSecond</a> = <a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a4e352c62d4a20f166b0eb0d529404943">detail::meter_per_second</a>)</td></tr>
<tr class="memdesc:ga9d80fc94ec9d5990d2fa6b9e4b67267d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter per second unit of linear velocity.  <a href="group__PhysicalUnits.html#ga9d80fc94ec9d5990d2fa6b9e4b67267d">More...</a><br /></td></tr>
<tr class="separator:ga9d80fc94ec9d5990d2fa6b9e4b67267d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc87db1f0fbc1b5f1ae9b44c66b6e82"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga0bc87db1f0fbc1b5f1ae9b44c66b6e82">MeterPerSquareSecond</a> = <a class="el" href="group__PhysicalQuantities.html#gaea2069744ddc1c5068705b00f957451a">LinearAcceleration</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a9306a61d0f8717e859093dd09277ae92">detail::meter_per_second_squared</a>)</td></tr>
<tr class="memdesc:ga0bc87db1f0fbc1b5f1ae9b44c66b6e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meter per square second unit of linear acceleration.  <a href="group__PhysicalUnits.html#ga0bc87db1f0fbc1b5f1ae9b44c66b6e82">More...</a><br /></td></tr>
<tr class="separator:ga0bc87db1f0fbc1b5f1ae9b44c66b6e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac88db74a1ddb390655f0837d9c970f76"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gac88db74a1ddb390655f0837d9c970f76">Newton</a> = <a class="el" href="group__PhysicalQuantities.html#gad51dd88ec6a5b3bf384dc89a63019d9d">Force</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a39a63c7fa9f3a8a7d2aa3ed6c375861d">detail::newton</a>)</td></tr>
<tr class="memdesc:gac88db74a1ddb390655f0837d9c970f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton unit of force.  <a href="group__PhysicalUnits.html#gac88db74a1ddb390655f0837d9c970f76">More...</a><br /></td></tr>
<tr class="separator:gac88db74a1ddb390655f0837d9c970f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab920bd1046410474258f9e8630e557a1"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gab920bd1046410474258f9e8630e557a1">NewtonMeter</a> = <a class="el" href="group__PhysicalQuantities.html#ga1acd0787ea4caa9725577e0aa2fdc9b7">Torque</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a60bc3b612446a1b018a7bdffa78a47c3">detail::newton_meter</a>)</td></tr>
<tr class="memdesc:gab920bd1046410474258f9e8630e557a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton meter unit of torque.  <a href="group__PhysicalUnits.html#gab920bd1046410474258f9e8630e557a1">More...</a><br /></td></tr>
<tr class="separator:gab920bd1046410474258f9e8630e557a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae55524173aec32daa74def2b8dddc0bb"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gae55524173aec32daa74def2b8dddc0bb">NewtonMeterSecond</a> = <a class="el" href="group__PhysicalUnits.html#gab920bd1046410474258f9e8630e557a1">NewtonMeter</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a></td></tr>
<tr class="memdesc:gae55524173aec32daa74def2b8dddc0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton meter second unit of angular momentum.  <a href="group__PhysicalUnits.html#gae55524173aec32daa74def2b8dddc0bb">More...</a><br /></td></tr>
<tr class="separator:gae55524173aec32daa74def2b8dddc0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64db6556e1824d11178c3d68301c2adc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga64db6556e1824d11178c3d68301c2adc">NewtonSecond</a> = <a class="el" href="group__PhysicalUnits.html#gac88db74a1ddb390655f0837d9c970f76">Newton</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a></td></tr>
<tr class="memdesc:ga64db6556e1824d11178c3d68301c2adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton second unit of momentum.  <a href="group__PhysicalUnits.html#ga64db6556e1824d11178c3d68301c2adc">More...</a><br /></td></tr>
<tr class="separator:ga64db6556e1824d11178c3d68301c2adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590efc6f9c2013056da85de7ab4e84ae"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga590efc6f9c2013056da85de7ab4e84ae">Peta</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e15)</td></tr>
<tr class="memdesc:ga590efc6f9c2013056da85de7ab4e84ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peta- (1 x 10^15).  <a href="group__DecimalUnitPrefices.html#ga590efc6f9c2013056da85de7ab4e84ae">More...</a><br /></td></tr>
<tr class="separator:ga590efc6f9c2013056da85de7ab4e84ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe0bdbb0ea9c449b7504f7c75840993"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(3.14159265358979323846264338327950288L)</td></tr>
<tr class="memdesc:a3fe0bdbb0ea9c449b7504f7c75840993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pi.  <a href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">More...</a><br /></td></tr>
<tr class="separator:a3fe0bdbb0ea9c449b7504f7c75840993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbe3f5282db32af8292500e505e21e5"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> = <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>(<a class="el" href="namespaceplayrho_1_1detail.html#afd99f222426ee977eb5660bbd03b05a5">detail::radian</a>)</td></tr>
<tr class="memdesc:gaebbe3f5282db32af8292500e505e21e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian unit of angle.  <a href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">More...</a><br /></td></tr>
<tr class="separator:gaebbe3f5282db32af8292500e505e21e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga446e46852ff69dee446aadc44635865c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a> = <a class="el" href="group__PhysicalQuantities.html#ga8b4603a98e526262c2e4adfe99510672">AngularVelocity</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a4b05a88d44049ecb87ed2945a30b78f4">detail::radian_per_second</a>)</td></tr>
<tr class="memdesc:ga446e46852ff69dee446aadc44635865c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian per second unit of angular velocity.  <a href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">More...</a><br /></td></tr>
<tr class="separator:ga446e46852ff69dee446aadc44635865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da7c45fe3ebc86d397e684154033742"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga0da7c45fe3ebc86d397e684154033742">RadianPerSquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> / (<a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a>)</td></tr>
<tr class="memdesc:ga0da7c45fe3ebc86d397e684154033742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radian per square second unit of angular acceleration.  <a href="group__PhysicalUnits.html#ga0da7c45fe3ebc86d397e684154033742">More...</a><br /></td></tr>
<tr class="separator:ga0da7c45fe3ebc86d397e684154033742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46b97afc56560699033e7c3fb480a4f7"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga46b97afc56560699033e7c3fb480a4f7">RevolutionsPerMinute</a> = 2 * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> / (<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{<a class="el" href="namespaceplayrho_1_1detail.html#ada8f7d778a105c363715baf196d71bfd">detail::SecondsPerMinute</a>} * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a>)</td></tr>
<tr class="memdesc:ga46b97afc56560699033e7c3fb480a4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revolutions per minute units of angular velocity.  <a href="group__PhysicalUnits.html#ga46b97afc56560699033e7c3fb480a4f7">More...</a><br /></td></tr>
<tr class="separator:ga46b97afc56560699033e7c3fb480a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dacec03532687e9bac4ac6a882b35ad"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> = <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a7e50c73b42174eea9c09e8fec3805919">detail::second</a>)</td></tr>
<tr class="memdesc:ga6dacec03532687e9bac4ac6a882b35ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second unit of time.  <a href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">More...</a><br /></td></tr>
<tr class="separator:ga6dacec03532687e9bac4ac6a882b35ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb0acbda4409a1a132baf7df83b9870"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga1fb0acbda4409a1a132baf7df83b9870">SquareMeter</a> = <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a>(<a class="el" href="namespaceplayrho_1_1detail.html#a8098710bf36c4d3d9fc8f47614f3238a">detail::square_meter</a>)</td></tr>
<tr class="memdesc:ga1fb0acbda4409a1a132baf7df83b9870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square meter unit of area.  <a href="group__PhysicalUnits.html#ga1fb0acbda4409a1a132baf7df83b9870">More...</a><br /></td></tr>
<tr class="separator:ga1fb0acbda4409a1a132baf7df83b9870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941b3913fd0dd86a33e695cd9b73318f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga941b3913fd0dd86a33e695cd9b73318f">SquareRadian</a> = <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a> * <a class="el" href="group__PhysicalUnits.html#gaebbe3f5282db32af8292500e505e21e5">Radian</a></td></tr>
<tr class="memdesc:ga941b3913fd0dd86a33e695cd9b73318f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square radian unit type.  <a href="group__PhysicalUnits.html#ga941b3913fd0dd86a33e695cd9b73318f">More...</a><br /></td></tr>
<tr class="separator:ga941b3913fd0dd86a33e695cd9b73318f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1bd392cbafcb91d60633c893ff0742"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplayrho.html#aae1bd392cbafcb91d60633c893ff0742">SquareRootTwo</a></td></tr>
<tr class="memdesc:aae1bd392cbafcb91d60633c893ff0742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of two.  <a href="namespaceplayrho.html#aae1bd392cbafcb91d60633c893ff0742">More...</a><br /></td></tr>
<tr class="separator:aae1bd392cbafcb91d60633c893ff0742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64467fca61de8c359a4e019f977ff320"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PhysicalUnits.html#ga64467fca61de8c359a4e019f977ff320">SquareSecond</a> = <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a> * <a class="el" href="group__PhysicalUnits.html#ga6dacec03532687e9bac4ac6a882b35ad">Second</a></td></tr>
<tr class="memdesc:ga64467fca61de8c359a4e019f977ff320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square second unit.  <a href="group__PhysicalUnits.html#ga64467fca61de8c359a4e019f977ff320">More...</a><br /></td></tr>
<tr class="separator:ga64467fca61de8c359a4e019f977ff320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30f732f080ece0b4e695da15e9da2a4"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#gaf30f732f080ece0b4e695da15e9da2a4">Tera</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e12)</td></tr>
<tr class="memdesc:gaf30f732f080ece0b4e695da15e9da2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tera- (1 x 10^12).  <a href="group__DecimalUnitPrefices.html#gaf30f732f080ece0b4e695da15e9da2a4">More...</a><br /></td></tr>
<tr class="separator:gaf30f732f080ece0b4e695da15e9da2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57179cfbd588c3d24609ad449a94bb0a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DecimalUnitPrefices.html#ga57179cfbd588c3d24609ad449a94bb0a">Yotta</a> = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1e24)</td></tr>
<tr class="memdesc:ga57179cfbd588c3d24609ad449a94bb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yotta- (1 x 10^24).  <a href="group__DecimalUnitPrefices.html#ga57179cfbd588c3d24609ad449a94bb0a">More...</a><br /></td></tr>
<tr class="separator:ga57179cfbd588c3d24609ad449a94bb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Name space for all PlayRho related names. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a261b3039a098762462a17164898bb647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261b3039a098762462a17164898bb647">&#9670;&nbsp;</a></span>BodyCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a261b3039a098762462a17164898bb647">playrho::BodyCounter</a> = typedef std::remove_const_t&lt;decltype(<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count type for bodies. </p>
<dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxBodies</code> value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a1">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a25">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0e937a573db2db27b95156590ef5dd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e937a573db2db27b95156590ef5dd12">&#9670;&nbsp;</a></span>ChildCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a0e937a573db2db27b95156590ef5dd12">playrho::ChildCounter</a> = typedef std::remove_const_t&lt;decltype(<a class="el" href="namespaceplayrho.html#af33623a59b7c701aead6d06e88dc2cc6">MaxChildCount</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Child counter type. </p>
<p>Relating to "children" of shape where each child is a convex shape possibly comprising a concave shape. </p><dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxChildCount</code> value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Compositor_8cpp-example.html#a1">Compositor.cpp</a>, <a class="el" href="Shape_8cpp-example.html#a9">Shape.cpp</a>, <a class="el" href="World_8cpp-example.html#a21">World.cpp</a>, <a class="el" href="WorldContact_8cpp-example.html#a45">WorldContact.cpp</a>, and <a class="el" href="WorldShape_8cpp-example.html#a37">WorldShape.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5fd824505590e2ca67e0ef804ede6e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd824505590e2ca67e0ef804ede6e34">&#9670;&nbsp;</a></span>ContactCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">playrho::ContactCounter</a> = typedef <a class="el" href="namespaceplayrho.html#a0d090b6b86609a8e93cb933b2b223e63">WiderType</a>&lt;<a class="el" href="namespaceplayrho.html#a261b3039a098762462a17164898bb647">BodyCounter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count type for contacts. </p>
<dl class="section note"><dt>Note</dt><dd>This type must be able to contain the squared value of <code>BodyCounter</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a3">World.cpp</a>, and <a class="el" href="WorldContact_8cpp-example.html#a8">WorldContact.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad26feaced5599b43b28c4de2a2f861b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26feaced5599b43b28c4de2a2f861b4">&#9670;&nbsp;</a></span>DecayedTypeIfNotSame</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Check , typename DecayedType  = std::decay_t&lt;Type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad26feaced5599b43b28c4de2a2f861b4">playrho::DecayedTypeIfNotSame</a> = typedef std::enable_if_t&lt;!std::is_same_v&lt;DecayedType, Check&gt;, DecayedType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decayed type if not same as the checked type. </p>
<dl class="section note"><dt>Note</dt><dd>This is done separately from other checks to ensure order of compiler's SFINAE processing and to ensure elimination of check class before attempting to process other checks like is_copy_constructible_v. This prevents a compiler error that started showing up in gcc-9. </dd></dl>

</div>
</div>
<a id="a2d09dc7b51321c052b071485357ca1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d09dc7b51321c052b071485357ca1f9">&#9670;&nbsp;</a></span>Force2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2d09dc7b51321c052b071485357ca1f9">playrho::Force2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gad51dd88ec6a5b3bf384dc89a63019d9d">Force</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Force quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional force vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a103">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a72">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a938af6ffa35b77fb176a9533d9b2f902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938af6ffa35b77fb176a9533d9b2f902">&#9670;&nbsp;</a></span>HasNullaryFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Return &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a938af6ffa35b77fb176a9533d9b2f902">playrho::HasNullaryFunctor</a> = typedef <a class="el" href="structplayrho_1_1detail_1_1HasFunctor.html">detail::HasFunctor</a>&lt;Type, Return()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has nullary functor type alias. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a9f7d6112b6c359e797237cf305277451" title="Has unary functor type alias.">HasUnaryFunctor</a>. </dd></dl>

</div>
</div>
<a id="a9f7d6112b6c359e797237cf305277451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7d6112b6c359e797237cf305277451">&#9670;&nbsp;</a></span>HasUnaryFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename Return , typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a9f7d6112b6c359e797237cf305277451">playrho::HasUnaryFunctor</a> = typedef <a class="el" href="structplayrho_1_1detail_1_1HasFunctor.html">detail::HasFunctor</a>&lt;Type, Return(Arg)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Has unary functor type alias. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a938af6ffa35b77fb176a9533d9b2f902" title="Has nullary functor type alias.">HasNullaryFunctor</a>. </dd></dl>

</div>
</div>
<a id="a7d449e0a1528c10ae0f241713fb69b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d449e0a1528c10ae0f241713fb69b40">&#9670;&nbsp;</a></span>IndexPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">playrho::IndexPair</a> = typedef std::pair&lt;<a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a>, <a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">VertexCounter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index pair. </p>
<dl class="section note"><dt>Note</dt><dd>Using <code>std::array</code> would make more sense if it weren't for the fact that <code>std::pair</code>, but not <code>std::array</code>, has <code>constexpr</code> equality and inequality operators. </dd></dl>

</div>
</div>
<a id="a704da3b24d9b1f9135e140dcd5420518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704da3b24d9b1f9135e140dcd5420518">&#9670;&nbsp;</a></span>IndexPair3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">playrho::IndexPair3</a> = typedef std::array&lt;<a class="el" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>, <a class="el" href="namespaceplayrho.html#a95591102a273a4d301f3f795d463b9ba">MaxSimplexEdges</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of three index-pair elements. </p>
<dl class="section note"><dt>Note</dt><dd>An element having the <code>InvalidIndexPair</code> value, denotes an unused or invalid elements. </dd></dl>

</div>
</div>
<a id="a3fff859979ed48e0d223d1584eb985c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fff859979ed48e0d223d1584eb985c3">&#9670;&nbsp;</a></span>JointCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a3fff859979ed48e0d223d1584eb985c3">playrho::JointCounter</a> = typedef std::remove_const_t&lt;decltype(<a class="el" href="namespaceplayrho.html#a69cde8c9e938d138a9a4ae8355501684">MaxJoints</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter type for joints. </p>
<dl class="section note"><dt>Note</dt><dd>This type must be able to contain the <code>MaxJoints</code> value. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a5">World.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7dc68cd0ce177e175ae0bb6c39db158d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc68cd0ce177e175ae0bb6c39db158d">&#9670;&nbsp;</a></span>Length2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">playrho::Length2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Length quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional distance or location vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Body_8cpp-example.html#a23">Body.cpp</a>, <a class="el" href="Compositor_8cpp-example.html#a16">Compositor.cpp</a>, <a class="el" href="DistanceJoint_8cpp-example.html#a2">DistanceJoint.cpp</a>, <a class="el" href="FrictionJoint_8cpp-example.html#a1">FrictionJoint.cpp</a>, <a class="el" href="GearJoint_8cpp-example.html#a10">GearJoint.cpp</a>, <a class="el" href="HelloWorld_8cpp-example.html#a2">HelloWorld.cpp</a>, <a class="el" href="Joint_8cpp-example.html#a26">Joint.cpp</a>, <a class="el" href="MotorJoint_8cpp-example.html#a2">MotorJoint.cpp</a>, <a class="el" href="PrismaticJoint_8cpp-example.html#a1">PrismaticJoint.cpp</a>, <a class="el" href="PulleyJoint_8cpp-example.html#a7">PulleyJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#a1">RevoluteJoint.cpp</a>, <a class="el" href="RopeJoint_8cpp-example.html#a1">RopeJoint.cpp</a>, <a class="el" href="Shape_8cpp-example.html#a12">Shape.cpp</a>, <a class="el" href="TargetJoint_8cpp-example.html#a3">TargetJoint.cpp</a>, <a class="el" href="WeldJoint_8cpp-example.html#a1">WeldJoint.cpp</a>, <a class="el" href="WheelJoint_8cpp-example.html#a1">WheelJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#a22">World.cpp</a>, <a class="el" href="WorldBody_8cpp-example.html#a45">WorldBody.cpp</a>, and <a class="el" href="WorldShape_8cpp-example.html#a25">WorldShape.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5822921028100052d4c6dfb43c7f6c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5822921028100052d4c6dfb43c7f6c4b">&#9670;&nbsp;</a></span>LinearAcceleration2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a5822921028100052d4c6dfb43c7f6c4b">playrho::LinearAcceleration2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gaea2069744ddc1c5068705b00f957451a">LinearAcceleration</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of linear acceleration (<code>LinearAcceleration</code>) quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional linear acceleration vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Body_8cpp-example.html#a29">Body.cpp</a>, <a class="el" href="DistanceJoint_8cpp-example.html#a33">DistanceJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#a65">RevoluteJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#a105">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a62">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a2faa31bff8794a0c4191d8b042f7deeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faa31bff8794a0c4191d8b042f7deeb">&#9670;&nbsp;</a></span>LinearVelocity2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a2faa31bff8794a0c4191d8b042f7deeb">playrho::LinearVelocity2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of linear velocity (<code>LinearVelocity</code>) quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional speed vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Body_8cpp-example.html#a25">Body.cpp</a>, <a class="el" href="World_8cpp-example.html#a138">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a11">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="acbf97bd8e3f0f2ce4588735388f4089a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf97bd8e3f0f2ce4588735388f4089a">&#9670;&nbsp;</a></span>Matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">playrho::Matrix</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;<a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, N&gt;, M&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic M by N matrix. </p>
<dl class="section note"><dt>Note</dt><dd>M is the number of rows of the matrix. </dd>
<dd>
N is the number of columns of the matrix. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">https://en.wikipedia.org/wiki/Matrix_(mathematics)</a> </dd>
<dd>
<a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>, <a class="el" href="group__MatrixTraitsGroup.html" title="Collection of trait classes for matrices.">Matrix Traits</a>, <a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7" title="Determines whether the given type is a Vector type.">IsVectorV</a> </dd></dl>

</div>
</div>
<a id="a1fa6ffb2e67c2e2f620eed088412b146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa6ffb2e67c2e2f620eed088412b146">&#9670;&nbsp;</a></span>Momentum2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a1fa6ffb2e67c2e2f620eed088412b146">playrho::Momentum2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="group__PhysicalQuantities.html#gad36b742307f9f19c2c8c95e9372a3613">Momentum</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2-element vector of Momentum quantities. </p>
<dl class="section note"><dt>Note</dt><dd>Often used as a 2-dimensional momentum vector. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DistanceJoint_8cpp-example.html#a15">DistanceJoint.cpp</a>, <a class="el" href="FrictionJoint_8cpp-example.html#a3">FrictionJoint.cpp</a>, <a class="el" href="GearJoint_8cpp-example.html#a17">GearJoint.cpp</a>, <a class="el" href="Joint_8cpp-example.html#a13">Joint.cpp</a>, <a class="el" href="MotorJoint_8cpp-example.html#a15">MotorJoint.cpp</a>, <a class="el" href="PrismaticJoint_8cpp-example.html#a7">PrismaticJoint.cpp</a>, <a class="el" href="PulleyJoint_8cpp-example.html#a16">PulleyJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#a16">RevoluteJoint.cpp</a>, <a class="el" href="RopeJoint_8cpp-example.html#a8">RopeJoint.cpp</a>, <a class="el" href="TargetJoint_8cpp-example.html#a10">TargetJoint.cpp</a>, <a class="el" href="WeldJoint_8cpp-example.html#a9">WeldJoint.cpp</a>, <a class="el" href="WheelJoint_8cpp-example.html#a12">WheelJoint.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a81">WorldBody.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae444a62491fcb2b10f0f06a41b1ac406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae444a62491fcb2b10f0f06a41b1ac406">&#9670;&nbsp;</a></span>PairLength2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ae444a62491fcb2b10f0f06a41b1ac406">playrho::PairLength2</a> = typedef std::pair&lt;<a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>, <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pair of <code>Length2</code> values. </p>
<dl class="section note"><dt>Note</dt><dd>Uses <code>std::pair</code> because this is a pair and also because <code>std::pair</code> has more support for constant expressions. </dd></dl>

</div>
</div>
<a id="a1fc125070a08100d083a1360f7167f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc125070a08100d083a1360f7167f87">&#9670;&nbsp;</a></span>Real</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">playrho::Real</a> = typedef float</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real-number type. </p>
<p>This is the number type underlying numerical calculations conceptually involving real-numbers. Ideally the implementation of this type doesn't suffer from things like: catastrophic cancellation, catastrophic division, overflows, nor underflows.</p>
<dl class="section note"><dt>Note</dt><dd>This can be implemented using any of the fundamental floating point types (<code>float</code>, <code>double</code>, or <code>long double</code>). </dd>
<dd>
This can also be implemented using a <code>LiteralType</code> that has necessary support: all common mathematical functions, support for infinity and NaN, and a specialization of the <code>std::numeric_limits</code> class template for it.</dd>
<dd>
Regarding division:<ul>
<li>While dividing 1 by a real, caching the result, and then doing multiplications with the result may well be faster (than repeatedly dividing), dividing 1 by the real can also result in an underflow situation that's then compounded every time it's multiplied with other values.</li>
<li>Meanwhile, dividing every time by a real isolates any underflows to the particular division where underflow occurs.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The note regarding division applies even more so when using a fixed-point type (for <code>Real</code>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a> </dd>
<dd>
<a href="https://en.cppreference.com/w/cpp/types/is_floating_point">https://en.cppreference.com/w/cpp/types/is_floating_point</a> </dd>
<dd>
<a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">https://en.cppreference.com/w/cpp/named_req/LiteralType</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Body_8cpp-example.html#a0">Body.cpp</a>, <a class="el" href="Compositor_8cpp-example.html#a0">Compositor.cpp</a>, <a class="el" href="DistanceJoint_8cpp-example.html#a0">DistanceJoint.cpp</a>, <a class="el" href="FrictionJoint_8cpp-example.html#a26">FrictionJoint.cpp</a>, <a class="el" href="GearJoint_8cpp-example.html#a1">GearJoint.cpp</a>, <a class="el" href="MotorJoint_8cpp-example.html#a0">MotorJoint.cpp</a>, <a class="el" href="PrismaticJoint_8cpp-example.html#a48">PrismaticJoint.cpp</a>, <a class="el" href="PulleyJoint_8cpp-example.html#a5">PulleyJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#a9">RevoluteJoint.cpp</a>, <a class="el" href="RopeJoint_8cpp-example.html#a34">RopeJoint.cpp</a>, <a class="el" href="Shape_8cpp-example.html#a4">Shape.cpp</a>, <a class="el" href="TargetJoint_8cpp-example.html#a5">TargetJoint.cpp</a>, <a class="el" href="WeldJoint_8cpp-example.html#a2">WeldJoint.cpp</a>, <a class="el" href="WheelJoint_8cpp-example.html#a29">WheelJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#a9">World.cpp</a>, <a class="el" href="WorldBody_8cpp-example.html#a13">WorldBody.cpp</a>, <a class="el" href="WorldContact_8cpp-example.html#a15">WorldContact.cpp</a>, and <a class="el" href="WorldShape_8cpp-example.html#a9">WorldShape.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a238bb543bc4c65753c931c94c8bd70cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238bb543bc4c65753c931c94c8bd70cf">&#9670;&nbsp;</a></span>ShapeCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a238bb543bc4c65753c931c94c8bd70cf">playrho::ShapeCounter</a> = typedef std::remove_const_t&lt;decltype(<a class="el" href="namespaceplayrho.html#a2e673e5e335bf14ece1382b582f2163b">MaxShapes</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count type for shapes. </p>
<dl class="section note"><dt>Note</dt><dd>This type must always be able to contain the <code>MaxShapes</code> value. </dd></dl>

</div>
</div>
<a id="a3898807006fd29cd5c4fc2e1a9cf5536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3898807006fd29cd5c4fc2e1a9cf5536">&#9670;&nbsp;</a></span>TimestepIters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a3898807006fd29cd5c4fc2e1a9cf5536">playrho::TimestepIters</a> = typedef std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time step iterations type.</p>
<p>A type for counting iterations per time-step. </p>

</div>
</div>
<a id="ad93c0cd83df090aba6593ffac4b628ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93c0cd83df090aba6593ffac4b628ec">&#9670;&nbsp;</a></span>Vec2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">playrho::Vec2</a> = typedef <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2 Real elements. </p>
<dl class="section note"><dt>Note</dt><dd>This data structure is two-times the size of the <code>Real</code> type (or 8 using Real of float). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Compositor_8cpp-example.html#a37">Compositor.cpp</a>, <a class="el" href="Shape_8cpp-example.html#a28">Shape.cpp</a>, <a class="el" href="World_8cpp-example.html#a116">World.cpp</a>, <a class="el" href="WorldBody_8cpp-example.html#a32">WorldBody.cpp</a>, and <a class="el" href="WorldShape_8cpp-example.html#a38">WorldShape.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a97243f194a9406d0fdcf5f6f833851ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97243f194a9406d0fdcf5f6f833851ab">&#9670;&nbsp;</a></span>Vector2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">playrho::Vector2</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 2-elements. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a C++11 alias template for 2-element uses of the <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> template. </dd></dl>

</div>
</div>
<a id="ad07b44f811ac4c7551067fb1d3554ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07b44f811ac4c7551067fb1d3554ec5">&#9670;&nbsp;</a></span>Vector3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">playrho::Vector3</a> = typedef <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> with 3-elements. </p>
<dl class="section note"><dt>Note</dt><dd>This is just a C++11 alias template for 3-element uses of the <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> template. </dd></dl>

</div>
</div>
<a id="a4505f6a4017695c48bd81225eaf9c28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4505f6a4017695c48bd81225eaf9c28a">&#9670;&nbsp;</a></span>VertexCounter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplayrho.html#a4505f6a4017695c48bd81225eaf9c28a">playrho::VertexCounter</a> = typedef std::remove_const_t&lt;decltype(<a class="el" href="namespaceplayrho.html#a0774f630ff2e5b9ed9e5f322700d44e4">MaxShapeVertices</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertex count type. </p>
<dl class="section note"><dt>Note</dt><dd>This type must not support more than 255 vertices as that would conflict with the <code><a class="el" href="structplayrho_1_1ContactFeature.html#ab960333ec02960bebf043a55ef1b6041" title="Index type.">ContactFeature::Index</a></code> type. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a098b0ef528e3b728af8e3e17873963f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098b0ef528e3b728af8e3e17873963f7">&#9670;&nbsp;</a></span>BodyType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">playrho::BodyType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of body. </p>
<dl class="section note"><dt>Note</dt><dd>static: zero mass, zero velocity, may be manually moved. </dd>
<dd>
kinematic: zero mass, non-zero velocity set by user, moved by solver. </dd>
<dd>
dynamic: positive mass, non-zero velocity determined by forces, moved by solver. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893" title="Is &quot;speedable&quot;.">IsSpeedable(BodyType)</a>, <a class="el" href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd" title="Is &quot;accelerable&quot;.">IsAccelerable(BodyType)</a>. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a84a8921b25f505d0d2077aeb5db4bc16"></a>Static&#160;</td><td class="fielddoc"><p>Static body type.</p>
<p>Static bodies have no mass, have no forces applied to them, and aren't moved by physical processes. They are impenetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: none. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a40c78b58b86002ee38fad2d3c9dd787e"></a>Kinematic&#160;</td><td class="fielddoc"><p>Kinematic body type.</p>
<p>Kinematic bodies: have no mass, cannot have forces applied to them, can move at set velocities (they are "speedable"), and are impenetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: velocity. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a098b0ef528e3b728af8e3e17873963f7a971fd8cc345d8bd9f92e9f7d88fdf20c"></a>Dynamic&#160;</td><td class="fielddoc"><p>Dynamic body type.</p>
<p>Dynamic bodies are fully simulated bodies - they are "speedable" and "accelerable". Dynamic bodies always have a positive non-zero mass. They may be penetrable. </p><dl class="section note"><dt>Note</dt><dd>Physics applied: velocity, acceleration. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="a854ac3ed65c77740c30c5d097b11435c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854ac3ed65c77740c30c5d097b11435c">&#9670;&nbsp;</a></span>LimitState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a854ac3ed65c77740c30c5d097b11435c">playrho::LimitState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Limit state. </p>
<dl class="section note"><dt>Note</dt><dd>Only used by joints that implement some notion of a limited range. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a854ac3ed65c77740c30c5d097b11435ca1f7b8a0fe66401e83219c7a6b7271e77"></a>e_inactiveLimit&#160;</td><td class="fielddoc"><p>Inactive limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a854ac3ed65c77740c30c5d097b11435cab5be4dc895bc396de7129733217d2d1d"></a>e_atLowerLimit&#160;</td><td class="fielddoc"><p>At-lower limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a854ac3ed65c77740c30c5d097b11435ca719db30ca9dc11b4ef7229efab6efb59"></a>e_atUpperLimit&#160;</td><td class="fielddoc"><p>At-upper limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a854ac3ed65c77740c30c5d097b11435ca4737f7baf9c11f81fc69998ca490edab"></a>e_equalLimits&#160;</td><td class="fielddoc"><p>Equal limit. </p>
<p>Equal limit is used to indicate that a joint's upper and lower limits are approximately the same. </p>
</td></tr>
</table>

</div>
</div>
<a id="a06f67e158a928ef59e4263facac8fb0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f67e158a928ef59e4263facac8fb0b">&#9670;&nbsp;</a></span>PointState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a06f67e158a928ef59e4263facac8fb0b">playrho::PointState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point state enumeration. </p>
<dl class="section note"><dt>Note</dt><dd>This is used for determining the state of contact points. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0babbb93ef26e3c101ff11cdd21cab08a94"></a>Null&#160;</td><td class="fielddoc"><p>Point does not exist. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0baec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"><p>Point was added in the update. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba5a7dacb6e9b5ba37e22f825429355174"></a>Persist&#160;</td><td class="fielddoc"><p>Point persisted across the update. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06f67e158a928ef59e4263facac8fb0ba1063e38cb53d94d386f21227fcd84717"></a>Remove&#160;</td><td class="fielddoc"><p>Point was removed in the update. </p>
</td></tr>
</table>

</div>
</div>
<a id="a66189f1fe36ac717e284ab1099171106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66189f1fe36ac717e284ab1099171106">&#9670;&nbsp;</a></span>RayCastOpcode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplayrho.html#a66189f1fe36ac717e284ab1099171106">playrho::RayCastOpcode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ray cast opcode enumeration. </p>
<p>Instructs some ray casting methods on what to do next. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a056fa3d840f48b7bfbbd68c19a4797b3"></a>Terminate&#160;</td><td class="fielddoc"><p>End the ray-cast search for fixtures. </p>
<p>Use this to stop searching for fixtures. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106aaf8767ee039cdc51717435bb815da593"></a>IgnoreFixture&#160;</td><td class="fielddoc"><p>Ignore the current fixture. </p>
<p>Use this to continue searching for fixtures along the ray. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a8dcfe18b6245b17c9cd69d5af7ef1847"></a>ClipRay&#160;</td><td class="fielddoc"><p>Clip the ray end to the current point. </p>
<p>Use this shorten the ray to the current point and to continue searching for fixtures now along the newly shortened ray. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66189f1fe36ac717e284ab1099171106a4592f28dc9d11de3ce507bebafd9de16"></a>ResetRay&#160;</td><td class="fielddoc"><p>Reset the ray end back to the second point. </p>
<p>Use this to restore the ray to its full length and to continue searching for fixtures now along the restored full length ray. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a516a3bbb73371cdc53f348b67f43bb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516a3bbb73371cdc53f348b67f43bb1f">&#9670;&nbsp;</a></span>Alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * playrho::Alloc </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory. </p>
<dl class="section note"><dt>Note</dt><dd>One can change this function to use ones own memory allocator. Be sure to conform to this function's interface: throw a <code>std::bad_alloc</code> exception if unable to allocate non-zero sized memory and return a null pointer if the requested size is zero. This is done to ensure that the behavior is not implementation defined unlike <code>std::malloc</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to allocate non-zero sized memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if size is not zero else <code>nullptr</code>. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>, <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0" title="Reallocates memory.">Realloc</a>, <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62" title="Reallocates memory for an array.">ReallocArray</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">AllocArray()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#abbb25555e5d25ed67a4748136ff7b8ed">playrho::BlockAllocator::Allocate()</a>, and <a class="el" href="classplayrho_1_1StackAllocator.html#a1ecbcaa8d549ffa1522e7128fc8a684d">playrho::StackAllocator::Allocate()</a>.</p>

</div>
</div>
<a id="a2943dd9a79b7fc1fa196af1208b00388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2943dd9a79b7fc1fa196af1208b00388">&#9670;&nbsp;</a></span>AllocArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* playrho::AllocArray </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for an array. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to allocate non-zero sized memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if size is not zero else <code>nullptr</code>. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>, <a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f" title="Allocates memory.">Alloc</a>, <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62" title="Reallocates memory for an array.">ReallocArray</a>. </dd></dl>

</div>
</div>
<a id="a5ff2551e46a5f342484d8f0ec42c44e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff2551e46a5f342484d8f0ec42c44e3">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Version.html">Version</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison function. </p>
<dl class="section return"><dt>Returns</dt><dd>Less-than zero if left-hand-side argument is less than the right. Greater-than zero if left-hand-side argument is greater than the right. Or zero if both arguments are the same. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a1b902ac6a7cd1b01dc4a4981889d2820">operator!=()</a>, <a class="el" href="namespaceplayrho.html#a9664edec057808e7df69e801e1f9012f">operator&lt;()</a>, <a class="el" href="namespaceplayrho.html#aafdb22d94f848eebd4aff498f3fba0c4">operator&lt;=()</a>, <a class="el" href="namespaceplayrho.html#a1a26000facbed802f63693ad132ea5e4">operator==()</a>, <a class="el" href="namespaceplayrho.html#ab826df98026c84dcfa3cf694d6f8e63e">operator&gt;()</a>, and <a class="el" href="namespaceplayrho.html#a30424693f3f723867383b08f1735bdd3">operator&gt;=()</a>.</p>

</div>
</div>
<a id="aa5b77298f0fc2a2ae88ececbc3fb23d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b77298f0fc2a2ae88ececbc3fb23d1">&#9670;&nbsp;</a></span>EraseAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::EraseAll </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(distance(container.erase(remove(<a class="el" href="namespaceplayrho.html#a429625691c6a45944e55fe50f9a59199">begin</a>(container), <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container), value),
                                         <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container)),
                         <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container)))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template function for erasing specified value from container. </p>
<dl class="section note"><dt>Note</dt><dd>This basically is the C++20 <code>std::erase</code> function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements erased. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ad559996a9d085eb07a18b5b88525761f" title="Convenience template function for erasing first found value from container.">EraseFirst</a>. </dd></dl>

</div>
</div>
<a id="ad559996a9d085eb07a18b5b88525761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad559996a9d085eb07a18b5b88525761f">&#9670;&nbsp;</a></span>EraseFirst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::EraseFirst </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(container.erase(find(<a class="el" href="namespaceplayrho.html#a429625691c6a45944e55fe50f9a59199">begin</a>(container), <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container), value)) != <a class="el" href="namespaceplayrho.html#a370e741c22960aad46732cdc0353f428">end</a>(container))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience template function for erasing first found value from container. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if value was found and erased, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#aa5b77298f0fc2a2ae88ececbc3fb23d1" title="Convenience template function for erasing specified value from container.">EraseAll</a>. </dd></dl>

</div>
</div>
<a id="ac1efaeb0c030854ede6606021ba56d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1efaeb0c030854ede6606021ba56d30">&#9670;&nbsp;</a></span>FlagForFiltering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void FlagForFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags the contact for filtering. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>NeedsFiltering(contact)</code> returns true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a92b68ee2dcf7f21577269938c5267f5f" title="Whether or not the contact needs filtering.">NeedsFiltering(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="ac1ec70ebc79af5b28899b8d0a1341141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ec70ebc79af5b28899b8d0a1341141">&#9670;&nbsp;</a></span>FlagForUpdating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void FlagForUpdating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags the contact for updating. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>NeedsUpdating(contact)</code> returns true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a00846636a226626c5dd4151893f397f7" title="Whether or not the contact needs updating.">NeedsUpdating(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="a62c138018c11ab3c255b410f2dedd7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c138018c11ab3c255b410f2dedd7d2">&#9670;&nbsp;</a></span>Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void playrho::Free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory. </p>
<dl class="section note"><dt>Note</dt><dd>If you change <code>Alloc</code>, consider also changing this function. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f" title="Allocates memory.">Alloc</a>, <a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388" title="Allocates memory for an array.">AllocArray</a>, <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0" title="Reallocates memory.">Realloc</a>, <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62" title="Reallocates memory for an array.">ReallocArray</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#ad81a322bcd52726dba15394783eea8fb">playrho::d2::DynamicTree::~DynamicTree()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a12d8426f4a31b8ed042b2a62699d04e4">playrho::BlockAllocator::Clear()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#ad8b0e591e1c43454b16d924e628cb1e8">playrho::d2::DynamicTree::Clear()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a74aadaded9475221a0ea343bff727df5">playrho::StackAllocator::Free()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a06536ee49cdb1a8c2f79de7522c8bd33">playrho::BlockAllocator::Free()</a>, <a class="el" href="classplayrho_1_1GrowableStack.html#a9a52c69b5e506bef0d458f1631ca3514">playrho::GrowableStack&lt; T, N &gt;::push()</a>, <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">Realloc()</a>, and <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#a47cbaffc41092844c1b4812057e37f13">playrho::d2::DynamicTree::RebuildBottomUp()</a>.</p>

</div>
</div>
<a id="a8abbe9590460876ec82bf7dd801fb1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abbe9590460876ec82bf7dd801fb1f0">&#9670;&nbsp;</a></span>GetCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = decltype(Interval&lt;T&gt;{}, ((T{} + T{}) / 2))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto GetCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the center of the given interval. </p>
<dl class="section warning"><dt>Warning</dt><dd>Behavior is not specified if the difference between the given range's max and min values overflows the range of the <code><a class="el" href="classplayrho_1_1Interval.html#af3f2912d491535ecbe0f8b03da2357b7" title="Value type.">Interval::value_type</a></code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__RayCastGroup.html#gadf0ec62e1852e3bc9b017eae4a5616b4">playrho::d2::RayCast()</a>.</p>

</div>
</div>
<a id="a1e3bad8be42524709861c9e728048ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3bad8be42524709861c9e728048ea2">&#9670;&nbsp;</a></span>GetFriction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto GetFriction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the coefficient of friction. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#acaf284b9eea3b4ad78ba5b673e67b00b" title="Sets the friction value for the identified contact.">SetFriction</a>. </dd></dl>

</div>
</div>
<a id="a25080522fd228616931476a49b5295d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25080522fd228616931476a49b5295d3">&#9670;&nbsp;</a></span>GetFwdPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetFwdPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a vector clockwise (forward-clockwise) perpendicular to the given vector. </p>
<p>This takes a vector of form (x, y) and returns the vector (y, -x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> to return a clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a6526ea72d722d9cccd28199e6e917fb3" title="Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector.">GetRevPerpendicular</a>. </dd></dl>

</div>
</div>
<a id="aff2ccc0dc9ac07175382084cee633e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2ccc0dc9ac07175382084cee633e49">&#9670;&nbsp;</a></span>GetIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;<a class="el" href="namespaceplayrho.html#a14b74d27a9f43c1f37aca5ee84aa6f97">IsSquareMatrixV</a>&lt;T&gt;, T&gt; playrho::GetIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the identity matrix of the template type and size as given by the argument. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Identity_matrix">https://en.wikipedia.org/wiki/Identity_matrix</a> </dd>
<dd>
<a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a" title="Generic M by N matrix.">Matrix</a>, IsMatrix, IsSquareMatrix </dd></dl>

</div>
</div>
<a id="a40b372974bcf478fe0254a0a29a2dd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b372974bcf478fe0254a0a29a2dd14">&#9670;&nbsp;</a></span>GetIdentityMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt;T&gt;, <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt;T, N, N&gt; &gt; playrho::GetIdentityMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the identity matrix of the template type and size. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Identity_matrix">https://en.wikipedia.org/wiki/Identity_matrix</a> </dd>
<dd>
<a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a" title="Generic M by N matrix.">Matrix</a>, IsMatrix, IsSquareMatrix </dd></dl>

</div>
</div>
<a id="a43351fde9d622f4762a47e6618daf2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43351fde9d622f4762a47e6618daf2f7">&#9670;&nbsp;</a></span>GetMovementConf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structplayrho_1_1MovementConf.html">MovementConf</a> playrho::GetMovementConf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1StepConf.html">StepConf</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the movement configuration from the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>The <code>maxTranslation</code> and <code>maxRotation</code> fields of the given value respectively are returned. </dd></dl>

</div>
</div>
<a id="ad136f8db9fd6c0c583c1890b8a3cc504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136f8db9fd6c0c583c1890b8a3cc504">&#9670;&nbsp;</a></span>GetNumValidIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t playrho::GetNumValidIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of valid indices in the given collection of index pairs. </p>
<dl class="section note"><dt>Note</dt><dd>Any element with a value of <code>InvalidIndexPair</code> is interpreted as being invalid in this context. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Value between 0 and 3 inclusive. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a98ab78cb47da6f6d872d617cc66040a6">empty()</a>, and <a class="el" href="namespaceplayrho.html#af33cf35b33c93168aedcbf5a986a3472">size()</a>.</p>

</div>
</div>
<a id="a8623a4509113eb33f84ea8aba436396e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8623a4509113eb33f84ea8aba436396e">&#9670;&nbsp;</a></span>GetRestitution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto GetRestitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the coefficient of restitution. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ae72b11c11801f8189dbd1d61dd917f77" title="Sets the restitution value for the identified contact.">SetRestitution</a>. </dd></dl>

</div>
</div>
<a id="a6526ea72d722d9cccd28199e6e917fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6526ea72d722d9cccd28199e6e917fb3">&#9670;&nbsp;</a></span>GetRevPerpendicular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetRevPerpendicular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a vector counter-clockwise (reverse-clockwise) perpendicular to the given vector. </p>
<p>This takes a vector of form (x, y) and returns the vector (-y, x). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> to return a counter-clockwise perpendicular equivalent for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A counter-clockwise 90-degree rotation of the given vector. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a25080522fd228616931476a49b5295d3" title="Gets a vector clockwise (forward-clockwise) perpendicular to the given vector.">GetFwdPerpendicular</a>. </dd></dl>

</div>
</div>
<a id="a64b898ee30ff659e61f3bfdcc78cc233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b898ee30ff659e61f3bfdcc78cc233">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = decltype(Interval&lt;T&gt;{}, (T{} - T{}))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the given interval. </p>
<p>Gets the difference between the max and min values. </p><dl class="section pre"><dt>Precondition</dt><dd>The difference between the given interval's max and min is representable by <code><a class="el" href="classplayrho_1_1Interval.html#af3f2912d491535ecbe0f8b03da2357b7" title="Value type.">Interval::value_type</a></code>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative value unless the given interval is "unset" or invalid. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1detail_1_1AABB.html#a3f0de4fdd4cecf5567090bf345c42ead">playrho::detail::AABB&lt; N &gt;::GetDimensions()</a>, and <a class="el" href="structplayrho_1_1detail_1_1AABB.html#a8f7f7fdc94ace092c3c65acbe6522752">playrho::detail::AABB&lt; N &gt;::GetPerimeter()</a>.</p>

</div>
</div>
<a id="a568a3fc3585eb44878213a919420f847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568a3fc3585eb44878213a919420f847">&#9670;&nbsp;</a></span>GetTangentSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto GetTangentSpeed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the desired tangent speed. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a16493a4bdae1683c07b4b116516716f0" title="Sets the desired tangent speed for a conveyor belt behavior.">SetTangentSpeed</a>. </dd></dl>

</div>
</div>
<a id="acd05d6b92912a6430c09ad8a74bcbc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd05d6b92912a6430c09ad8a74bcbc73">&#9670;&nbsp;</a></span>GetToi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto GetToi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the time of impact (TOI) as a fraction. </p>
<dl class="section return"><dt>Returns</dt><dd>Time of impact fraction in the range of 0 to 1 if set (where 1 means no actual impact in current time slot), otherwise empty. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a77e830664360ead07ab616d934ff2550" title="Gets whether a TOI is set.">HasValidToi</a>, <a class="el" href="namespaceplayrho.html#af93e3743c48882f44ef7936cbad68ae1" title="Sets the time of impact (TOI).">SetToi(Contact&amp;, const std::optional&lt;UnitIntervalFF&lt;Real&gt;&gt;&amp;)</a>. </dd></dl>

</div>
</div>
<a id="abce1723933df3c7d4054975daa7ac724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce1723933df3c7d4054975daa7ac724">&#9670;&nbsp;</a></span>GetToiCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto GetToiCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the time of impact count. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#aabf79c789863cc4aea6b9e6bc976267c" title="Sets the TOI count to the given value.">SetToiCount</a>. </dd></dl>

</div>
</div>
<a id="a77e830664360ead07ab616d934ff2550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e830664360ead07ab616d934ff2550">&#9670;&nbsp;</a></span>HasValidToi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto HasValidToi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether a TOI is set. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#acd05d6b92912a6430c09ad8a74bcbc73" title="Gets the time of impact (TOI) as a fraction.">GetToi</a>. </dd></dl>

</div>
</div>
<a id="a6514752c0838613cfaf76ea7e03581cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6514752c0838613cfaf76ea7e03581cd">&#9670;&nbsp;</a></span>IsAccelerable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool playrho::IsAccelerable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is "accelerable". </p>
<p>Whether or not the given type value is for a body which can have a non-zero acceleration associated with it. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given type value represents an "accelerable" type value, <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Would be nice if the Doxygen "relatedalso BodyType" command worked for this but seems that doesn't work for scoped enumeration. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a76e2dcc5aeb221351e51ad965e9de893" title="Is &quot;speedable&quot;.">IsSpeedable(BodyType)</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Body.html#abb921582a11b07be4c8ac81c43787176">playrho::d2::Body::SetAcceleration()</a>.</p>

</div>
</div>
<a id="aa8f91c8a02e1886e4e9f90d0926e075a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f91c8a02e1886e4e9f90d0926e075a">&#9670;&nbsp;</a></span>IsFor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool IsFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a>&#160;</td>
          <td class="paramname"><em>bodyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a>&#160;</td>
          <td class="paramname"><em>shapeID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is-for convenience function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if contact is for the identified body and shape, else false. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1Contact.html#aa8f91c8a02e1886e4e9f90d0926e075a">playrho::Contact::IsFor()</a>.</p>

</div>
</div>
<a id="a283c9f04ceb148910537dc1cd3f37c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283c9f04ceb148910537dc1cd3f37c00">&#9670;&nbsp;</a></span>IsFor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool IsFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a>&#160;</td>
          <td class="paramname"><em>shapeID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is-for convenience function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if contact is for the identified shape, else false. </dd></dl>

</div>
</div>
<a id="a078999e2c900ac9ee1b081be6934d5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078999e2c900ac9ee1b081be6934d5b7">&#9670;&nbsp;</a></span>IsFor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::IsFor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Contactable.html">Contactable</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a>&#160;</td>
          <td class="paramname"><em>bodyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a664fbedb33a4af92883576fbee62fd28">ShapeID</a>&#160;</td>
          <td class="paramname"><em>shapeID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is-for convenience function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if contactable is for the identified body and shape, else false. </dd></dl>

</div>
</div>
<a id="a885fded7567b0972b4af486e5df9afea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885fded7567b0972b4af486e5df9afea">&#9670;&nbsp;</a></span>IsImpenetrable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool IsImpenetrable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the given contact is "impenetrable". </p>
<dl class="section note"><dt>Note</dt><dd>This should be true whenever body A or body B are impenetrable. </dd></dl>

</div>
</div>
<a id="ab9dc0da0330f8a1c23b44b919f02fed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dc0da0330f8a1c23b44b919f02fed7">&#9670;&nbsp;</a></span>IsIntersecting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = decltype(Interval&lt;T&gt;{}, T{} &lt; T{}, T{} &gt;= T{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool IsIntersecting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether two value ranges have any intersection/overlap at all. </p>
<dl class="section note"><dt>Note</dt><dd><code>a</code> intersects with <code>b</code> if and only if any value of <code>a</code> is also a value of <code>b</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1detail_1_1AABB.html#a9ad73cec0b99cb943f354a290c7f9bfc">playrho::detail::AABB&lt; N &gt;::TestOverlap()</a>.</p>

</div>
</div>
<a id="a76e2dcc5aeb221351e51ad965e9de893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e2dcc5aeb221351e51ad965e9de893">&#9670;&nbsp;</a></span>IsSpeedable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool playrho::IsSpeedable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a098b0ef528e3b728af8e3e17873963f7">BodyType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is "speedable". </p>
<p>Whether or not the given type value is for a body which can have a non-zero speed associated with it. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given type value represents a "speedable" type value, <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Would be nice if the Doxygen "relatedalso BodyType" command worked for this but seems that doesn't work for scoped enumeration. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a6514752c0838613cfaf76ea7e03581cd" title="Is &quot;accelerable&quot;.">IsAccelerable(BodyType)</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Body.html#a70e7705910ea350a7721bf5477e1f391">playrho::d2::Body::JustSetVelocity()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#a794c4c1b8c24aedb959c5031a5ecde69">playrho::d2::Body::SetAwake()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#a96bfa8ab63b3246ed714573661ea3618">playrho::d2::Body::SetSleepingAllowed()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#a32b0b95d49a70472d8667fc97959151c">playrho::d2::Body::SetVelocity()</a>, and <a class="el" href="classplayrho_1_1d2_1_1Body.html#a7821d9464b36b49ddb893ef9c2c262fb">playrho::d2::Body::UnsetAwake()</a>.</p>

</div>
</div>
<a id="ab7404128f6225cf6915219bb784c7843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7404128f6225cf6915219bb784c7843">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92" title="Strongly typed identifier for bodies within World instances.">BodyID</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#abebb8afee132b1f990d43a9a223fd5ed">playrho::d2::VelocityConstraint::VelocityConstraint()</a>, <a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html#a44cc65808fd89570707b3af1bc87eb36">playrho::d2::DistanceProxy::ComputeAABB()</a>, <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#a63c3c99d25c6e735174cb9ddeec58c4a">playrho::d2::DynamicTree::CreateLeaf()</a>, <a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::DistanceProxy::Distance()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#ae1cb8e651628460be908ba768c7d3883">playrho::d2::WorldManifold::GetPointCount()</a>, <a class="el" href="structplayrho_1_1d2_1_1Position.html#a30e3652aa86130f81c948112cf4538d6">playrho::d2::Position::GetPosition()</a>, <a class="el" href="structplayrho_1_1ToiOutput.html#a19b308c9b3b8f5292b9f3dad183c9d76">playrho::ToiOutput::GetToiViaSat()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a1c8db589cd3a6e20401aeeecb6cccf66">playrho::d2::GetTransformation()</a>, <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a1bc16ad22662f69d6218f879a5c17245">playrho::d2::TargetJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1Acceleration.html#a81b1dd82c9c8f3ec7c80b0c53e818239">playrho::d2::Acceleration::IsValid()</a>, <a class="el" href="structplayrho_1_1d2_1_1Position.html#ae5cbbddc6b8f2b557ba2e87f43c64802">playrho::d2::Position::IsValid()</a>, <a class="el" href="structplayrho_1_1d2_1_1Sweep.html#afce9c1dea61c4ba26d5785f2f20c3bff">playrho::d2::Sweep::IsValid()</a>, <a class="el" href="structplayrho_1_1d2_1_1Transformation.html#af76924a9aee97c42840a3867b3cb612c">playrho::d2::Transformation::IsValid()</a>, <a class="el" href="namespaceplayrho.html#a5351f2762c5c98b723679795e0a79287">IsValid()</a>, <a class="el" href="structplayrho_1_1d2_1_1Velocity.html#a1735a28e0a25cc77e59fafe1d840c242">playrho::d2::Velocity::IsValid()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#abb921582a11b07be4c8ac81c43787176">playrho::d2::Body::SetAcceleration()</a>, <a class="el" href="classplayrho_1_1d2_1_1BodyConstraint.html#a029a000b5ed14578c451483630beb487">playrho::d2::BodyConstraint::SetPosition()</a>, <a class="el" href="classplayrho_1_1d2_1_1BodyConstraint.html#a50a8d3716f6263cdfa096eb357e2d7c9">playrho::d2::BodyConstraint::SetVelocity()</a>, <a class="el" href="ContactSolver_8hpp.html#a0fd21d441a78194f210e9f900bd3d1a4">playrho::GaussSeidel::SolvePositionConstraint()</a>, and <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a87f0cb382d657fcac4402b3896269fe3">playrho::d2::TargetJointConf::SolveVelocity()</a>.</p>

</div>
</div>
<a id="a0fa02e6b0d55e9363ad4afb89a755fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa02e6b0d55e9363ad4afb89a755fc1">&#9670;&nbsp;</a></span>IsValid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool playrho::IsValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given value is valid. </p>
<p>Determines whether the given vector contains finite coordinates. </p>

</div>
</div>
<a id="aee56c4a29a6dd23450e8be8027929f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee56c4a29a6dd23450e8be8027929f6c">&#9670;&nbsp;</a></span>MakeUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MakeUnsigned </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> -&gt; std::enable_if_t&lt;std::is_signed_v&lt;T&gt;, std::make_unsigned_t&lt;T&gt;&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the given <b>value</b> into an <b>unsigned value</b>. </p>
<dl class="section note"><dt>Note</dt><dd>If the given value is negative, this will result in an unsigned value which is the two's complement modulo-wrapped value. </dd>
<dd>
This is different from <code>std::make_unsigned</code> in that this changes the <b>value</b> to the value in the type that's the unsigned type equivalent of the input value. <code>std::make_unsigned</code> merely provides the unsigned <b>type</b> equivalent. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1Island.html#a3063d5a0619a13b6a4e9c7dd682d2b8c">playrho::Island::Count()</a>.</p>

</div>
</div>
<a id="ac32367e964a575ebee3ed45c8ddb0afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32367e964a575ebee3ed45c8ddb0afe">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::max_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> -&gt; decltype(pairs.max_size())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum size of the given container of index pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>Always returns 3. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__RayCastGroup.html#ga425e9dc1c0e263bf7484ef6ef2cde86b">playrho::d2::RayCast()</a>.</p>

</div>
</div>
<a id="a2fce5cef2c9f11a5e880c1f6b54bb80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fce5cef2c9f11a5e880c1f6b54bb80f">&#9670;&nbsp;</a></span>MixFriction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::MixFriction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;&#160;</td>
          <td class="paramname"><em>friction1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;&#160;</td>
          <td class="paramname"><em>friction2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mixes friction. </p>
<p>Friction mixing formula. The idea is to allow either value to drive the resulting friction to zero. For example, anything slides on ice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">friction1</td><td>A zero or greater value. </td></tr>
    <tr><td class="paramname">friction2</td><td>A zero or greater value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mixed friction result. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Shape.html#ae22ed2de98d0e1d8a06ec370159038ef">playrho::d2::Shape::GetDefaultFriction()</a>.</p>

</div>
</div>
<a id="af99b1684f31a12e9151c9abeafdc74fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99b1684f31a12e9151c9abeafdc74fe">&#9670;&nbsp;</a></span>MixRestitution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::MixRestitution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>restitution1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>restitution2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mixes restitution. </p>
<p>Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface. For example, a super ball bounces on anything. </p><dl class="section return"><dt>Returns</dt><dd>Mixed restitution result. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Shape.html#a5c54c5f7b57db25cefecbcef1fcf1452">playrho::d2::Shape::GetDefaultRestitution()</a>.</p>

</div>
</div>
<a id="a861fb100d29d58d6f26f3767017886b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861fb100d29d58d6f26f3767017886b3">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<dl class="section note"><dt>Note</dt><dd>Satisfies the <code>EqualityComparable</code> named requirement for <a class="el" href="classplayrho_1_1Interval.html" title="Interval template type.">Interval</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">https://en.cppreference.com/w/cpp/named_req/EqualityComparable</a> </dd></dl>

</div>
</div>
<a id="a2722bc95da32ec0b7f65c9dff9aa0dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2722bc95da32ec0b7f65c9dff9aa0dcc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt; &amp;&amp;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T1 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for non-vector times vector. </p>
<dl class="section note"><dt>Note</dt><dd>Explicitly disabled for <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> * <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> to prevent this function from existing in that case and prevent errors like "use of overloaded operator '*' is ambiguous". </dd></dl>

</div>
</div>
<a id="a225cd9989faf6ae44c6bf24f84c2edf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225cd9989faf6ae44c6bf24f84c2edf7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;<a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt;T1, T2&gt; &amp;&amp; !<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt;T1&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;OT, B&gt; &gt; playrho::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, B &gt;, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies an A-element vector by a A-by-B vector of vectors. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm favors column major ordering of the vector of vectors. </dd>
<dd>
This treats the left-hand-side argument as though it's a 1-by-A vector of vectors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side vector treated as if it were of type: <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>&lt;Vector&lt;T1, A&gt;, 1&gt;</code>. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side vector of vectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B-element vector product. </dd></dl>

</div>
</div>
<a id="a17bf68739331457fd06d2ac83a971ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bf68739331457fd06d2ac83a971ce7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T1 , typename T2 , typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt; &amp;&amp;!<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt; T2 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, N &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator for vector times non-vector. </p>
<dl class="section note"><dt>Note</dt><dd>Explicitly disabled for <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> * <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> to prevent this function from existing in that case and prevent errors like "use of overloaded operator '*' is ambiguous". </dd></dl>

</div>
</div>
<a id="a32931066a82b41864b61d9c0389d6712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32931066a82b41864b61d9c0389d6712">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;<a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt;T1, T2&gt; &amp;&amp; !<a class="el" href="namespaceplayrho.html#a168449a74e78ad00c9d22f1017de05f7">IsVectorV</a>&lt;T2&gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt;OT, B&gt; &gt; playrho::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, A &gt;, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a B-by-A vector of vectors by an A-element vector. </p>
<dl class="section note"><dt>Note</dt><dd>This algorithm favors row major ordering of the vector of vectors. </dd>
<dd>
This treats the right-hand-side argument as though it's an A-by-1 vector of vectors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side vector of vectors. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side vector treated as if it were of type: <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a>&lt;Vector&lt;T2, 1&gt;, A&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B-element vector product. </dd></dl>

</div>
</div>
<a id="a53d7a33cd41bce2acd1d6b8292487981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d7a33cd41bce2acd1d6b8292487981">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , std::size_t A, std::size_t B, std::size_t C, typename OT  = decltype(T1{} * T2{})&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt; <a class="el" href="namespaceplayrho.html#a3c2c0d8136a2aabd56742fbedf6c00ad">IsMultipliableV</a>&lt; T1, T2 &gt;, <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; OT, C &gt;, A &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, B &gt;, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T2, C &gt;, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the matrix product of the two given vector of vectors (matrices). </p>
<p>Multiplies an A-by-B vector of vectors by a B-by-C vector of vectors returning an A-by-C vector of vectors. </p><dl class="section note"><dt>Note</dt><dd>From Wikipedia: <blockquote class="doxtable">
<p>Multiplication of two matrices is defined if and only if the number of columns of the left matrix is the same as the number of rows of the right matrix. </p>
</blockquote>
</dd>
<dd>
Matrix multiplication is not commutative. </dd>
<dd>
Algorithmically speaking, this implementation is called the "naive" algorithm. For small matrices, like 3-by-3 or smaller matrices, its complexity shouldn't be an issue. The matrix dimensions are compile time constants anyway which can help compilers automatically identify loop unrolling and hardware level parallelism opportunities. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand-side matrix. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand-side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A-by-C matrix product of the left-hand-side matrix and the right-hand-side matrix. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_multiplication">https://en.wikipedia.org/wiki/Matrix_multiplication</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm">https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm</a> </dd>
<dd>
<a href="https://en.wikipedia.org/wiki/Commutative_property">https://en.wikipedia.org/wiki/Commutative_property</a> </dd></dl>

</div>
</div>
<a id="a04db47926693f7d605331b5035d4c9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04db47926693f7d605331b5035d4c9c5">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classplayrho_1_1ArrayList.html">ArrayList</a>&lt; T, S &gt;::data_type &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="classplayrho_1_1ArrayList.html" title="Array list.">ArrayList</a></code> add operator. </p>
<p>Appends the right-hand-side value to the left-hand-side instance's values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left hand side instance. </td></tr>
    <tr><td class="paramname">rhs</td><td>Right hand side value to append with <code>lhs</code> into the returned result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An instance with all of <code>lhs</code> values follwed by the <code>rhs</code> value. </dd></dl>

</div>
</div>
<a id="a41f0c49a750ed51bb02cef10158e8d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f0c49a750ed51bb02cef10158e8d7f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix addition operator for two same-type, same-sized matrices. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_addition">https://en.wikipedia.org/wiki/Matrix_addition</a> </dd></dl>

</div>
</div>
<a id="a89118d71eeeffa541c76f6d566a8546d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89118d71eeeffa541c76f6d566a8546d">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix subtraction operator for two same-type, same-sized matrices. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Matrix_addition">https://en.wikipedia.org/wiki/Matrix_addition</a> </dd></dl>

</div>
</div>
<a id="a815e65e38974a8bb60ef0a096bea0241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815e65e38974a8bb60ef0a096bea0241">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison. </dd>
<dd>
Obeys the <code>LessThanComparable</code> named requirement: <code>for all a, !(a &lt; a); if (a &lt; b) then !(b &lt; a); if (a &lt; b) and (b &lt; c) then (a &lt; c); with equiv = !(a &lt; b) &amp;&amp; !(b &lt; a), if equiv(a, b) and equiv(b, c), then equiv(a, c).</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd>
<dd>
<a href="https://en.cppreference.com/w/cpp/named_req/LessThanComparable">https://en.cppreference.com/w/cpp/named_req/LessThanComparable</a> </dd></dl>

</div>
</div>
<a id="a4eaedfa824fd2df1b6450a875b144ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eaedfa824fd2df1b6450a875b144ed0">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N0, class T0 , std::size_t N1, class T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T0, N0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less than operator. </p>
<dl class="section note"><dt>Note</dt><dd>Among other things, this also makes the <a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> class usable with <code>std::set</code>. </dd></dl>

</div>
</div>
<a id="adbf50e7e086182f69dc09e011aef6345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf50e7e086182f69dc09e011aef6345">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-than or equal-to operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="ac1b97d7e2f5894048236948061068fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b97d7e2f5894048236948061068fb5">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<dl class="section note"><dt>Note</dt><dd>Satisfies the <code>EqualityComparable</code> named requirement for <a class="el" href="classplayrho_1_1Interval.html" title="Interval template type.">Interval</a> objects.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/named_req/EqualityComparable">https://en.cppreference.com/w/cpp/named_req/EqualityComparable</a> </dd></dl>

</div>
</div>
<a id="acc58a55aab3f8bdd7ea411a6b2a4ddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc58a55aab3f8bdd7ea411a6b2a4ddfb">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="acca7f35c089808652f6c5d6c06a85ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca7f35c089808652f6c5d6c06a85ae7">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Interval.html">Interval</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-than or equal-to operator. </p>
<dl class="section note"><dt>Note</dt><dd>Provides a "strict weak ordering" relation. </dd>
<dd>
This is a lexicographical comparison.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> </dd></dl>

</div>
</div>
<a id="adb651f620aefb4ee65ec0cc8c10b27b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb651f620aefb4ee65ec0cc8c10b27b0">&#9670;&nbsp;</a></span>Realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * playrho::Realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates memory. </p>
<dl class="section note"><dt>Note</dt><dd>One can change this function to use ones own memory allocator. Be sure to conform to this function's interface: throw a <code>std::bad_alloc</code> exception if unable to allocate non-zero sized memory, return a null pointer if the requested size is zero, and free old memory if the new size is zero. This is done to ensure that the behavior is not implementation defined unlike <code>std::realloc</code>. </dd>
<dd>
If the new size for memory is zero, then the old memory is freed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to reallocate non-zero sized memory. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if size is not zero else <code>nullptr</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f" title="Allocates memory.">Alloc</a>, <a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho.html#a197482cbffdd702c8926a00f42a76e62">ReallocArray()</a>.</p>

</div>
</div>
<a id="a197482cbffdd702c8926a00f42a76e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197482cbffdd702c8926a00f42a76e62">&#9670;&nbsp;</a></span>ReallocArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* playrho::ReallocArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocates memory for an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the old memory. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements to reallocate for. This value must be less than the value of <code>std::numeric_limits&lt;std::size_t&gt;::max() / sizeof(T)</code> or an exception will be thrown. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the new size for memory is zero, then the old memory is freed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If unable to reallocate non-zero sized memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-null pointer if count is not zero else <code>nullptr</code>. Pointer must be deallocated with <code><a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free(void*)</a></code> or one of the <code>Realloc</code> functions. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0" title="Reallocates memory.">Realloc</a>, <a class="el" href="namespaceplayrho.html#a62c138018c11ab3c255b410f2dedd7d2" title="Frees memory.">Free</a>. </dd></dl>

</div>
</div>
<a id="a1de374e7d6af7b68b654b657d756468a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de374e7d6af7b68b654b657d756468a">&#9670;&nbsp;</a></span>Reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespaceplayrho.html#adaec996c65bbbcac537113d83ee753c5">IsReverseIterableV</a>&lt;T&gt;, <a class="el" href="structplayrho_1_1ReversionWrapper.html">ReversionWrapper</a>&lt;T&gt; &gt; playrho::Reverse </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a reversed order iterated wrapper. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://stackoverflow.com/a/28139075/7410358">https://stackoverflow.com/a/28139075/7410358</a> </dd></dl>

</div>
</div>
<a id="a23ce44af5f5ba3deb7e1eafe1acf5198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ce44af5f5ba3deb7e1eafe1acf5198">&#9670;&nbsp;</a></span>SetEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables the contact. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsEnabled(contact)</code> returns true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#acf2071b64988e62193b4a2567bdde292" title="Gets whether the given contact is enabled or not.">IsEnabled(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="acaf284b9eea3b4ad78ba5b673e67b00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf284b9eea3b4ad78ba5b673e67b00b">&#9670;&nbsp;</a></span>SetFriction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetFriction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CheckedTypes.html#ga7ab2310a74db36363887ad368d5c3118">NonNegative</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the friction value for the identified contact. </p>
<p>Overrides the default friction mixture. </p><dl class="section note"><dt>Note</dt><dd>This value persists until set or reset. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contact</td><td>The contact whose friction should be set. </td></tr>
    <tr><td class="paramname">value</td><td>Co-efficient of friction value of zero or greater. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>friction</code> must be greater-than or equal-to zero. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>GetFriction(contact)</code> returns the value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a1e3bad8be42524709861c9e728048ea2" title="Gets the coefficient of friction.">GetFriction</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Compositor_8cpp-example.html#a26">Compositor.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a146755eafb1ed7d0ea52af68ea4874cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146755eafb1ed7d0ea52af68ea4874cd">&#9670;&nbsp;</a></span>SetImpenetrable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetImpenetrable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the impenetrability of the given contact. </p>
<dl class="section attention"><dt>Attention</dt><dd>Call this if body A or body B are impenetrable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsImpenetrable(contact)</code> returns true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a885fded7567b0972b4af486e5df9afea" title="Whether the given contact is &quot;impenetrable&quot;.">IsImpenetrable(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="a6dc7dc1c568e7e1cbe70afe67c51b14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc7dc1c568e7e1cbe70afe67c51b14a">&#9670;&nbsp;</a></span>SetIsActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetIsActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the active state of the given contact. </p>
<dl class="section attention"><dt>Attention</dt><dd>Call this if body A or body B are "awake". </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsActive(contact)</code> returns true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ae659e1f443f30d7813853f6763f1f22f" title="Determines whether the given contact is &quot;active&quot;.">IsActive(const Contact &amp;)</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="WorldContact_8cpp-example.html#a23">WorldContact.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ae72b11c11801f8189dbd1d61dd917f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72b11c11801f8189dbd1d61dd917f77">&#9670;&nbsp;</a></span>SetRestitution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetRestitution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the restitution value for the identified contact. </p>
<p>This override the default restitution mixture. </p><dl class="section note"><dt>Note</dt><dd>You can call this in "pre-solve" listeners. </dd>
<dd>
The value persists until you set or reset. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>GetRestitution(contact)</code> returns the value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a8623a4509113eb33f84ea8aba436396e" title="Gets the coefficient of restitution.">GetRestitution</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Compositor_8cpp-example.html#a29">Compositor.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="af8595ac215de486ea15aaa0c9c608b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8595ac215de486ea15aaa0c9c608b3e">&#9670;&nbsp;</a></span>SetSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the sensor state of the given contact. </p>
<dl class="section attention"><dt>Attention</dt><dd>Call this if shape A or shape B is a sensor. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsSensor(contact)</code> returns true. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ab8801b7203d1ab9a06ca349a9d304f3c" title="Gets whether the given contact is for sensors or not.">IsSensor(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="a16493a4bdae1683c07b4b116516716f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16493a4bdae1683c07b4b116516716f0">&#9670;&nbsp;</a></span>SetTangentSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetTangentSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gaf4434fe902be456f845c8e478bd48f97">LinearVelocity</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the desired tangent speed for a conveyor belt behavior. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>GetTangentSpeed(contact)</code> returns the value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a568a3fc3585eb44878213a919420f847" title="Gets the desired tangent speed.">GetTangentSpeed</a>. </dd></dl>

</div>
</div>
<a id="af93e3743c48882f44ef7936cbad68ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93e3743c48882f44ef7936cbad68ae1">&#9670;&nbsp;</a></span>SetToi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetToi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; <a class="el" href="group__CheckedTypes.html#ga309960da94ba655d5101c19da5c55c1b">UnitIntervalFF</a>&lt; <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>toi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the time of impact (TOI). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contact</td><td>The contact to update. </td></tr>
    <tr><td class="paramname">toi</td><td>Optional time of impact as a fraction between 0 and 1 where 1 indicates no actual impact in the current time slot. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>HasValidToi(contact)</code> returns <code>toi.has_value()</code>. </dd>
<dd>
<code><a class="el" href="namespaceplayrho.html#acd05d6b92912a6430c09ad8a74bcbc73" title="Gets the time of impact (TOI) as a fraction.">GetToi(const Contact&amp;)</a></code> returns the value set. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a77e830664360ead07ab616d934ff2550" title="Gets whether a TOI is set.">HasValidToi</a>, <a class="el" href="namespaceplayrho.html#acd05d6b92912a6430c09ad8a74bcbc73" title="Gets the time of impact (TOI) as a fraction.">GetToi</a>. </dd></dl>

</div>
</div>
<a id="aabf79c789863cc4aea6b9e6bc976267c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf79c789863cc4aea6b9e6bc976267c">&#9670;&nbsp;</a></span>SetToiCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void SetToiCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html#a302944c607d7a872a6a30c653c9f690d">Contact::substep_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the TOI count to the given value. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>GetToiCount(contact)</code> returns <code>value</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#abce1723933df3c7d4054975daa7ac724" title="Gets the time of impact count.">GetToiCount</a>. </dd></dl>

</div>
</div>
<a id="af33cf35b33c93168aedcbf5a986a3472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33cf35b33c93168aedcbf5a986a3472">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplayrho.html#a704da3b24d9b1f9135e140dcd5420518">IndexPair3</a>&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices</a>(pairs))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the dynamic size of the given collection of index pairs. </p>
<dl class="section note"><dt>Note</dt><dd>This just calls <code>GetNumValidIndices</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504" title="Gets the number of valid indices in the given collection of index pairs.">GetNumValidIndices</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1ArrayList.html#a7cbc50e8f7093460b749107e4ba5e1ca">playrho::ArrayList&lt; VALUE_TYPE, MAXSIZE, SIZE_TYPE &gt;::ArrayList()</a>, <a class="el" href="namespaceplayrho.html#a516a3bbb73371cdc53f348b67f43bb1f">Alloc()</a>, <a class="el" href="namespaceplayrho.html#a2943dd9a79b7fc1fa196af1208b00388">AllocArray()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#abbb25555e5d25ed67a4748136ff7b8ed">playrho::BlockAllocator::Allocate()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a1ecbcaa8d549ffa1522e7128fc8a684d">playrho::StackAllocator::Allocate()</a>, <a class="el" href="classplayrho_1_1StackAllocator.html#a1902b15365c55a19c21e9103565e3447">playrho::StackAllocator::AllocateArray()</a>, <a class="el" href="group__Math.html#ga5928e1bb2ea4a8d60673314ff46a83cf">Average()</a>, <a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">ComputeCentroid()</a>, <a class="el" href="group__Math.html#ga08e3eae87277d85db13cce6b12facf1e">Dot()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a06536ee49cdb1a8c2f79de7522c8bd33">playrho::BlockAllocator::Free()</a>, <a class="el" href="group__Math.html#ga760effc058042418453697e733937b2f">GetAreaOfPolygon()</a>, <a class="el" href="classplayrho_1_1BlockAllocator.html#a5aa7655c98fb927d7bc7a2fc936ec6cc">playrho::BlockAllocator::GetMaxBlockSize()</a>, <a class="el" href="group__Math.html#gaee743e28b24b01d9101b8a2e7bd72284">GetPolarMoment()</a>, <a class="el" href="namespaceplayrho_1_1detail.html#a9c6ef61517707043fb5fd0891647687f">playrho::detail::IsFull()</a>, and <a class="el" href="namespaceplayrho.html#adb651f620aefb4ee65ec0cc8c10b27b0">Realloc()</a>.</p>

</div>
</div>
<a id="ab48e50a80b0fd16dfd70ee70307ad296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48e50a80b0fd16dfd70ee70307ad296">&#9670;&nbsp;</a></span>StripUnit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::StripUnit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt;  decltype(StripUnit(<a class="el" href="namespaceplayrho.html#a4b3ffaf4d26f2f410c72befd4f9b0ec6">to_underlying</a>(v)))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strips the units off of the given value. </p>
<p>Strips the unit from the given value.</p>
<dl class="section note"><dt>Note</dt><dd>This definition is for two step stripping of units. As such, it has to be after all other overloads of the <code>StripUnit</code> functions have been declared so it can use any of those as needed. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="WheelJoint_8cpp-example.html#a52">WheelJoint.cpp</a>, and <a class="el" href="World_8cpp-example.html#a83">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">Atan2()</a>, <a class="el" href="classplayrho_1_1d2_1_1Simplex.html#a21f4fbe4f435a497f723ba4692745d13">playrho::d2::Simplex::CalcMetric()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a073a93c54a20aa68f2c56e759b7976ab">playrho::d2::ClipSegmentToLine()</a>, <a class="el" href="group__Math.html#gab5164277624274fde39d33fd4f0f5dd5">Cross()</a>, <a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::DistanceProxy::Distance()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a21ae34e564b20057e6ed0f80e4485868">playrho::d2::GetContactRelVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1ChainShapeConf.html#acf3a62f07bbb6fdaeb1cbc962d62feb8">playrho::d2::ChainShapeConf::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a7304da106cfaa394b4d0179ded468aa6">playrho::d2::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a6bd25518f48c10a51a89b63e4d5103bb">playrho::d2::GetUnitVector()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a6fb896d2cd2716bc5313edf9664311dd">playrho::d2::GearJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#ac1c8f45842be63b34da6d53d811881db">playrho::d2::PrismaticJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#ad9a429415a87a06a9134b001d73bf508">playrho::d2::WeldJointConf::InitVelocity()</a>, <a class="el" href="group__Math.html#ga01639d99c5401d526aeb5c6df075e153">Invert()</a>, <a class="el" href="group__Math.html#ga1dfb22979400417701de8582bb6d76ad">Solve()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a5a54a7c5cb24901f677963106f310fec">playrho::d2::GearJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a9781e7946b790d5697f7692de702ab82">playrho::d2::PrismaticJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a0a2a5151fb0a799e0d2f0a84e4534b94">playrho::d2::WeldJointConf::SolvePosition()</a>, <a class="el" href="ContactSolver_8hpp.html#a0fd21d441a78194f210e9f900bd3d1a4">playrho::GaussSeidel::SolvePositionConstraint()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a6ee4f0a073351cace3dc1ba478411140">playrho::d2::PrismaticJointConf::SolveVelocity()</a>, and <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a25cfb7a5d3d5f2aeef028803b37454da">playrho::d2::WeldJointConf::SolveVelocity()</a>.</p>

</div>
</div>
<a id="a4b3ffaf4d26f2f410c72befd4f9b0ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3ffaf4d26f2f410c72befd4f9b0ec6">&#9670;&nbsp;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::to_underlying </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceplayrho_1_1detail.html#a2ddc4b148d5e38a5a59954a1f503e901">detail::underlying_type_t</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the given value to the value as the underlying type. </p><dl class="section note"><dt>Note</dt><dd>This is like <code>std::to_underlying</code> slated for C++23. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a177">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#abebb8afee132b1f990d43a9a223fd5ed">playrho::d2::VelocityConstraint::VelocityConstraint()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#af6a301104182688b53bfdfb4c9df309f">playrho::d2::At()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a7e8932936bd2f281984a4afacc40e7a1">playrho::d2::GetSoonestContact()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#a730c61c0b7b9ed98996116e9a30ee429">playrho::d2::World::GetWorldIndex()</a>, and <a class="el" href="ContactSolver_8hpp.html#a0fd21d441a78194f210e9f900bd3d1a4">playrho::GaussSeidel::SolvePositionConstraint()</a>.</p>

</div>
</div>
<a id="aaf49104158a7aea199f9531f9ab5b7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf49104158a7aea199f9531f9ab5b7d0">&#9670;&nbsp;</a></span>UnflagForFiltering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void UnflagForFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unflags this contact for filtering. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>NeedsFiltering(contact)</code> returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a92b68ee2dcf7f21577269938c5267f5f" title="Whether or not the contact needs filtering.">NeedsFiltering(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="ad0be851da5e90da82388aaddaa1d8f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0be851da5e90da82388aaddaa1d8f6d">&#9670;&nbsp;</a></span>UnflagForUpdating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void UnflagForUpdating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unflags this contact for updating. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>NeedsUpdating(contact)</code> returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a00846636a226626c5dd4151893f397f7" title="Whether or not the contact needs updating.">NeedsUpdating(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="a4e555a7d486dd3e1c1f7788c7d5edc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e555a7d486dd3e1c1f7788c7d5edc0f">&#9670;&nbsp;</a></span>UnsetEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void playrho::UnsetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disables the identified contact. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsEnabled(contact)</code> returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#acf2071b64988e62193b4a2567bdde292" title="Gets whether the given contact is enabled or not.">IsEnabled(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="a205494b248da96a02b57be9d9ad9a27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205494b248da96a02b57be9d9ad9a27b">&#9670;&nbsp;</a></span>UnsetImpenetrable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void UnsetImpenetrable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the impenetrability of the given contact. </p>
<dl class="section attention"><dt>Attention</dt><dd>Call this if body A or body B are no longer impenetrable. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsImpenetrable(contact)</code> returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a885fded7567b0972b4af486e5df9afea" title="Whether the given contact is &quot;impenetrable&quot;.">IsImpenetrable(const Contact &amp;)</a>. </dd></dl>

</div>
</div>
<a id="a1ae66cec17d17f003982ee50908d0d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae66cec17d17f003982ee50908d0d25">&#9670;&nbsp;</a></span>UnsetIsActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void UnsetIsActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the active state of this contact. </p>
<dl class="section attention"><dt>Attention</dt><dd>Call this if neither body A nor body B are "awake". </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsActive(contact)</code> returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ae659e1f443f30d7813853f6763f1f22f" title="Determines whether the given contact is &quot;active&quot;.">IsActive(const Contact &amp;)</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="WorldContact_8cpp-example.html#a27">WorldContact.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ad488916b3a4198e323011d0a3f417c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad488916b3a4198e323011d0a3f417c90">&#9670;&nbsp;</a></span>UnsetIsSensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void UnsetIsSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplayrho_1_1Contact.html">Contact</a> &amp;&#160;</td>
          <td class="paramname"><em>contact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsets the sensor state of the given contact. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>IsSensor(contact)</code> returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#ab8801b7203d1ab9a06ca349a9d304f3c" title="Gets whether the given contact is for sensors or not.">IsSensor(const Contact &amp;)</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="WorldContact_8cpp-example.html#a33">WorldContact.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a70ce59a4d103ae2a050ea60a2f767d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ce59a4d103ae2a050ea60a2f767d1c">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classplayrho_1_1ObjectPool.html">ObjectPool</a>&lt;T&gt;::size_type playrho::used </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1ObjectPool.html">ObjectPool</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of elements that are used in the specified structure. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of the specified structure minus the size of its free pool. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a31907e80be5889667f03ef86ee3bbf0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31907e80be5889667f03ef86ee3bbf0a">&#9670;&nbsp;</a></span>DefaultAngularSleepTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultAngularSleepTolerance = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>((<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2) / 180) * <a class="el" href="group__PhysicalUnits.html#ga446e46852ff69dee446aadc44635865c">RadianPerSecond</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default angular sleep tolerance.</p>
<p>A body cannot sleep if its angular velocity is above this amount. </p>

</div>
</div>
<a id="adfccbc3cd8cc0bb78701f62e041acdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfccbc3cd8cc0bb78701f62e041acdba">&#9670;&nbsp;</a></span>DefaultAngularSlop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultAngularSlop = (<a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 2_rad) / <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(180)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default angular slop. </p>
<p>A small angle used as a collision and constraint tolerance. Usually it is chosen to be numerically significant, but visually insignificant. </p>

</div>
</div>
<a id="ac12a28e4c1a2b9138c79d895d3ccb3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12a28e4c1a2b9138c79d895d3ccb3aa">&#9670;&nbsp;</a></span>DefaultCirclesRatio</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultCirclesRatio = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(10)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default circles ratio.</p>
<p>Ratio used for switching between rounded-corner collisions and closest-face biased normal collisions. </p>

</div>
</div>
<a id="a490b0d336b7a74ae18cf57632eeb7aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490b0d336b7a74ae18cf57632eeb7aa9">&#9670;&nbsp;</a></span>DefaultLinearSleepTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultLinearSleepTolerance = 0.01_mps</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default linear sleep tolerance.</p>
<p>A body cannot sleep if the magnitude of its linear velocity is above this amount. </p>

</div>
</div>
<a id="ad91e53ba44755653e34147d39695a0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91e53ba44755653e34147d39695a0a1">&#9670;&nbsp;</a></span>DefaultLinearSlop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultLinearSlop = 0.005_m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default linear slop. </p>
<p>Length used as a collision and constraint tolerance. Usually chosen to be numerically significant, but visually insignificant. Lower or raise to decrease or increase respectively the minimum of space between bodies at rest. </p><dl class="section note"><dt>Note</dt><dd>Smaller values relative to sizes of bodies increases the time it takes for bodies to come to rest. </dd>
<dd>
The value used by Box2D 2.3.2 b2_linearSlop define is 0.005_m. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Compositor_8cpp-example.html#a20">Compositor.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1PolygonShapeConf.html#afdeb3fda682d199b593b3567534abb67">playrho::d2::PolygonShapeConf::Set()</a>.</p>

</div>
</div>
<a id="ac8fea4a93f741aa800e943957fd23656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fea4a93f741aa800e943957fd23656">&#9670;&nbsp;</a></span>DefaultMaxAngularCorrection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxAngularCorrection = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(8.0f / 180.0f) * <a class="el" href="namespaceplayrho.html#a3fe0bdbb0ea9c449b7504f7c75840993">Pi</a> * 1_rad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum angular correction. </p>
<dl class="section note"><dt>Note</dt><dd>This value should be greater than the angular slop value. </dd></dl>

</div>
</div>
<a id="aa7d2cfbedb9200e2ed973eb18cc3b23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d2cfbedb9200e2ed973eb18cc3b23b">&#9670;&nbsp;</a></span>DefaultMaxLinearCorrection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxLinearCorrection = 0.2_m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum linear correction. </p>
<p>The maximum linear position correction used when solving constraints. This helps to prevent overshoot. </p><dl class="section note"><dt>Note</dt><dd>This value should be greater than the linear slop value. </dd></dl>

</div>
</div>
<a id="a36c3a1adc34421b07e930a06ce905db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c3a1adc34421b07e930a06ce905db1">&#9670;&nbsp;</a></span>DefaultMaxRotation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxRotation = <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>{179_deg}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum rotation per world step. </p>
<dl class="section warning"><dt>Warning</dt><dd>This value should always be less than 180 degrees - i.e. less than .5 * Pi * Radian. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This limit is meant to prevent numerical problems. Adjusting this value isn't advised. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structplayrho_1_1StepConf.html#a0ab48d76f772682e5d2d2d937eacdde4" title="Maximum rotation.">StepConf::maxRotation</a>. </dd></dl>

</div>
</div>
<a id="aa678e38c906502e06a90f31e2acc952a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa678e38c906502e06a90f31e2acc952a">&#9670;&nbsp;</a></span>DefaultMaxSubSteps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxSubSteps = std::uint8_t{8}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default maximum number of sub steps.</p>
<p>This is the default maximum number of sub-steps per contact in continuous physics simulation. In other words, this is the default maximum number of times in a world step that a contact will have continuous collision resolution done for it. </p><dl class="section note"><dt>Note</dt><dd>Used in the TOI phase of step processing. </dd></dl>

</div>
</div>
<a id="a7beadf6067bdf66f48ee9b94c337d252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7beadf6067bdf66f48ee9b94c337d252">&#9670;&nbsp;</a></span>DefaultMaxVertexRadius</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMaxVertexRadius = 255_m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default maximum vertex radius. </p>
<dl class="section note"><dt>Note</dt><dd>Recommend using <code>255_m</code> or <code>DefaultLinearSlop * 2 * 25500</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a150">World.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a0e76508577c61a5bc9cc3107d60f3c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e76508577c61a5bc9cc3107d60f3c1b">&#9670;&nbsp;</a></span>DefaultMinStillTimeToSleep</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMinStillTimeToSleep = <a class="el" href="group__PhysicalQuantities.html#gaa4842e1cf025b86cafb4b09c0f51bc18">Time</a>{1_s / 2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default minimum still time to sleep.</p>
<p>The default minimum time bodies must be still for bodies to be put to sleep. </p>

</div>
</div>
<a id="a174cfa632eb92c15bc2e48e7d09d216a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174cfa632eb92c15bc2e48e7d09d216a">&#9670;&nbsp;</a></span>DefaultMinVertexRadius</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::DefaultMinVertexRadius = 0.01_m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default minimum vertex radius. </p>
<dl class="section note"><dt>Note</dt><dd>Recommend using <code>0.01_m</code> or <code>DefaultLinearSlop * Real(2)</code>. </dd></dl>

</div>
</div>
<a id="ae4c4c9f92abc8bb90f494053a8e04375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c4c9f92abc8bb90f494053a8e04375">&#9670;&nbsp;</a></span>Invalid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::enable_if_t&lt; std::numeric_limits&lt; T &gt;::has_signaling_NaN||std::numeric_limits&lt; T &gt;::has_quiet_NaN, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Invalid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::numeric_limits&lt;T&gt;::has_signaling_NaN</div>
<div class="line">    ? std::numeric_limits&lt;T&gt;::signaling_NaN()</div>
<div class="line">    : <a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;T&gt;::quiet_NaN()</div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div></div>
</div><!-- fragment -->
<p>Invalid value of the template's instantiated numeric type. </p>

</div>
</div>
<a id="a38fa6c4a45ec8fd218dc962396685c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fa6c4a45ec8fd218dc962396685c3f">&#9670;&nbsp;</a></span>InvalidBodyID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidBodyID = static_cast&lt;<a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92">BodyID</a>&gt;(static_cast&lt;<a class="el" href="classplayrho_1_1detail_1_1IndexingNamedType.html#a2ed01bf69779b0880b5092c6bbad560b">BodyID::underlying_type</a>&gt;(-1))</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalid body ID value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceplayrho.html#a9d094e8b19ea714a079a48c336abad92" title="Strongly typed identifier for bodies within World instances.">BodyID</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DistanceJoint_8cpp-example.html#a1">DistanceJoint.cpp</a>, <a class="el" href="FrictionJoint_8cpp-example.html#a0">FrictionJoint.cpp</a>, <a class="el" href="GearJoint_8cpp-example.html#a0">GearJoint.cpp</a>, <a class="el" href="Joint_8cpp-example.html#a0">Joint.cpp</a>, <a class="el" href="MotorJoint_8cpp-example.html#a1">MotorJoint.cpp</a>, <a class="el" href="PulleyJoint_8cpp-example.html#a0">PulleyJoint.cpp</a>, <a class="el" href="RevoluteJoint_8cpp-example.html#a0">RevoluteJoint.cpp</a>, <a class="el" href="RopeJoint_8cpp-example.html#a0">RopeJoint.cpp</a>, <a class="el" href="TargetJoint_8cpp-example.html#a18">TargetJoint.cpp</a>, <a class="el" href="WeldJoint_8cpp-example.html#a0">WeldJoint.cpp</a>, <a class="el" href="WheelJoint_8cpp-example.html#a0">WheelJoint.cpp</a>, <a class="el" href="World_8cpp-example.html#a32">World.cpp</a>, and <a class="el" href="WorldBody_8cpp-example.html#a1">WorldBody.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1World.html#a678b061692e87f71d512b8bb80f9377d">playrho::d2::World::FindClosestBody()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#ad3c653a34c7a681dbc60ec447225e85f">playrho::d2::World::GetAnchorA()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#aa88982e1bd4c8bafe0160cdad5a68a71">playrho::d2::World::GetAnchorB()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a04f5087d761eecd8554b6156d1cc3021">playrho::d2::DistanceJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1FrictionJointConf.html#a904a7c9eb12d39f5331d70e31bfc5aa3">playrho::d2::FrictionJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a6fb896d2cd2716bc5313edf9664311dd">playrho::d2::GearJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1MotorJointConf.html#a2b683394550bdac7d8ff211bf659cc79">playrho::d2::MotorJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#ac1c8f45842be63b34da6d53d811881db">playrho::d2::PrismaticJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html#a4bc9c62ac7aaef84c0c536a1b439ccf9">playrho::d2::PulleyJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#a7b32961588123ecf24d8c176b39be0b8">playrho::d2::RevoluteJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html#a0fa82bd7d2ebe576faf0ceac30982870">playrho::d2::RopeJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a1bc16ad22662f69d6218f879a5c17245">playrho::d2::TargetJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#ad9a429415a87a06a9134b001d73bf508">playrho::d2::WeldJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a9e194ef30b3a342a38f9afc09c629f6d">playrho::d2::WheelJointConf::InitVelocity()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#ac628649081fe495f59e06aff27f3201d">playrho::d2::World::IsEnabled()</a>, <a class="el" href="namespaceplayrho.html#ab7404128f6225cf6915219bb784c7843">IsValid()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#a85c5cee4a3713d3ef248eab7b4d05926">playrho::d2::World::SetAwake()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a1cb4cf206219920fd02778200b00d623">playrho::d2::DistanceJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a5a54a7c5cb24901f677963106f310fec">playrho::d2::GearJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a9781e7946b790d5697f7692de702ab82">playrho::d2::PrismaticJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html#afa2b76fbf75674d72e4bab581590eec4">playrho::d2::PulleyJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#a15b5d820404f01071ece796f787c4fab">playrho::d2::RevoluteJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html#a168b27b3bf6ef8dec62708dd2037abcb">playrho::d2::RopeJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a0a2a5151fb0a799e0d2f0a84e4534b94">playrho::d2::WeldJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a14e495be301fc95b5f890716f9e51309">playrho::d2::WheelJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a9b2e8c358061fcd3724da3c1cb5fcc32">playrho::d2::DistanceJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1FrictionJointConf.html#a6072ec80a0f6f19ddf2bbc57abe6110a">playrho::d2::FrictionJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#ab274b1bb66255adc6ad6fe9ea22fbe5c">playrho::d2::GearJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1MotorJointConf.html#a9fbbab76d642be0211f8c76334ccbe0f">playrho::d2::MotorJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a6ee4f0a073351cace3dc1ba478411140">playrho::d2::PrismaticJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html#ac62c3b05e95c61b801722de099d962de">playrho::d2::PulleyJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#aa27f190089266d9d8de1d9f3ae963999">playrho::d2::RevoluteJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html#a67249c115b7b84fc2a58abc83664c934">playrho::d2::RopeJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a87f0cb382d657fcac4402b3896269fe3">playrho::d2::TargetJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a25cfb7a5d3d5f2aeef028803b37454da">playrho::d2::WeldJointConf::SolveVelocity()</a>, and <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a6474e7647ffafa7698e6b2fb0282f3cc">playrho::d2::WheelJointConf::SolveVelocity()</a>.</p>

</div>
</div>
<a id="a1a7a2c4f0ce447813c94060e1ea4c0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7a2c4f0ce447813c94060e1ea4c0f9">&#9670;&nbsp;</a></span>InvalidContactID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidContactID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="keyword">static_cast&lt;</span><a class="code" href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">ContactID</a><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span>ContactID::underlying_type<span class="keyword">&gt;</span>(-1))</div>
<div class="ttc" id="anamespaceplayrho_html_abe7a48a3a0e57fa1a9dd9e396b6b24f7"><div class="ttname"><a href="namespaceplayrho.html#abe7a48a3a0e57fa1a9dd9e396b6b24f7">playrho::ContactID</a></div><div class="ttdeci">detail::IndexingNamedType&lt; ContactCounter, struct ContactIdentifier &gt; ContactID</div><div class="ttdoc">Strongly typed identifier of contacts within World instances.</div><div class="ttdef"><b>Definition:</b> ContactID.hpp:33</div></div>
</div><!-- fragment -->
<p>Invalid contact ID value. </p>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a7e8932936bd2f281984a4afacc40e7a1">playrho::d2::GetSoonestContact()</a>, and <a class="el" href="namespaceplayrho.html#adc42b14180314ff41872c38c5596970c">IsValid()</a>.</p>

</div>
</div>
<a id="a6fb9d11a6fadb62b0e68aee9797059ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb9d11a6fadb62b0e68aee9797059ad">&#9670;&nbsp;</a></span>InvalidIndexPair</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::InvalidIndexPair</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">IndexPair</a>{</div>
<div class="line">    <a class="code" href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">InvalidVertex</a>, <a class="code" href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">InvalidVertex</a></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceplayrho_html_a49c511e18a6b72260126cf763c1cd8df"><div class="ttname"><a href="namespaceplayrho.html#a49c511e18a6b72260126cf763c1cd8df">playrho::InvalidVertex</a></div><div class="ttdeci">constexpr auto InvalidVertex</div><div class="ttdoc">Invalid vertex index.</div><div class="ttdef"><b>Definition:</b> Settings.hpp:85</div></div>
<div class="ttc" id="anamespaceplayrho_html_a7d449e0a1528c10ae0f241713fb69b40"><div class="ttname"><a href="namespaceplayrho.html#a7d449e0a1528c10ae0f241713fb69b40">playrho::IndexPair</a></div><div class="ttdeci">std::pair&lt; VertexCounter, VertexCounter &gt; IndexPair</div><div class="ttdoc">Index pair.</div><div class="ttdef"><b>Definition:</b> IndexPair.hpp:36</div></div>
</div><!-- fragment -->
<p>Invalid index-pair value. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::DistanceProxy::Distance()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a70613779e152f647af4f80dce352d83c">playrho::d2::GetIndexPairs()</a>, and <a class="el" href="namespaceplayrho.html#ad136f8db9fd6c0c583c1890b8a3cc504">GetNumValidIndices()</a>.</p>

</div>
</div>
<a id="a7b821c4b23566defba0fd2917d95f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b821c4b23566defba0fd2917d95f0ba">&#9670;&nbsp;</a></span>MaxBodies</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxBodies</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div>
<div class="line">                                                      std::uint16_t{1})</div>
</div><!-- fragment -->
<p>Maximum number of bodies in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a130">World.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a5ac18ab5fe22782c56d7ab92b397468e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac18ab5fe22782c56d7ab92b397468e">&#9670;&nbsp;</a></span>MaxContacts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxContacts = <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a>} * <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>{<a class="el" href="namespaceplayrho.html#a7b821c4b23566defba0fd2917d95f0ba">MaxBodies</a> - 1} / <a class="el" href="namespaceplayrho.html#a5fd824505590e2ca67e0ef804ede6e34">ContactCounter</a>{2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of contacts in a world (2147319811). </p>
<p>Uses the formula for the maximum number of edges in an unidirectional graph of <code>MaxBodies</code> nodes. This occurs when every possible body is connected to every other body. </p>

</div>
</div>
<a id="a69cde8c9e938d138a9a4ae8355501684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69cde8c9e938d138a9a4ae8355501684">&#9670;&nbsp;</a></span>MaxJoints</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxJoints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div>
<div class="line">                                                      std::uint16_t{1})</div>
</div><!-- fragment -->
<p>Maximum number of joints in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a131">World.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aae670387c8f37f8812082b1838e18863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae670387c8f37f8812082b1838e18863">&#9670;&nbsp;</a></span>MaxManifoldPoints</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxManifoldPoints = std::uint8_t{2}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum manifold points. This is the maximum number of contact points between two convex shapes. Do not change this value. </p><dl class="section note"><dt>Note</dt><dd>For memory efficiency, uses the smallest integral type that can hold the value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1ContactImpulsesList.html#a10582ed9bfbe1061650b20acbaa3787f">playrho::d2::ContactImpulsesList::AddEntry()</a>, <a class="el" href="classplayrho_1_1d2_1_1Manifold.html#a1399ecf9d6951ca8b72dd34dc66d1e75">playrho::d2::Manifold::AddPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1ContactImpulsesList.html#a93e87aaa55a2d38ff22bda824bf84ef6">playrho::d2::ContactImpulsesList::GetEntryNormal()</a>, <a class="el" href="classplayrho_1_1d2_1_1ContactImpulsesList.html#aaba0fcd7239b70c9c20a27c6f54f42da">playrho::d2::ContactImpulsesList::GetEntryTanget()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a82d672d8bf598bf27a746423392b72b3">playrho::d2::WorldManifold::GetImpulses()</a>, <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a4872f3b8f5ec291a4e2d8324829f82b6">playrho::d2::WorldManifold::GetPoint()</a>, <a class="el" href="classplayrho_1_1d2_1_1VelocityConstraint.html#a0522810720f80c9e976e069aaca09cf4">playrho::d2::VelocityConstraint::GetPointAt()</a>, and <a class="el" href="classplayrho_1_1d2_1_1WorldManifold.html#a0e20bfa57459aa27c74c57043b822bd0">playrho::d2::WorldManifold::GetSeparation()</a>.</p>

</div>
</div>
<a id="a2e673e5e335bf14ece1382b582f2163b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e673e5e335bf14ece1382b582f2163b">&#9670;&nbsp;</a></span>MaxShapes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxShapes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <span class="keyword">static_cast&lt;</span>std::uint16_t<span class="keyword">&gt;</span>(std::numeric_limits&lt;std::uint16_t&gt;::max() -</div>
<div class="line">                                                      std::uint16_t{1})</div>
</div><!-- fragment -->
<p>Maximum number of shapes in a world. </p>
<dl class="section note"><dt>Note</dt><dd>This is 65534 based off <code>std::uint16_t</code> and eliminating one value for invalid. </dd></dl>

</div>
</div>
<a id="a0774f630ff2e5b9ed9e5f322700d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0774f630ff2e5b9ed9e5f322700d44e4">&#9670;&nbsp;</a></span>MaxShapeVertices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::MaxShapeVertices = std::uint8_t{254}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of vertices for any shape type. </p>
<dl class="section note"><dt>Note</dt><dd>For memory efficiency, uses the smallest integral type that can hold the value minus one that's left out as a sentinel value. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1ToiOutput.html#a19b308c9b3b8f5292b9f3dad183c9d76">playrho::ToiOutput::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="a3fe0bdbb0ea9c449b7504f7c75840993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe0bdbb0ea9c449b7504f7c75840993">&#9670;&nbsp;</a></span>Pi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Pi = <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(3.14159265358979323846264338327950288L)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pi. </p>
<p>An "irrational number" that's defined as the ratio of a circle's circumference to its diameter.</p>
<dl class="section note"><dt>Note</dt><dd>While the include file definition of M_PI may be a POSIX compliance requirement and initially attractive to use, it's apparently not a C++ standards requirement and casually including it pollutes the name space of all code that uses this library. Whatever the case, MSVC 2017 doesn't make it part of the <code>cmath</code> include without enabling <code>_USE_MATH_DEFINES</code>. So rather than add yet more C preprocessor macros to all sources that this library may be compiled with, it's simply hard-coded in here instead using a C++ mechanism that also keeps it with the enclosing name space. </dd>
<dd>
Any narrowing is intentional.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Pi">https://en.wikipedia.org/wiki/Pi</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="World_8cpp-example.html#a82">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga007d43d0fd5ce900118dd41e3197d887">GetAreaOfCircle()</a>, <a class="el" href="group__Math.html#ga338c586cf1a29f27ee334d061fa59b5d">GetCircleVertices()</a>, <a class="el" href="structplayrho_1_1d2_1_1ChainShapeConf.html#acf3a62f07bbb6fdaeb1cbc962d62feb8">playrho::d2::ChainShapeConf::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad7dc3397566d3b0447d318e67761bbc2">playrho::d2::GetMassData()</a>, <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">GetNormalized()</a>, <a class="el" href="structplayrho_1_1d2_1_1Position.html#a30e3652aa86130f81c948112cf4538d6">playrho::d2::Position::GetPosition()</a>, <a class="el" href="group__Math.html#gac9b72aa4a587e552a586a42494d614c1">GetShortestDelta()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a04f5087d761eecd8554b6156d1cc3021">playrho::d2::DistanceJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a1bc16ad22662f69d6218f879a5c17245">playrho::d2::TargetJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#ad9a429415a87a06a9134b001d73bf508">playrho::d2::WeldJointConf::InitVelocity()</a>, and <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a9e194ef30b3a342a38f9afc09c629f6d">playrho::d2::WheelJointConf::InitVelocity()</a>.</p>

</div>
</div>
<a id="aae1bd392cbafcb91d60633c893ff0742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1bd392cbafcb91d60633c893ff0742">&#9670;&nbsp;</a></span>SquareRootTwo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::SquareRootTwo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>(1.414213562373095048801688724209698078569671875376948073176679737990732478462L)</div>
<div class="ttc" id="anamespaceplayrho_html_a1fc125070a08100d083a1360f7167f87"><div class="ttname"><a href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">playrho::Real</a></div><div class="ttdeci">float Real</div><div class="ttdoc">Real-number type.</div><div class="ttdef"><b>Definition:</b> Real.hpp:65</div></div>
</div><!-- fragment -->
<p>Square root of two. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Square_root_of_2">https://en.wikipedia.org/wiki/Square_root_of_2</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html#ad253c43a96160cfccf89cf650abd225e">playrho::d2::UnitVec::GetBottomRight()</a>, and <a class="el" href="classplayrho_1_1d2_1_1UnitVec.html#a1e841cb8279292e8fbaf0d83b4cd0ddb">playrho::d2::UnitVec::GetTopRight()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceplayrho.html">playrho</a></li>
    <li class="footer">Generated on Tue Oct 24 2023 15:01:08 for PlayRho by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
