<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PlayRho: Additional Math Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlayRho
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">An interactive physics engine &amp; library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__Math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Additional Math Functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>Additional functions for common mathematical operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9447e387f79e761f547aa4d321605c78"><td class="memTemplParams" colspan="2"><a id="ga9447e387f79e761f547aa4d321605c78"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9447e387f79e761f547aa4d321605c78"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga9447e387f79e761f547aa4d321605c78">playrho::AlmostEqual</a> (const T &amp;x, const T &amp;y, int ulp=2) -&gt; std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt;, bool &gt;</td></tr>
<tr class="memdesc:ga9447e387f79e761f547aa4d321605c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given two values are "almost equal". <br /></td></tr>
<tr class="separator:ga9447e387f79e761f547aa4d321605c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994ed50293b78dff53a5c7bce78602bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga994ed50293b78dff53a5c7bce78602bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga994ed50293b78dff53a5c7bce78602bf">playrho::AlmostZero</a> (const T &amp;value) -&gt; decltype(<a class="el" href="namespaceplayrho.html#ac862a8609b82126d0683ecb38a498087">abs</a>(value)&lt; std::numeric_limits&lt; T &gt;::min())</td></tr>
<tr class="memdesc:ga994ed50293b78dff53a5c7bce78602bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether a given value is almost zero.  <a href="group__Math.html#ga994ed50293b78dff53a5c7bce78602bf">More...</a><br /></td></tr>
<tr class="separator:ga994ed50293b78dff53a5c7bce78602bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab870a9188fcc77c905807fa718a8268d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">playrho::Atan2</a> (T y, T x)</td></tr>
<tr class="memdesc:gab870a9188fcc77c905807fa718a8268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc-tangent of the given y and x values.  <a href="group__Math.html#gab870a9188fcc77c905807fa718a8268d">More...</a><br /></td></tr>
<tr class="separator:gab870a9188fcc77c905807fa718a8268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="memTemplParams" colspan="2"><a id="ga5928e1bb2ea4a8d60673314ff46a83cf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga5928e1bb2ea4a8d60673314ff46a83cf">playrho::Average</a> (const T &amp;span)</td></tr>
<tr class="memdesc:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the average of the given values. <br /></td></tr>
<tr class="separator:ga5928e1bb2ea4a8d60673314ff46a83cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9807960f6f6e39b0449aec22d646669"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad9807960f6f6e39b0449aec22d646669"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gad9807960f6f6e39b0449aec22d646669">playrho::Bisect</a> (const T &amp;a1, const T &amp;a2) -&gt; decltype((a1+a2)/2)</td></tr>
<tr class="memdesc:gad9807960f6f6e39b0449aec22d646669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisection method.  <a href="group__Math.html#gad9807960f6f6e39b0449aec22d646669">More...</a><br /></td></tr>
<tr class="separator:gad9807960f6f6e39b0449aec22d646669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3f6e8b69eaeee408d3894b59629cffe9">playrho::cfloor</a> (T v) noexcept</td></tr>
<tr class="memdesc:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant expression enhanced floor function.  <a href="group__Math.html#ga3f6e8b69eaeee408d3894b59629cffe9">More...</a><br /></td></tr>
<tr class="separator:ga3f6e8b69eaeee408d3894b59629cffe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae769785f0540a4b8960b282f6b105c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">playrho::ComputeCentroid</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gae769785f0540a4b8960b282f6b105c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid of a counter-clockwise array of 3 or more vertices.  <a href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">More...</a><br /></td></tr>
<tr class="separator:gae769785f0540a4b8960b282f6b105c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5164277624274fde39d33fd4f0f5dd5"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size_v&lt; T1 &gt;==2 &amp;&amp;std::tuple_size_v&lt; T2 &gt;==2, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:gab5164277624274fde39d33fd4f0f5dd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab5164277624274fde39d33fd4f0f5dd5">playrho::Cross</a> (const T1 &amp;a, const T2 &amp;b) noexcept</td></tr>
<tr class="memdesc:gab5164277624274fde39d33fd4f0f5dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the 2-element analog of the cross product of two vectors.  <a href="group__Math.html#gab5164277624274fde39d33fd4f0f5dd5">More...</a><br /></td></tr>
<tr class="separator:gab5164277624274fde39d33fd4f0f5dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0508a648e02202d025b83e46973e45"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaff0508a648e02202d025b83e46973e45"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gaff0508a648e02202d025b83e46973e45">playrho::ctrunc</a> (T v) noexcept</td></tr>
<tr class="memdesc:gaff0508a648e02202d025b83e46973e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant expression enhanced truncate function.  <a href="group__Math.html#gaff0508a648e02202d025b83e46973e45">More...</a><br /></td></tr>
<tr class="separator:gaff0508a648e02202d025b83e46973e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e3eae87277d85db13cce6b12facf1e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga08e3eae87277d85db13cce6b12facf1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga08e3eae87277d85db13cce6b12facf1e">playrho::Dot</a> (const T1 &amp;a, const T2 &amp;b) noexcept</td></tr>
<tr class="memdesc:ga08e3eae87277d85db13cce6b12facf1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dot product on two vectors (A and B).  <a href="group__Math.html#ga08e3eae87277d85db13cce6b12facf1e">More...</a><br /></td></tr>
<tr class="separator:ga08e3eae87277d85db13cce6b12facf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941d2e26e203e19b567a018570417be3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga941d2e26e203e19b567a018570417be3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga941d2e26e203e19b567a018570417be3">playrho::GetAngle</a> (const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:ga941d2e26e203e19b567a018570417be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the angle.  <a href="group__Math.html#ga941d2e26e203e19b567a018570417be3">More...</a><br /></td></tr>
<tr class="separator:ga941d2e26e203e19b567a018570417be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007d43d0fd5ce900118dd41e3197d887"><td class="memItemLeft" align="right" valign="top"><a id="ga007d43d0fd5ce900118dd41e3197d887"></a>
<a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga007d43d0fd5ce900118dd41e3197d887">playrho::GetAreaOfCircle</a> (<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a> radius)</td></tr>
<tr class="memdesc:ga007d43d0fd5ce900118dd41e3197d887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a circle. <br /></td></tr>
<tr class="separator:ga007d43d0fd5ce900118dd41e3197d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760effc058042418453697e733937b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga760effc058042418453697e733937b2f">playrho::GetAreaOfPolygon</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:ga760effc058042418453697e733937b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the area of a polygon.  <a href="group__Math.html#ga760effc058042418453697e733937b2f">More...</a><br /></td></tr>
<tr class="separator:ga760effc058042418453697e733937b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memItemLeft" align="right" valign="top"><a id="ga3b8e8abc999b0c63cf1921b0edcf0b36"></a>
std::vector&lt; <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3b8e8abc999b0c63cf1921b0edcf0b36">playrho::GetCircleVertices</a> (<a class="el" href="group__PhysicalQuantities.html#ga8705f1923f7cff39bf09f6d01989770d">Length</a> radius, unsigned slices, <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> start=0_deg, <a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a> turns=<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>{1})</td></tr>
<tr class="memdesc:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the vertices for a circle described by the given parameters. <br /></td></tr>
<tr class="separator:ga3b8e8abc999b0c63cf1921b0edcf0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d41854b91fcfb6b8ea05e7b8c92e304"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga5d41854b91fcfb6b8ea05e7b8c92e304">playrho::GetFwdRotationalAngle</a> (const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a1, const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a2) noexcept</td></tr>
<tr class="memdesc:ga5d41854b91fcfb6b8ea05e7b8c92e304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the forward/clockwise rotational angle to go from angle 1 to angle 2.  <a href="group__Math.html#ga5d41854b91fcfb6b8ea05e7b8c92e304">More...</a><br /></td></tr>
<tr class="separator:ga5d41854b91fcfb6b8ea05e7b8c92e304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9354b34edeb8433cd3062aecb78143"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0a9354b34edeb8433cd3062aecb78143">playrho::GetInverse22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept -&gt; <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a></td></tr>
<tr class="memdesc:ga0a9354b34edeb8433cd3062aecb78143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the inverse of the given matrix as a 2-by-2.  <a href="group__Math.html#ga0a9354b34edeb8433cd3062aecb78143">More...</a><br /></td></tr>
<tr class="separator:ga0a9354b34edeb8433cd3062aecb78143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gafe323c1c5ab88d30d18413a3c1f10abb">playrho::GetMagnitude</a> (const T &amp;value) noexcept(noexcept(<a class="el" href="group__FixedMath.html#ga7a9d7e9855b45a3b4103632a47ccd6f4">sqrt</a>(<a class="el" href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">GetMagnitudeSquared</a>(value)))) -&gt; decltype(<a class="el" href="group__FixedMath.html#ga7a9d7e9855b45a3b4103632a47ccd6f4">sqrt</a>(<a class="el" href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">GetMagnitudeSquared</a>(value)))</td></tr>
<tr class="memdesc:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the magnitude of the given value.  <a href="group__Math.html#gafe323c1c5ab88d30d18413a3c1f10abb">More...</a><br /></td></tr>
<tr class="separator:gafe323c1c5ab88d30d18413a3c1f10abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36866f7061dfa4d056405aa5da0daf84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga36866f7061dfa4d056405aa5da0daf84"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">playrho::GetMagnitudeSquared</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:ga36866f7061dfa4d056405aa5da0daf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the square of the magnitude of the given iterable value.  <a href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">More...</a><br /></td></tr>
<tr class="separator:ga36866f7061dfa4d056405aa5da0daf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga81dbf936e69c8d2ecc9ca3600c6be3a1">playrho::GetModuloNext</a> (T value, const T count) noexcept -&gt; decltype(++value,(value&lt; count)? value:static_cast&lt; T &gt;(0), T())</td></tr>
<tr class="memdesc:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo next value.  <a href="group__Math.html#ga81dbf936e69c8d2ecc9ca3600c6be3a1">More...</a><br /></td></tr>
<tr class="separator:ga81dbf936e69c8d2ecc9ca3600c6be3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga6434759234bd5e94759bf10cc4eb5ac5">playrho::GetModuloPrev</a> (const T value, const T count) noexcept -&gt; decltype((value ? value :count) - static_cast&lt; T &gt;(1), T())</td></tr>
<tr class="memdesc:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the modulo previous value.  <a href="group__Math.html#ga6434759234bd5e94759bf10cc4eb5ac5">More...</a><br /></td></tr>
<tr class="separator:ga6434759234bd5e94759bf10cc4eb5ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156a2abff11f978a8df25efbf0c10147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized</a> (<a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> value) noexcept</td></tr>
<tr class="memdesc:ga156a2abff11f978a8df25efbf0c10147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the "normalized" value of the given angle.  <a href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">More...</a><br /></td></tr>
<tr class="separator:ga156a2abff11f978a8df25efbf0c10147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee743e28b24b01d9101b8a2e7bd72284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#ga687546b31c191aeeacf223bdbebe6747">SecondMomentOfArea</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaee743e28b24b01d9101b8a2e7bd72284">playrho::GetPolarMoment</a> (const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;vertices)</td></tr>
<tr class="memdesc:gaee743e28b24b01d9101b8a2e7bd72284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the polar moment of the area enclosed by the given vertices.  <a href="group__Math.html#gaee743e28b24b01d9101b8a2e7bd72284">More...</a><br /></td></tr>
<tr class="separator:gaee743e28b24b01d9101b8a2e7bd72284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1413e02cc41bf9943071baa2ae242c27"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1413e02cc41bf9943071baa2ae242c27">playrho::GetRevRotationalAngle</a> (const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a1, const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;a2) noexcept</td></tr>
<tr class="memdesc:ga1413e02cc41bf9943071baa2ae242c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2.  <a href="group__Math.html#ga1413e02cc41bf9943071baa2ae242c27">More...</a><br /></td></tr>
<tr class="separator:ga1413e02cc41bf9943071baa2ae242c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b72aa4a587e552a586a42494d614c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gac9b72aa4a587e552a586a42494d614c1">playrho::GetShortestDelta</a> (<a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> a0, <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> a1) noexcept</td></tr>
<tr class="memdesc:gac9b72aa4a587e552a586a42494d614c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shortest angular distance to go from angle 0 to angle 1.  <a href="group__Math.html#gac9b72aa4a587e552a586a42494d614c1">More...</a><br /></td></tr>
<tr class="separator:gac9b72aa4a587e552a586a42494d614c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39333b6fc4de2a8f365b74194e42ceef"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga39333b6fc4de2a8f365b74194e42ceef">playrho::GetSymInverse33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;value) noexcept -&gt; <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a></td></tr>
<tr class="memdesc:ga39333b6fc4de2a8f365b74194e42ceef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the symmetric inverse of this matrix as a 3-by-3.  <a href="group__Math.html#ga39333b6fc4de2a8f365b74194e42ceef">More...</a><br /></td></tr>
<tr class="separator:ga39333b6fc4de2a8f365b74194e42ceef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c69326c22bafb811d6e00b9e6966cc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga68c69326c22bafb811d6e00b9e6966cc">playrho::InverseTransform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;v, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A) noexcept</td></tr>
<tr class="separator:ga68c69326c22bafb811d6e00b9e6966cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01639d99c5401d526aeb5c6df075e153"><td class="memTemplParams" colspan="2"><a id="ga01639d99c5401d526aeb5c6df075e153"></a>
template&lt;class IN_TYPE &gt; </td></tr>
<tr class="memitem:ga01639d99c5401d526aeb5c6df075e153"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga01639d99c5401d526aeb5c6df075e153">playrho::Invert</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; IN_TYPE &gt; &amp;value) noexcept</td></tr>
<tr class="memdesc:ga01639d99c5401d526aeb5c6df075e153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the given value. <br /></td></tr>
<tr class="separator:ga01639d99c5401d526aeb5c6df075e153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fac7df522251c1cc54aeafbfe3b737"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga96fac7df522251c1cc54aeafbfe3b737"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga96fac7df522251c1cc54aeafbfe3b737">playrho::IsOdd</a> (const T &amp;val) -&gt; decltype((val % 2) !=T{})</td></tr>
<tr class="memdesc:ga96fac7df522251c1cc54aeafbfe3b737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is-odd.  <a href="group__Math.html#ga96fac7df522251c1cc54aeafbfe3b737">More...</a><br /></td></tr>
<tr class="separator:ga96fac7df522251c1cc54aeafbfe3b737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="memTemplParams" colspan="2"><a id="ga08b9672d78dbe1aa5275a9c514b422f5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga08b9672d78dbe1aa5275a9c514b422f5">playrho::IsPowerOfTwo</a> (const T &amp;n) -&gt; decltype(n &amp;&amp;!(n &amp;(n - 1)))</td></tr>
<tr class="memdesc:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether or not the given value is a power of two. <br /></td></tr>
<tr class="separator:ga08b9672d78dbe1aa5275a9c514b422f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab53c16bcb68dd36d3b18027a2ac6b1b2">playrho::ModuloViaFmod</a> (T dividend, T divisor)</td></tr>
<tr class="memdesc:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::fmod</code>.  <a href="group__Math.html#gab53c16bcb68dd36d3b18027a2ac6b1b2">More...</a><br /></td></tr>
<tr class="separator:gab53c16bcb68dd36d3b18027a2ac6b1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">playrho::ModuloViaTrunc</a> (T dividend, T divisor) noexcept</td></tr>
<tr class="memdesc:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulo operation using <code>std::trunc</code>.  <a href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200">More...</a><br /></td></tr>
<tr class="separator:ga84e7cb2a415fcb956202c8d7e1b1d200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab471bae6413067374ab8d8262533e402"><td class="memItemLeft" align="right" valign="top"><a id="gab471bae6413067374ab8d8262533e402"></a>
constexpr <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gab471bae6413067374ab8d8262533e402">playrho::MulT</a> (const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;A, const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;B) noexcept</td></tr>
<tr class="memdesc:gab471bae6413067374ab8d8262533e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes A^T * B. <br /></td></tr>
<tr class="separator:gab471bae6413067374ab8d8262533e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9c45595993e763f220e4018c3780058"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac9c45595993e763f220e4018c3780058"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gac9c45595993e763f220e4018c3780058">playrho::NextPowerOfTwo</a> (T x) -&gt; decltype((x|(x &gt;&gt; 1u)), T(++x))</td></tr>
<tr class="memdesc:gac9c45595993e763f220e4018c3780058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next largest power of 2.  <a href="group__Math.html#gac9c45595993e763f220e4018c3780058">More...</a><br /></td></tr>
<tr class="separator:gac9c45595993e763f220e4018c3780058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memItemLeft" align="right" valign="top"><a id="ga0c7d2525a406c1f83c0574e46a2cee32"></a>
<a class="el" href="namespaceplayrho.html#a1fc125070a08100d083a1360f7167f87">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">playrho::Normalize</a> (<a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;vector)</td></tr>
<tr class="memdesc:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given vector into a unit vector and returns its original length. <br /></td></tr>
<tr class="separator:ga0c7d2525a406c1f83c0574e46a2cee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1502fbf5063c1f5dbedafe215895ad29"><td class="memTemplParams" colspan="2"><a id="ga1502fbf5063c1f5dbedafe215895ad29"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1502fbf5063c1f5dbedafe215895ad29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1502fbf5063c1f5dbedafe215895ad29">playrho::RoundOff</a> (const T &amp;value, unsigned precision=<a class="el" href="group__Math.html#ga2e94545b5052523414ec03d0e95e2297">DefaultRoundOffPrecission</a>) -&gt; decltype(<a class="el" href="group__FixedMath.html#ga1e3ca7fb2626886c5920bbc5f570a525">round</a>(value *static_cast&lt; T &gt;(precision))/static_cast&lt; T &gt;(precision))</td></tr>
<tr class="memdesc:ga1502fbf5063c1f5dbedafe215895ad29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value. <br /></td></tr>
<tr class="separator:ga1502fbf5063c1f5dbedafe215895ad29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ceb2daa8b41c4834408662c43e5abda"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1ceb2daa8b41c4834408662c43e5abda">playrho::RoundOff</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;value, std::uint32_t precision=<a class="el" href="group__Math.html#ga2e94545b5052523414ec03d0e95e2297">DefaultRoundOffPrecission</a>) -&gt; <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a></td></tr>
<tr class="memdesc:ga1ceb2daa8b41c4834408662c43e5abda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the rounded value of the given value.  <a href="group__Math.html#ga1ceb2daa8b41c4834408662c43e5abda">More...</a><br /></td></tr>
<tr class="separator:ga1ceb2daa8b41c4834408662c43e5abda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30837f12d652c4e51406db0f1cd11a3a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga30837f12d652c4e51406db0f1cd11a3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga30837f12d652c4e51406db0f1cd11a3a">playrho::Secant</a> (const T &amp;target, const U &amp;a1, const T &amp;s1, const U &amp;a2, const T &amp;s2) -&gt; decltype(a1+(target - s1) *(a2 - a1)/(s2 - s1))</td></tr>
<tr class="memdesc:ga30837f12d652c4e51406db0f1cd11a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Secant method.  <a href="group__Math.html#ga30837f12d652c4e51406db0f1cd11a3a">More...</a><br /></td></tr>
<tr class="separator:ga30837f12d652c4e51406db0f1cd11a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dfb22979400417701de8582bb6d76ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga1dfb22979400417701de8582bb6d76ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga1dfb22979400417701de8582bb6d76ad">playrho::Solve</a> (const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt; &amp;mat, const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga1dfb22979400417701de8582bb6d76ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga1dfb22979400417701de8582bb6d76ad">More...</a><br /></td></tr>
<tr class="separator:ga1dfb22979400417701de8582bb6d76ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844e39448ab76470e60db668b1815ee0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga844e39448ab76470e60db668b1815ee0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga844e39448ab76470e60db668b1815ee0">playrho::Solve22</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;b) noexcept -&gt; <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga844e39448ab76470e60db668b1815ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#ga844e39448ab76470e60db668b1815ee0">More...</a><br /></td></tr>
<tr class="separator:ga844e39448ab76470e60db668b1815ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gab5eb451a3aff0db8ef5bcbb3d67a18df">playrho::Solve33</a> (const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;mat, const <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; T &gt; &amp;b) noexcept -&gt; <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves A * x = b, where b is a column vector.  <a href="group__Math.html#gab5eb451a3aff0db8ef5bcbb3d67a18df">More...</a><br /></td></tr>
<tr class="separator:gab5eb451a3aff0db8ef5bcbb3d67a18df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7300e33771c076a6d7236d566b30207"><td class="memTemplParams" colspan="2"><a id="gac7300e33771c076a6d7236d566b30207"></a>
template&lt;class TYPE &gt; </td></tr>
<tr class="memitem:gac7300e33771c076a6d7236d566b30207"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#gac7300e33771c076a6d7236d566b30207">playrho::Square</a> (TYPE t) noexcept -&gt; decltype(t *t)</td></tr>
<tr class="memdesc:gac7300e33771c076a6d7236d566b30207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares the given value. <br /></td></tr>
<tr class="separator:gac7300e33771c076a6d7236d566b30207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="memTemplParams" colspan="2"><a id="ga3410f58d0023e2a0d6ae6ad85da9508c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga3410f58d0023e2a0d6ae6ad85da9508c">playrho::ToSigned</a> (const T &amp;value) -&gt; decltype(static_cast&lt; std::make_signed_t&lt; T &gt;&gt;(value))</td></tr>
<tr class="memdesc:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given value to its closest signed equivalent. <br /></td></tr>
<tr class="separator:ga3410f58d0023e2a0d6ae6ad85da9508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8489f7d571594e36194a437ea93898a"><td class="memItemLeft" align="right" valign="top"><a id="gaa8489f7d571594e36194a437ea93898a"></a>
constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#gaa8489f7d571594e36194a437ea93898a">playrho::Transform</a> (const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;v, const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;A) noexcept</td></tr>
<tr class="memdesc:gaa8489f7d571594e36194a437ea93898a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by a matrix. <br /></td></tr>
<tr class="separator:gaa8489f7d571594e36194a437ea93898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fa159bf4195bff228c3fda9252a5b1"><td class="memTemplParams" colspan="2">template&lt;std::size_t M, typename T1 , std::size_t N, typename T2 &gt; </td></tr>
<tr class="memitem:ga17fa159bf4195bff228c3fda9252a5b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Math.html#ga17fa159bf4195bff228c3fda9252a5b1">playrho::Transform</a> (const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, M &gt; &amp;v, const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T2, M, N &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga17fa159bf4195bff228c3fda9252a5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies an M-element vector by an M-by-N matrix.  <a href="group__Math.html#ga17fa159bf4195bff228c3fda9252a5b1">More...</a><br /></td></tr>
<tr class="separator:ga17fa159bf4195bff228c3fda9252a5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2e94545b5052523414ec03d0e95e2297"><td class="memItemLeft" align="right" valign="top"><a id="ga2e94545b5052523414ec03d0e95e2297"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Math.html#ga2e94545b5052523414ec03d0e95e2297">playrho::DefaultRoundOffPrecission</a> = unsigned{100000}</td></tr>
<tr class="memdesc:ga2e94545b5052523414ec03d0e95e2297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default round-off precision. <br /></td></tr>
<tr class="separator:ga2e94545b5052523414ec03d0e95e2297"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Additional functions for common mathematical operations. </p>
<p>These are non-member non-friend functions for mathematical operations especially those with mixed input and output types. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga994ed50293b78dff53a5c7bce78602bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994ed50293b78dff53a5c7bce78602bf">&#9670;&nbsp;</a></span>AlmostZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::AlmostZero </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespaceplayrho.html#ac862a8609b82126d0683ecb38a498087">abs</a>(value) &lt; std::numeric_limits&lt;T&gt;::min())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether a given value is almost zero. </p>
<p>An almost zero value is "subnormal". Dividing by these values can lead to odd results like a divide by zero trap occurring. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given value is almost zero, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab870a9188fcc77c905807fa718a8268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab870a9188fcc77c905807fa718a8268d">&#9670;&nbsp;</a></span>Atan2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::Atan2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the arc-tangent of the given y and x values. </p>
<dl class="section return"><dt>Returns</dt><dd>Normalized angle - an angle between -Pi and Pi inclusively. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/numeric/math/atan2">https://en.cppreference.com/w/cpp/numeric/math/atan2</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a3b7f2988103c1593f346d2d58e9b4c6c">playrho::d2::GetAngle()</a>, and <a class="el" href="group__Math.html#ga941d2e26e203e19b567a018570417be3">playrho::GetAngle()</a>.</p>

</div>
</div>
<a id="gad9807960f6f6e39b0449aec22d646669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9807960f6f6e39b0449aec22d646669">&#9670;&nbsp;</a></span>Bisect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Bisect </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((a1 + a2) / 2)
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bisection method. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Bisection_method">https://en.wikipedia.org/wiki/Bisection_method</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1ToiOutput.html#a19b308c9b3b8f5292b9f3dad183c9d76">playrho::ToiOutput::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="ga3f6e8b69eaeee408d3894b59629cffe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f6e8b69eaeee408d3894b59629cffe9">&#9670;&nbsp;</a></span>cfloor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::cfloor </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant expression enhanced floor function. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike <code>std::floor</code>, this function is only defined for finite values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/numeric/math/floor">https://en.cppreference.com/w/cpp/numeric/math/floor</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized()</a>, and <a class="el" href="structplayrho_1_1d2_1_1Position.html#a30e3652aa86130f81c948112cf4538d6">playrho::d2::Position::GetPosition()</a>.</p>

</div>
</div>
<a id="gae769785f0540a4b8960b282f6b105c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae769785f0540a4b8960b282f6b105c14">&#9670;&nbsp;</a></span>ComputeCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> playrho::ComputeCentroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the centroid of a counter-clockwise array of 3 or more vertices. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vertices</code> Has 3 or more elements and they're in counter-clockwise order. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1PolygonShapeConf.html#a83aaa3b7748b0f34ac7afb4e29b0c51e">playrho::d2::PolygonShapeConf::Set()</a>.</p>

</div>
</div>
<a id="gab5164277624274fde39d33fd4f0f5dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5164277624274fde39d33fd4f0f5dd5">&#9670;&nbsp;</a></span>Cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , std::enable_if_t&lt; std::tuple_size_v&lt; T1 &gt;==2 &amp;&amp;std::tuple_size_v&lt; T2 &gt;==2, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Cross </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the 2-element analog of the cross product of two vectors. </p>
<p>Cross-products the given two values.</p>
<p>Defined as the result of: <code>(a.x * b.y) - (a.y * b.x)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is dimension squashing. I.e. A cross of a 2-D length by a 2-D unit vector results in a 1-D length value. </dd>
<dd>
The unit of the result is the 1-D product of the inputs. </dd>
<dd>
This operation is anti-commutative. I.e. Cross(a, b) == -Cross(b, a). </dd>
<dd>
The result will be 0 if any of the following are true: vector A or vector B has a length of zero; vectors A and B point in the same direction; or vectors A and B point in exactly opposite direction of each other. </dd>
<dd>
The result will be positive if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of greater than 0 and less than 180 degrees (counter-clockwise from A being a positive angle). </dd>
<dd>
Result will be negative if: neither vector A nor B has a length of zero; and vector B is at an angle from vector A of less than 0 and greater than -180 degrees (clockwise from A being a negative angle). </dd>
<dd>
The absolute value of the result is the area of the parallelogram formed by the vectors A and B.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product of the two values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation is anti-commutative. I.e. Cross(a, b) == -Cross(b, a). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Cross_product">https://en.wikipedia.org/wiki/Cross_product</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value A of a 3-element type. </td></tr>
    <tr><td class="paramname">b</td><td>Value B of a 3-element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cross product of the two values. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1World.html#aa4467a2050404136d210f7d81017f2d6">playrho::d2::World::ApplyForce()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#a822028bbec557a6caf1040105f78244f">playrho::d2::Body::ApplyLinearImpulse()</a>, <a class="el" href="classplayrho_1_1d2_1_1Simplex.html#a21f4fbe4f435a497f723ba4692745d13">playrho::d2::Simplex::CalcMetric()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a8eafa8c052954d863e81d00251d51194">playrho::d2::CalcSearchDirection()</a>, <a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">playrho::ComputeCentroid()</a>, <a class="el" href="classplayrho_1_1d2_1_1Simplex.html#ab745b96a84c8e8340e8abf7efbfd3c69">playrho::d2::Simplex::Get()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ae1538594ce2f0d86da70bf832c0327bb">playrho::d2::GetConvexHullAsVector()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ab0e7f6b99f8d46a62c739d0df5ba8c1d">playrho::d2::GetEffectiveInvMass()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a7304da106cfaa394b4d0179ded468aa6">playrho::d2::GetMassData()</a>, <a class="el" href="group__Math.html#gaee743e28b24b01d9101b8a2e7bd72284">playrho::GetPolarMoment()</a>, <a class="el" href="group__Math.html#ga39333b6fc4de2a8f365b74194e42ceef">playrho::GetSymInverse33()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a04f5087d761eecd8554b6156d1cc3021">playrho::d2::DistanceJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1FrictionJointConf.html#a904a7c9eb12d39f5331d70e31bfc5aa3">playrho::d2::FrictionJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a6fb896d2cd2716bc5313edf9664311dd">playrho::d2::GearJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1MotorJointConf.html#a2b683394550bdac7d8ff211bf659cc79">playrho::d2::MotorJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#ac1c8f45842be63b34da6d53d811881db">playrho::d2::PrismaticJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html#a4bc9c62ac7aaef84c0c536a1b439ccf9">playrho::d2::PulleyJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#a7b32961588123ecf24d8c176b39be0b8">playrho::d2::RevoluteJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html#a0fa82bd7d2ebe576faf0ceac30982870">playrho::d2::RopeJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a1bc16ad22662f69d6218f879a5c17245">playrho::d2::TargetJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#ad9a429415a87a06a9134b001d73bf508">playrho::d2::WeldJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a9e194ef30b3a342a38f9afc09c629f6d">playrho::d2::WheelJointConf::InitVelocity()</a>, <a class="el" href="group__Math.html#ga01639d99c5401d526aeb5c6df075e153">playrho::Invert()</a>, <a class="el" href="group__RayCastGroup.html#gabc2e992343e201f48c1956753a530247">playrho::d2::DistanceProxy::RayCast()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#adb7f803accaca7a22ef4ba09067c4eea">playrho::d2::World::SetForce()</a>, <a class="el" href="group__Math.html#ga1dfb22979400417701de8582bb6d76ad">playrho::Solve()</a>, <a class="el" href="group__Math.html#gab5eb451a3aff0db8ef5bcbb3d67a18df">playrho::Solve33()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a1cb4cf206219920fd02778200b00d623">playrho::d2::DistanceJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a5a54a7c5cb24901f677963106f310fec">playrho::d2::GearJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a9781e7946b790d5697f7692de702ab82">playrho::d2::PrismaticJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html#afa2b76fbf75674d72e4bab581590eec4">playrho::d2::PulleyJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#a15b5d820404f01071ece796f787c4fab">playrho::d2::RevoluteJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html#a168b27b3bf6ef8dec62708dd2037abcb">playrho::d2::RopeJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a0a2a5151fb0a799e0d2f0a84e4534b94">playrho::d2::WeldJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a14e495be301fc95b5f890716f9e51309">playrho::d2::WheelJointConf::SolvePosition()</a>, <a class="el" href="ContactSolver_8hpp.html#a0fd21d441a78194f210e9f900bd3d1a4">playrho::GaussSeidel::SolvePositionConstraint()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a9b2e8c358061fcd3724da3c1cb5fcc32">playrho::d2::DistanceJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1FrictionJointConf.html#a6072ec80a0f6f19ddf2bbc57abe6110a">playrho::d2::FrictionJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1MotorJointConf.html#a9fbbab76d642be0211f8c76334ccbe0f">playrho::d2::MotorJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html#ac62c3b05e95c61b801722de099d962de">playrho::d2::PulleyJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#aa27f190089266d9d8de1d9f3ae963999">playrho::d2::RevoluteJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html#a67249c115b7b84fc2a58abc83664c934">playrho::d2::RopeJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a87f0cb382d657fcac4402b3896269fe3">playrho::d2::TargetJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a25cfb7a5d3d5f2aeef028803b37454da">playrho::d2::WeldJointConf::SolveVelocity()</a>, and <a class="el" href="namespaceplayrho_1_1d2.html#a0254e96c6b1df87a80cf44dc29fc2017">playrho::d2::Validate()</a>.</p>

</div>
</div>
<a id="gaff0508a648e02202d025b83e46973e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff0508a648e02202d025b83e46973e45">&#9670;&nbsp;</a></span>ctrunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::ctrunc </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant expression enhanced truncate function. </p>
<dl class="section note"><dt>Note</dt><dd>Unlike <code>std::trunc</code>, this function is only defined for finite values. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.cppreference.com/w/cpp/numeric/math/trunc">https://en.cppreference.com/w/cpp/numeric/math/trunc</a> </dd></dl>

</div>
</div>
<a id="ga08e3eae87277d85db13cce6b12facf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08e3eae87277d85db13cce6b12facf1e">&#9670;&nbsp;</a></span>Dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Dot </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the dot product on two vectors (A and B). </p>
<p>The dot product of two vectors is defined as: the magnitude of vector A, multiplied by, the magnitude of vector B, multiplied by, the cosine of the angle between the two vectors (A and B). Thus the dot product of two vectors is a value ranging between plus and minus the magnitudes of each vector times each other. The middle value of 0 indicates that two vectors are perpendicular to each other (at an angle of +/- 90 degrees from each other).</p>
<dl class="section note"><dt>Note</dt><dd>This operation is commutative. I.e. Dot(a, b) == Dot(b, a). </dd>
<dd>
If A and B are the same vectors, <code>GetMagnitudeSquared(Vec2)</code> returns the same value using effectively one less input parameter. </dd>
<dd>
This is similar to the <code>std::inner_product</code> standard library algorithm except benchmark tests suggest this implementation is faster at least for <code>Vec2</code> like instances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Dot_product">https://en.wikipedia.org/wiki/Dot_product</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> A. </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> B.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dot product of the vectors (0 means the two vectors are perpendicular). </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a073a93c54a20aa68f2c56e759b7976ab">playrho::d2::ClipSegmentToLine()</a>, <a class="el" href="classplayrho_1_1d2_1_1Simplex.html#a67974276b721135016f384f5475990ef">playrho::d2::Simplex::Get()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#a2e2f7487e6bca2b26a9dc6779a9bc72b">playrho::d2::World::GetGearJointConf()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#a0469ef558d7b14efb4792c7f24084d7e">playrho::d2::World::GetJointTranslation()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#ab7b59db43cee6a26c0433b69476b0c9b">playrho::d2::World::GetLinearVelocity()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ac457cb117f43c867a553087e91608ce7">playrho::d2::GetManifold()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a0ae59f7bcf03f75dd6aa405683e455b9">playrho::d2::GetSeparationScenario()</a>, <a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html#a6cfc27f1644f9c4d6da229b5eba07e51">playrho::d2::DistanceProxy::GetSupportIndex()</a>, <a class="el" href="group__Math.html#ga39333b6fc4de2a8f365b74194e42ceef">playrho::GetSymInverse33()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#ac1c8f45842be63b34da6d53d811881db">playrho::d2::PrismaticJointConf::InitVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a9e194ef30b3a342a38f9afc09c629f6d">playrho::d2::WheelJointConf::InitVelocity()</a>, <a class="el" href="group__Math.html#ga68c69326c22bafb811d6e00b9e6966cc">playrho::InverseTransform()</a>, <a class="el" href="group__Math.html#gab471bae6413067374ab8d8262533e402">playrho::MulT()</a>, <a class="el" href="group__RayCastGroup.html#gaa2b257514c434e44a5ea5839c959bea9">playrho::d2::RayCast()</a>, <a class="el" href="group__Math.html#gab5eb451a3aff0db8ef5bcbb3d67a18df">playrho::Solve33()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a5a54a7c5cb24901f677963106f310fec">playrho::d2::GearJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a9781e7946b790d5697f7692de702ab82">playrho::d2::PrismaticJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a14e495be301fc95b5f890716f9e51309">playrho::d2::WheelJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1DistanceJointConf.html#a9b2e8c358061fcd3724da3c1cb5fcc32">playrho::d2::DistanceJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#ab274b1bb66255adc6ad6fe9ea22fbe5c">playrho::d2::GearJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a6ee4f0a073351cace3dc1ba478411140">playrho::d2::PrismaticJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1PulleyJointConf.html#ac62c3b05e95c61b801722de099d962de">playrho::d2::PulleyJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1RopeJointConf.html#a67249c115b7b84fc2a58abc83664c934">playrho::d2::RopeJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1WheelJointConf.html#a6474e7647ffafa7698e6b2fb0282f3cc">playrho::d2::WheelJointConf::SolveVelocity()</a>, and <a class="el" href="group__TestPointGroup.html#gab8505b0b58d03f1d6f7c702d9db632c9">playrho::d2::DistanceProxy::TestPoint()</a>.</p>

</div>
</div>
<a id="ga941d2e26e203e19b567a018570417be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941d2e26e203e19b567a018570417be3">&#9670;&nbsp;</a></span>GetAngle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> playrho::GetAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the angle. </p>
<dl class="section return"><dt>Returns</dt><dd>Angular value in the range of -Pi to +Pi radians. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Body.html#abb921582a11b07be4c8ac81c43787176">playrho::d2::Body::SetAcceleration()</a>, and <a class="el" href="classplayrho_1_1d2_1_1Body.html#ad4c0253fd8704a22847a80fd634620a2">playrho::d2::Body::SetTransformation()</a>.</p>

</div>
</div>
<a id="ga760effc058042418453697e733937b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760effc058042418453697e733937b2f">&#9670;&nbsp;</a></span>GetAreaOfPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CheckedTypes.html#gafcee23e546ebf8053221fa14741f0dc9">NonNegativeFF</a>&lt; <a class="el" href="group__PhysicalQuantities.html#ga708ceb55bdc6043d445776d1886802eb">Area</a> &gt; playrho::GetAreaOfPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the area of a polygon. </p>
<dl class="section note"><dt>Note</dt><dd>This function is valid for any non-self-intersecting (simple) polygon, which can be convex or concave. </dd>
<dd>
Winding order doesn't matter. </dd></dl>

</div>
</div>
<a id="ga5d41854b91fcfb6b8ea05e7b8c92e304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d41854b91fcfb6b8ea05e7b8c92e304">&#9670;&nbsp;</a></span>GetFwdRotationalAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> playrho::GetFwdRotationalAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the forward/clockwise rotational angle to go from angle 1 to angle 2. </p>
<dl class="section return"><dt>Returns</dt><dd>Angular rotation in the clockwise direction to go from angle 1 to angle 2. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a5a54a7c5cb24901f677963106f310fec">playrho::d2::GearJointConf::SolvePosition()</a>.</p>

</div>
</div>
<a id="ga0a9354b34edeb8433cd3062aecb78143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a9354b34edeb8433cd3062aecb78143">&#9670;&nbsp;</a></span>GetInverse22()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetInverse22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the inverse of the given matrix as a 2-by-2. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#ad9a429415a87a06a9134b001d73bf508">playrho::d2::WeldJointConf::InitVelocity()</a>.</p>

</div>
</div>
<a id="gafe323c1c5ab88d30d18413a3c1f10abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe323c1c5ab88d30d18413a3c1f10abb">&#9670;&nbsp;</a></span>GetMagnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::GetMagnitude </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="group__FixedMath.html#ga7a9d7e9855b45a3b4103632a47ccd6f4">sqrt</a>(<a class="el" href="group__Math.html#ga36866f7061dfa4d056405aa5da0daf84">GetMagnitudeSquared</a>(value)))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the magnitude of the given value. </p>
<dl class="section note"><dt>Note</dt><dd>Works for any type for which <code>GetMagnitudeSquared</code> also works. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="DistanceJoint_8cpp-example.html#a28">DistanceJoint.cpp</a>, <a class="el" href="PulleyJoint_8cpp-example.html#a28">PulleyJoint.cpp</a>, and <a class="el" href="World_8cpp-example.html#a123">World.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1Simplex.html#a21f4fbe4f435a497f723ba4692745d13">playrho::d2::Simplex::CalcMetric()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#ae563375c4aff49f02b9ecab9dce5fc62">playrho::d2::World::GetCentripetalForce()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#afd81bf06efee4b29f2490134f52baddc">playrho::d2::World::GetCurrentLengthA()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#a11679510e7348f8480d317a02ba3e2aa">playrho::d2::World::GetCurrentLengthB()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#aeca593754c5f10e69f145526786978fe">playrho::d2::World::GetDistanceJointConf()</a>, <a class="el" href="classplayrho_1_1d2_1_1ChainShapeConf.html#acf3a62f07bbb6fdaeb1cbc962d62feb8">playrho::d2::ChainShapeConf::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a32e1a0772998ac59c02ff4b1a7981343">playrho::d2::GetMassData()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#a52974eadc9023357fc460b5392160a0e">playrho::d2::World::GetPulleyJointConf()</a>, <a class="el" href="group__Math.html#ga0c7d2525a406c1f83c0574e46a2cee32">playrho::Normalize()</a>, and <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a0a2a5151fb0a799e0d2f0a84e4534b94">playrho::d2::WeldJointConf::SolvePosition()</a>.</p>

</div>
</div>
<a id="ga36866f7061dfa4d056405aa5da0daf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36866f7061dfa4d056405aa5da0daf84">&#9670;&nbsp;</a></span>GetMagnitudeSquared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetMagnitudeSquared </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the square of the magnitude of the given iterable value. </p>
<dl class="section note"><dt>Note</dt><dd>For performance, use this instead of <code>GetMagnitude(T value)</code> (if possible). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Non-negative value from 0 to infinity, or NaN. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1World.html#a145bc2034162d0e6684d8d606211fb5e">playrho::d2::World::CalcGravitationalAcceleration()</a>, <a class="el" href="structplayrho_1_1d2_1_1Position.html#a2fd12fe4d010345504eeee95534dbed6">playrho::d2::Position::Cap()</a>, <a class="el" href="structplayrho_1_1d2_1_1Velocity.html#a3d2551fe26d1aa448d4d4b337e5aa66c">playrho::d2::Velocity::Cap()</a>, <a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html#ad01443fd4ea346d550ece90f7f92b1f4">playrho::d2::DistanceProxy::Distance()</a>, <a class="el" href="classplayrho_1_1d2_1_1VertexSet.html#a14cdd5584f6eb0bf44942c2a72b00167">playrho::d2::VertexSet::find()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#a678b061692e87f71d512b8bb80f9377d">playrho::d2::World::FindClosestBody()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ae1538594ce2f0d86da70bf832c0327bb">playrho::d2::GetConvexHullAsVector()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#accc0736257251f381353661320af972e">playrho::d2::Body::GetLocalRotInertia()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#ad374df7cc8d1a5a9a186e0ae8a7c8cb3">playrho::d2::World::GetLocalRotInertia()</a>, <a class="el" href="group__Math.html#gafe323c1c5ab88d30d18413a3c1f10abb">playrho::GetMagnitude()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ac457cb117f43c867a553087e91608ce7">playrho::d2::GetManifold()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ad7dc3397566d3b0447d318e67761bbc2">playrho::d2::GetMassData()</a>, <a class="el" href="structplayrho_1_1ToiOutput.html#a19b308c9b3b8f5292b9f3dad183c9d76">playrho::ToiOutput::GetToiViaSat()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a9af102f967f219132acef68f51888f5c">playrho::d2::IsUnderActive()</a>, <a class="el" href="group__RayCastGroup.html#gaa2b257514c434e44a5ea5839c959bea9">playrho::d2::RayCast()</a>, <a class="el" href="classplayrho_1_1d2_1_1Body.html#abb921582a11b07be4c8ac81c43787176">playrho::d2::Body::SetAcceleration()</a>, <a class="el" href="classplayrho_1_1d2_1_1World.html#abe6b45c9a1aeec496d83c00a6f587740">playrho::d2::World::SetMassData()</a>, <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a5a54a7c5cb24901f677963106f310fec">playrho::d2::GearJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#a15b5d820404f01071ece796f787c4fab">playrho::d2::RevoluteJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1FrictionJointConf.html#a6072ec80a0f6f19ddf2bbc57abe6110a">playrho::d2::FrictionJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1MotorJointConf.html#a9fbbab76d642be0211f8c76334ccbe0f">playrho::d2::MotorJointConf::SolveVelocity()</a>, <a class="el" href="structplayrho_1_1d2_1_1TargetJointConf.html#a87f0cb382d657fcac4402b3896269fe3">playrho::d2::TargetJointConf::SolveVelocity()</a>, <a class="el" href="classplayrho_1_1d2_1_1DistanceProxy.html#a3a575c58f1a4cde929feb45c68617bd9">playrho::d2::DistanceProxy::TestOverlap()</a>, and <a class="el" href="group__TestPointGroup.html#gab8505b0b58d03f1d6f7c702d9db632c9">playrho::d2::DistanceProxy::TestPoint()</a>.</p>

</div>
</div>
<a id="ga81dbf936e69c8d2ecc9ca3600c6be3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81dbf936e69c8d2ecc9ca3600c6be3a1">&#9670;&nbsp;</a></span>GetModuloNext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetModuloNext </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(++value, (value &lt; count)? value: static_cast&lt;T&gt;(0), T())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the modulo next value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>To get the modulo next value for. </td></tr>
    <tr><td class="paramname">count</td><td>Count to wrap around at. Must be greater-than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>value</code> is less than <code>count</code>. </dd>
<dd>
<code>count</code> is greater-than zero. </dd>
<dd>
<code>value</code> plus one is greater-than zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga6434759234bd5e94759bf10cc4eb5ac5" title="Gets the modulo previous value.">GetModuloPrev</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#gae769785f0540a4b8960b282f6b105c14">playrho::ComputeCentroid()</a>, <a class="el" href="classplayrho_1_1d2_1_1ConvexHull.html#a678ba0811f2975d1cdba6bfca49005eb">playrho::d2::ConvexHull::Get()</a>, <a class="el" href="group__Math.html#ga760effc058042418453697e733937b2f">playrho::GetAreaOfPolygon()</a>, <a class="el" href="classplayrho_1_1d2_1_1PolygonShapeConf.html#a066828295fc1238756f5adf1f3502343">playrho::d2::PolygonShapeConf::GetEdge()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ac457cb117f43c867a553087e91608ce7">playrho::d2::GetManifold()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#a7304da106cfaa394b4d0179ded468aa6">playrho::d2::GetMassData()</a>, <a class="el" href="namespaceplayrho_1_1d2.html#ac7d699f052c62efd80ce28f0190d70af">playrho::d2::GetNextIndex()</a>, <a class="el" href="group__Math.html#gaee743e28b24b01d9101b8a2e7bd72284">playrho::GetPolarMoment()</a>, <a class="el" href="group__RayCastGroup.html#gabc2e992343e201f48c1956753a530247">playrho::d2::DistanceProxy::RayCast()</a>, <a class="el" href="group__TestPointGroup.html#gab8505b0b58d03f1d6f7c702d9db632c9">playrho::d2::DistanceProxy::TestPoint()</a>, and <a class="el" href="namespaceplayrho_1_1d2.html#a0254e96c6b1df87a80cf44dc29fc2017">playrho::d2::Validate()</a>.</p>

</div>
</div>
<a id="ga6434759234bd5e94759bf10cc4eb5ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6434759234bd5e94759bf10cc4eb5ac5">&#9670;&nbsp;</a></span>GetModuloPrev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetModuloPrev </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype((value ? value : count) - static_cast&lt;T&gt;(1), T())
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the modulo previous value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>To get the modulo previous value for. </td></tr>
    <tr><td class="paramname">count</td><td>Count to wrap around at. Must be greater-than zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>count</code> is greater-than zero and <code>value</code> is less than <code>count</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga81dbf936e69c8d2ecc9ca3600c6be3a1" title="Gets the modulo next value.">GetModuloNext</a>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga760effc058042418453697e733937b2f">playrho::GetAreaOfPolygon()</a>.</p>

</div>
</div>
<a id="ga156a2abff11f978a8df25efbf0c10147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156a2abff11f978a8df25efbf0c10147">&#9670;&nbsp;</a></span>GetNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> playrho::GetNormalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the "normalized" value of the given angle. </p>
<dl class="section note"><dt>Note</dt><dd>An angle of zero (0), represents the positive X-axis. </dd>
<dd>
Both -Pi and +Pi normalize to -Pi. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A finite angular value. Behavior of this function is not defined if given a non-finite value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Angle that's greater than or equal to -Pi and that's less than +Pi radians. I.e. the value returned will be a value within the half-open interval of [-Pi, +Pi). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#gab870a9188fcc77c905807fa718a8268d" title="Computes the arc-tangent of the given y and x values.">Atan2</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a5955bf7b1c0cdfa36d11adea236d9af4">playrho::d2::GetNormalized()</a>, <a class="el" href="classplayrho_1_1d2_1_1Sweep.html#a09b21383c1a73afea37f11e0ba906a76">playrho::d2::Sweep::GetNormalized()</a>, and <a class="el" href="group__Math.html#gac9b72aa4a587e552a586a42494d614c1">playrho::GetShortestDelta()</a>.</p>

</div>
</div>
<a id="gaee743e28b24b01d9101b8a2e7bd72284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee743e28b24b01d9101b8a2e7bd72284">&#9670;&nbsp;</a></span>GetPolarMoment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#ga687546b31c191aeeacf223bdbebe6747">SecondMomentOfArea</a> playrho::GetPolarMoment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplayrho_1_1Span.html">Span</a>&lt; const <a class="el" href="namespaceplayrho.html#a7dc68cd0ce177e175ae0bb6c39db158d">Length2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the polar moment of the area enclosed by the given vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>Collection of three or more vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>vertices</code> has 3 or more elements. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespaceplayrho_1_1d2.html#a32e1a0772998ac59c02ff4b1a7981343">playrho::d2::GetMassData()</a>.</p>

</div>
</div>
<a id="ga1413e02cc41bf9943071baa2ae242c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1413e02cc41bf9943071baa2ae242c27">&#9670;&nbsp;</a></span>GetRevRotationalAngle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> playrho::GetRevRotationalAngle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reverse (counter) clockwise rotational angle to go from angle 1 to angle 2. </p>
<dl class="section return"><dt>Returns</dt><dd>Angular rotation in the counter clockwise direction to go from angle 1 to angle 2. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1GearJointConf.html#a5a54a7c5cb24901f677963106f310fec">playrho::d2::GearJointConf::SolvePosition()</a>.</p>

</div>
</div>
<a id="gac9b72aa4a587e552a586a42494d614c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b72aa4a587e552a586a42494d614c1">&#9670;&nbsp;</a></span>GetShortestDelta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a> playrho::GetShortestDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PhysicalQuantities.html#gabb35ed422281bfdf3c41a276958898fc">Angle</a>&#160;</td>
          <td class="paramname"><em>a1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the shortest angular distance to go from angle 0 to angle 1. </p>
<p>This gets the angle to rotate angle 0 by, in order to get to angle 1, with the least amount of rotation. </p><dl class="section return"><dt>Returns</dt><dd>Angle between -Pi and Pi radians inclusively. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147" title="Gets the &quot;normalized&quot; value of the given angle.">GetNormalized</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1Position.html#a30e3652aa86130f81c948112cf4538d6">playrho::d2::Position::GetPosition()</a>.</p>

</div>
</div>
<a id="ga39333b6fc4de2a8f365b74194e42ceef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39333b6fc4de2a8f365b74194e42ceef">&#9670;&nbsp;</a></span>GetSymInverse33()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::GetSymInverse33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the symmetric inverse of this matrix as a 3-by-3. </p>
<dl class="section return"><dt>Returns</dt><dd>Zero matrix if singular. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#ad9a429415a87a06a9134b001d73bf508">playrho::d2::WeldJointConf::InitVelocity()</a>.</p>

</div>
</div>
<a id="ga68c69326c22bafb811d6e00b9e6966cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68c69326c22bafb811d6e00b9e6966cc">&#9670;&nbsp;</a></span>InverseTransform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> playrho::InverseTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a02c09bb6556e3168c0085871358d2f71">Mat22</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform). </p>

</div>
</div>
<a id="ga96fac7df522251c1cc54aeafbfe3b737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96fac7df522251c1cc54aeafbfe3b737">&#9670;&nbsp;</a></span>IsOdd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::IsOdd </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; decltype((val % 2) != T{})
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is-odd. </p>
<p>Determines whether the given integral value is odd (as opposed to being even). </p>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1ToiOutput.html#a19b308c9b3b8f5292b9f3dad183c9d76">playrho::ToiOutput::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="gab53c16bcb68dd36d3b18027a2ac6b1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab53c16bcb68dd36d3b18027a2ac6b1b2">&#9670;&nbsp;</a></span>ModuloViaFmod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::ModuloViaFmod </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modulo operation using <code>std::fmod</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Modulo via <code>std::fmod</code> appears slower than via <code>std::trunc</code>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#ga84e7cb2a415fcb956202c8d7e1b1d200" title="Modulo operation using std::trunc.">ModuloViaTrunc</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized()</a>.</p>

</div>
</div>
<a id="ga84e7cb2a415fcb956202c8d7e1b1d200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e7cb2a415fcb956202c8d7e1b1d200">&#9670;&nbsp;</a></span>ModuloViaTrunc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::ModuloViaTrunc </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modulo operation using <code>std::trunc</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Modulo via <code>std::fmod</code> appears slower than via <code>std::trunc</code>. </dd>
<dd>
This function won't behave like <code>ModuloViaFmod</code> when divisor is infinite. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dividend</td><td>Dividend value for which <code>isfinite</code> returns true. </td></tr>
    <tr><td class="paramname">divisor</td><td>Divisor value for which <code>isfinite</code> returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Math.html#gab53c16bcb68dd36d3b18027a2ac6b1b2" title="Modulo operation using std::fmod.">ModuloViaFmod</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__Math.html#ga156a2abff11f978a8df25efbf0c10147">playrho::GetNormalized()</a>, and <a class="el" href="group__Math.html#gac9b72aa4a587e552a586a42494d614c1">playrho::GetShortestDelta()</a>.</p>

</div>
</div>
<a id="gac9c45595993e763f220e4018c3780058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9c45595993e763f220e4018c3780058">&#9670;&nbsp;</a></span>NextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::NextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype((x | (x &gt;&gt; 1u)), T(++x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the next largest power of 2. </p>
<p>Given a binary integer value x, the next largest power of 2 can be computed by a S.W.A.R. algorithm that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with the same most significant 1 as x, but all one's below it. Adding 1 to that value yields the next largest power of 2. </p>

<p class="reference">Referenced by <a class="el" href="classplayrho_1_1d2_1_1DynamicTree.html#ad1fa3e1b69c47356cee7809d9137d7a0">playrho::d2::DynamicTree::Reserve()</a>.</p>

</div>
</div>
<a id="ga1ceb2daa8b41c4834408662c43e5abda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ceb2daa8b41c4834408662c43e5abda">&#9670;&nbsp;</a></span>RoundOff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto playrho::RoundOff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>precision</em> = <code><a class="el" href="group__Math.html#ga2e94545b5052523414ec03d0e95e2297">DefaultRoundOffPrecission</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceplayrho.html#ad93c0cd83df090aba6593ffac4b628ec">Vec2</a>
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the rounded value of the given value. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Consider making this function generic to any <code><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a></code>. </dd></dl>

</div>
</div>
<a id="ga30837f12d652c4e51406db0f1cd11a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30837f12d652c4e51406db0f1cd11a3a">&#9670;&nbsp;</a></span>Secant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Secant </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(a1 + (target - s1) * (a2 - a1) / (s2 - s1))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Secant method. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Secant_method">https://en.wikipedia.org/wiki/Secant_method</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1ToiOutput.html#a19b308c9b3b8f5292b9f3dad183c9d76">playrho::ToiOutput::GetToiViaSat()</a>.</p>

</div>
</div>
<a id="ga1dfb22979400417701de8582bb6d76ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dfb22979400417701de8582bb6d76ad">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a26aabbb6723402cb9e12cf32e17beebc">Matrix22</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a9781e7946b790d5697f7692de702ab82">playrho::d2::PrismaticJointConf::SolvePosition()</a>, and <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#a15b5d820404f01071ece796f787c4fab">playrho::d2::RevoluteJointConf::SolvePosition()</a>.</p>

</div>
</div>
<a id="ga844e39448ab76470e60db668b1815ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga844e39448ab76470e60db668b1815ee0">&#9670;&nbsp;</a></span>Solve22()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Solve22 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceplayrho.html#a97243f194a9406d0fdcf5f6f833851ab">Vector2</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd>
<dd>
Solves only the upper 2-by-2 matrix equation. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a0a2a5151fb0a799e0d2f0a84e4534b94">playrho::d2::WeldJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a6ee4f0a073351cace3dc1ba478411140">playrho::d2::PrismaticJointConf::SolveVelocity()</a>, and <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#aa27f190089266d9d8de1d9f3ae963999">playrho::d2::RevoluteJointConf::SolveVelocity()</a>.</p>

</div>
</div>
<a id="gab5eb451a3aff0db8ef5bcbb3d67a18df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5eb451a3aff0db8ef5bcbb3d67a18df">&#9670;&nbsp;</a></span>Solve33()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Solve33 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#aabd44d74c5bc530c9b6676c6a61e6b31">Mat33</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceplayrho.html#ad07b44f811ac4c7551067fb1d3554ec5">Vector3</a>&lt;T&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves A * x = b, where b is a column vector. </p>
<dl class="section note"><dt>Note</dt><dd>This is more efficient than computing the inverse in one-shot cases. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a9781e7946b790d5697f7692de702ab82">playrho::d2::PrismaticJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1WeldJointConf.html#a0a2a5151fb0a799e0d2f0a84e4534b94">playrho::d2::WeldJointConf::SolvePosition()</a>, <a class="el" href="structplayrho_1_1d2_1_1PrismaticJointConf.html#a6ee4f0a073351cace3dc1ba478411140">playrho::d2::PrismaticJointConf::SolveVelocity()</a>, and <a class="el" href="structplayrho_1_1d2_1_1RevoluteJointConf.html#aa27f190089266d9d8de1d9f3ae963999">playrho::d2::RevoluteJointConf::SolveVelocity()</a>.</p>

</div>
</div>
<a id="ga17fa159bf4195bff228c3fda9252a5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17fa159bf4195bff228c3fda9252a5b1">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t M, typename T1 , std::size_t N, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto playrho::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structplayrho_1_1Vector.html">Vector</a>&lt; T1, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplayrho.html#acbf97bd8e3f0f2ce4588735388f4089a">Matrix</a>&lt; T2, M, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies an M-element vector by an M-by-N matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="structplayrho_1_1Vector.html" title="Vector.">Vector</a> that's interpreted as a matrix with 1 row and M-columns. </td></tr>
    <tr><td class="paramname">m</td><td>An M-row by N-column <em>transformation matrix</em> to multiply the vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://en.wikipedia.org/wiki/Transformation_matrix">https://en.wikipedia.org/wiki/Transformation_matrix</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 3 2023 14:40:21 for PlayRho by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
